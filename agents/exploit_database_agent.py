"""
Weaponized Exploit Database Agent
รวบรวมและค้นหา exploits จาก GitHub, ExploitDB, และ Nuclei Templates
"""

import asyncio
import hashlib
import os
import json
import re
from typing import Dict, List, Any, Optional
from datetime import datetime

import aiohttp

from core.base_agent import BaseAgent
from core.data_models import AgentData, AttackPhase
from core.logger import log


class ExploitDatabaseAgent(BaseAgent):
    """
    Weaponized Exploit Database Agent
    
    Features:
    - Search GitHub for POC exploits
    - Query ExploitDB
    - Search Nuclei templates
    - CVE lookup and mapping
    - Auto-download and organize exploits
    - Exploit verification
    """
    
    supported_phases = [AttackPhase.RECONNAISSANCE, AttackPhase.EXPLOITATION]
    required_tools = []

    def __init__(self, context_manager=None, orchestrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        workspace_dir = os.getenv("WORKSPACE_DIR", "workspace"); self.results_dir = os.path.join(workspace_dir, "loot", "exploits")
        self.exploits_dir = os.path.join(workspace_dir, "exploits")
        os.makedirs(self.results_dir, exist_ok=True)
        os.makedirs(self.exploits_dir, exist_ok=True)
        
        # GitHub API
        self.github_api = "https://api.github.com"
        self.github_search_api = f"{self.github_api}/search/repositories"
        
        # ExploitDB
        self.exploitdb_api = "https://www.exploit-db.com/search"
        
        # Nuclei Templates
        self.nuclei_templates_repo = "https://github.com/projectdiscovery/nuclei-templates"

    async def run(self, directive: str, context: Dict[str, Any]) -> AgentData:
        """
        Main execution method
        
        Args:
            directive: "search", "download", "verify", "update"
            context: {
                "cve": CVE ID (e.g., "CVE-2021-44228"),
                "keyword": search keyword,
                "product": product name,
                "version": product version
            }
        """
        log.info(f"[ExploitDatabaseAgent] Starting with directive: {directive}")

        try:
            if directive == "search":
                result = await self._search_exploits(context)
            elif directive == "download":
                result = await self._download_exploits(context)
            elif directive == "verify":
                result = await self._verify_exploits(context)
            elif directive == "update":
                result = await self._update_database(context)
            else:
                result = await self._search_exploits(context)
            
            return AgentData(
                agent_name="ExploitDatabaseAgent",
                success=result.get("success", False),
                data=result
            )
            
        except Exception as e:
            log.error(f"[ExploitDatabaseAgent] Error: {e}")
            return AgentData(
                agent_name="ExploitDatabaseAgent",
                success=False,
                data={"error": str(e)}
            )

    async def _search_exploits(self, context: Dict) -> Dict:
        """Search for exploits"""
        log.info("[ExploitDatabaseAgent] Searching for exploits...")
        
        cve = context.get("cve")
        keyword = context.get("keyword")
        product = context.get("product")
        
        if not any([cve, keyword, product]):
            return {
                "success": False,
                "error": "Need at least one of: cve, keyword, or product"
            }
        
        all_exploits = []
        
        # Search GitHub
        log.info("[ExploitDatabaseAgent] Searching GitHub...")
        github_exploits = await self._search_github(cve, keyword, product)
        all_exploits.extend(github_exploits)
        
        # Search ExploitDB
        log.info("[ExploitDatabaseAgent] Searching ExploitDB...")
        exploitdb_exploits = await self._search_exploitdb(cve, keyword, product)
        all_exploits.extend(exploitdb_exploits)
        
        # Search Nuclei Templates
        log.info("[ExploitDatabaseAgent] Searching Nuclei Templates...")
        nuclei_templates = await self._search_nuclei_templates(cve, keyword, product)
        all_exploits.extend(nuclei_templates)
        
        result = {
            "success": len(all_exploits) > 0,
            "total_exploits": len(all_exploits),
            "github_exploits": len(github_exploits),
            "exploitdb_exploits": len(exploitdb_exploits),
            "nuclei_templates": len(nuclei_templates),
            "exploits": all_exploits[:50],  # Top 50
            "output_file": self._save_results("search", all_exploits)
        }
        
        if all_exploits:
            log.success(f"[ExploitDatabaseAgent] Found {len(all_exploits)} exploits!")
        else:
            log.warning("[ExploitDatabaseAgent] No exploits found")
        
        return result

    async def _search_github(self, cve: Optional[str], keyword: Optional[str], product: Optional[str]) -> List[Dict]:
        """Search GitHub for POC exploits"""
        exploits = []
        
        # Build search query
        search_terms = []
        if cve:
            search_terms.append(cve)
        if keyword:
            search_terms.append(keyword)
        if product:
            search_terms.append(product)
        
        search_terms.append("POC OR exploit OR vulnerability")
        
        query = " ".join(search_terms)
        
        try:
            async with aiohttp.ClientSession() as session:
                params = {
                    "q": query,
                    "sort": "stars",
                    "order": "desc",
                    "per_page": 30
                }
                
                headers = {
                    "Accept": "application/vnd.github.v3+json",
                    "User-Agent": "dLNk-dLNk"
                }
                
                async with session.get(self.github_search_api, params=params, headers=headers, timeout=30) as response:
                    if response.status == 200:
                        data = await response.json()
                        items = data.get("items", [])
                        
                        for item in items:
                            exploits.append({
                                "source": "github",
                                "name": item["name"],
                                "description": item.get("description", ""),
                                "url": item["html_url"],
                                "clone_url": item["clone_url"],
                                "stars": item["stargazers_count"],
                                "updated": item["updated_at"]
                            })
                            
                            log.info(f"[ExploitDatabaseAgent] Found GitHub repo: {item['name']} ({item['stargazers_count']} stars)")
        
        except Exception as e:
            log.error(f"[ExploitDatabaseAgent] GitHub search failed: {e}")
        
        return exploits

    async def _search_exploitdb(self, cve: Optional[str], keyword: Optional[str], product: Optional[str]) -> List[Dict]:
        """Search ExploitDB"""
        exploits = []
        
        # Build search query
        search_term = cve or keyword or product
        
        try:
            # ExploitDB search URL
            search_url = f"https://www.exploit-db.com/search?q={search_term}"
            
            async with aiohttp.ClientSession() as session:
                headers = {
                    "User-Agent": "Mozilla/5.0"
                }
                
                async with session.get(search_url, headers=headers, timeout=30) as response:
                    if response.status == 200:
                        html = await response.text()
                        
                        # Parse HTML for exploit links (basic parsing)
                        # In production, use BeautifulSoup
                        exploit_pattern = r'href="/exploits/(\d+)"'
                        matches = re.findall(exploit_pattern, html)
                        
                        for exploit_id in matches[:20]:  # Top 20
                            exploits.append({
                                "source": "exploitdb",
                                "id": exploit_id,
                                "url": f"https://www.exploit-db.com/exploits/{exploit_id}",
                                "download_url": f"https://www.exploit-db.com/download/{exploit_id}"
                            })
                            
                            log.info(f"[ExploitDatabaseAgent] Found ExploitDB: {exploit_id}")
        
        except Exception as e:
            log.error(f"[ExploitDatabaseAgent] ExploitDB search failed: {e}")
        
        return exploits

    async def _search_nuclei_templates(self, cve: Optional[str], keyword: Optional[str], product: Optional[str]) -> List[Dict]:
        """Search Nuclei templates"""
        templates = []
        
        # Nuclei templates GitHub API
        api_url = "https://api.github.com/repos/projectdiscovery/nuclei-templates/contents"
        
        try:
            async with aiohttp.ClientSession() as session:
                headers = {
                    "Accept": "application/vnd.github.v3+json",
                    "User-Agent": "dLNk-dLNk"
                }
                
                # Search in CVEs directory
                if cve:
                    cves_url = f"{api_url}/cves"
                    async with session.get(cves_url, headers=headers, timeout=30) as response:
                        if response.status == 200:
                            items = await response.json()
                            
                            # Find matching CVE
                            cve_normalized = cve.lower().replace("-", "")
                            
                            for item in items:
                                if cve_normalized in item["name"].lower():
                                    templates.append({
                                        "source": "nuclei",
                                        "name": item["name"],
                                        "url": item["html_url"],
                                        "download_url": item["download_url"],
                                        "type": "cve"
                                    })
                                    
                                    log.info(f"[ExploitDatabaseAgent] Found Nuclei template: {item['name']}")
        
        except Exception as e:
            log.error(f"[ExploitDatabaseAgent] Nuclei search failed: {e}")
        
        return templates

    async def _download_exploits(self, context: Dict) -> Dict:
        """Download exploits"""
        log.info("[ExploitDatabaseAgent] Downloading exploits...")
        
        # First search for exploits
        search_result = await self._search_exploits(context)
        
        if not search_result.get("success"):
            return {
                "success": False,
                "message": "No exploits found to download"
            }
        
        exploits = search_result["exploits"]
        downloaded = []
        
        for exploit in exploits[:10]:  # Download top 10
            source = exploit["source"]
            
            if source == "github":
                # Clone GitHub repo
                clone_url = exploit["clone_url"]
                repo_name = exploit["name"]
                target_dir = os.path.join(self.exploits_dir, f"github_{repo_name}")
                
                if not os.path.exists(target_dir):
                    try:
                        process = await asyncio.create_subprocess_exec(
                            "git", "clone", clone_url, target_dir,
                            stdout=asyncio.subprocess.PIPE,
                            stderr=asyncio.subprocess.PIPE
                        )
                        
                        await process.communicate()
                        
                        if process.returncode == 0:
                            downloaded.append({
                                "source": "github",
                                "name": repo_name,
                                "path": target_dir
                            })
                            log.success(f"[ExploitDatabaseAgent] Downloaded: {repo_name}")
                    
                    except Exception as e:
                        log.error(f"[ExploitDatabaseAgent] Failed to clone {repo_name}: {e}")
            
            elif source == "exploitdb":
                # Download ExploitDB exploit
                download_url = exploit["download_url"]
                exploit_id = exploit["id"]
                target_file = os.path.join(self.exploits_dir, f"exploitdb_{exploit_id}.txt")
                
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(download_url, timeout=30) as response:
                            if response.status == 200:
                                content = await response.read()
                                
                                with open(target_file, "wb") as f:
                                    f.write(content)
                                
                                downloaded.append({
                                    "source": "exploitdb",
                                    "id": exploit_id,
                                    "path": target_file
                                })
                                log.success(f"[ExploitDatabaseAgent] Downloaded: ExploitDB-{exploit_id}")
                
                except Exception as e:
                    log.error(f"[ExploitDatabaseAgent] Failed to download ExploitDB-{exploit_id}: {e}")
            
            elif source == "nuclei":
                # Download Nuclei template
                download_url = exploit["download_url"]
                template_name = exploit["name"]
                target_file = os.path.join(self.exploits_dir, f"nuclei_{template_name}")
                
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(download_url, timeout=30) as response:
                            if response.status == 200:
                                content = await response.read()
                                
                                with open(target_file, "wb") as f:
                                    f.write(content)
                                
                                downloaded.append({
                                    "source": "nuclei",
                                    "name": template_name,
                                    "path": target_file
                                })
                                log.success(f"[ExploitDatabaseAgent] Downloaded: {template_name}")
                
                except Exception as e:
                    log.error(f"[ExploitDatabaseAgent] Failed to download {template_name}: {e}")
        
        result = {
            "success": len(downloaded) > 0,
            "total_downloaded": len(downloaded),
            "downloaded": downloaded,
            "output_file": self._save_results("download", downloaded)
        }
        
        log.success(f"[ExploitDatabaseAgent] Downloaded {len(downloaded)} exploits!")
        return result

    async def _verify_exploits(self, context: Dict) -> Dict:
        """Verify downloaded exploits"""
        log.info("[ExploitDatabaseAgent] Verifying exploits...")
        
        # List all downloaded exploits
        exploit_files = []
        
        for root, dirs, files in os.walk(self.exploits_dir):
            for file in files:
                if file.endswith((".py", ".sh", ".rb", ".pl", ".txt")):
                    exploit_files.append(os.path.join(root, file))
        
        verified = []
        
        for exploit_file in exploit_files:
            # Basic verification
            try:
                with open(exploit_file, "r") as f:
                    content = f.read()
                
                # Check for common exploit indicators
                has_exploit_code = any(keyword in content.lower() for keyword in [
                    "exploit", "payload", "shellcode", "vulnerability",
                    "poc", "cve", "attack", "injection"
                ])
                
                if has_exploit_code:
                    verified.append({
                        "file": exploit_file,
                        "verified": True,
                        "size": os.path.getsize(exploit_file)
                    })
            
            except Exception as e:
                log.debug(f"[ExploitDatabaseAgent] Failed to verify {exploit_file}: {e}")
        
        result = {
            "success": len(verified) > 0,
            "total_files": len(exploit_files),
            "verified_exploits": len(verified),
            "exploits": verified,
            "output_file": self._save_results("verify", verified)
        }
        
        log.success(f"[ExploitDatabaseAgent] Verified {len(verified)} exploits!")
        return result

    async def _update_database(self, context: Dict) -> Dict:
        """Update exploit database"""
        log.info("[ExploitDatabaseAgent] Updating exploit database...")
        
        # Clone/update Nuclei templates
        nuclei_dir = os.path.join(self.exploits_dir, "nuclei-templates")
        
        if os.path.exists(nuclei_dir):
            # Update existing
            try:
                process = await asyncio.create_subprocess_exec(
                    "git", "-C", nuclei_dir, "pull",
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                await process.communicate()
                log.success("[ExploitDatabaseAgent] Updated Nuclei templates")
            
            except Exception as e:
                log.error(f"[ExploitDatabaseAgent] Failed to update Nuclei templates: {e}")
        else:
            # Clone new
            try:
                process = await asyncio.create_subprocess_exec(
                    "git", "clone", self.nuclei_templates_repo, nuclei_dir,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                await process.communicate()
                log.success("[ExploitDatabaseAgent] Cloned Nuclei templates")
            
            except Exception as e:
                log.error(f"[ExploitDatabaseAgent] Failed to clone Nuclei templates: {e}")
        
        result = {
            "success": True,
            "nuclei_templates_dir": nuclei_dir,
            "updated_at": datetime.now().isoformat()
        }
        
        log.success("[ExploitDatabaseAgent] Database updated!")
        return result

    async def execute(self, strategy: Strategy) -> AgentData:
        """Execute exploit database agent"""
        try:
            target = strategy.context.get('target_url', '')
            
            # Call existing method
            if asyncio.iscoroutinefunction(self.run):
                results = await self.run(target)
            else:
                results = self.run(target)
            
            return AgentData(
                agent_name=self.__class__.__name__,
                success=True,
                summary=f"{self.__class__.__name__} completed successfully",
                errors=[],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={'results': results}
            )
        except Exception as e:
            return AgentData(
                agent_name=self.__class__.__name__,
                success=False,
                summary=f"{self.__class__.__name__} failed",
                errors=[str(e)],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={}
            )

    def _save_results(self, operation: str, data: Any) -> str:
        """Save results"""
        filename = f"exploits_{operation}_{int(asyncio.get_event_loop().time())}.json"
        filepath = os.path.join(self.results_dir, filename)
        
        try:
            with open(filepath, "w") as f:
                json.dump(data, f, indent=2)
            return filepath
        except Exception as e:
            log.error(f"[ExploitDatabaseAgent] Failed to save results: {e}")
            return ""

