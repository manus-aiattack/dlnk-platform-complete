"""
Report Generator Service
Generate comprehensive attack reports in various formats
"""

import os
import json
from typing import Dict, Any, List, Optional
from datetime import datetime
from jinja2 import Template
import markdown


class ReportGenerator:
    """Service สำหรับสร้างรายงานการโจมตี"""
    
    def __init__(self, workspace_dir: str):
        self.workspace_dir = workspace_dir
        self.reports_dir = os.path.join(workspace_dir, "reports")
        os.makedirs(self.reports_dir, exist_ok=True)
    
    async def generate_attack_report(
        self, 
        attack_data: Dict[str, Any],
        results: Dict[str, Any],
        format: str = "markdown"
    ) -> str:
        """สร้างรายงานการโจมตี"""
        
        if format == "markdown":
            return await self._generate_markdown_report(attack_data, results)
        elif format == "html":
            return await self._generate_html_report(attack_data, results)
        elif format == "json":
            return await self._generate_json_report(attack_data, results)
        else:
            raise ValueError(f"Unsupported format: {format}")
    
    async def _generate_markdown_report(
        self, 
        attack_data: Dict[str, Any],
        results: Dict[str, Any]
    ) -> str:
        """สร้างรายงานแบบ Markdown"""
        
        template = """
# Penetration Testing Report

**Generated:** {{ timestamp }}  
**Attack ID:** {{ attack_id }}  
**Target:** {{ target_url }}  
**Attack Type:** {{ attack_type }}  
**Status:** {{ status }}

---

## Executive Summary

This report documents a penetration testing engagement conducted against **{{ target_url }}** using the dLNk dLNk Attack Platform. The assessment was performed on {{ started_at }} and completed on {{ completed_at }}.

### Key Findings

- **Total Vulnerabilities Found:** {{ vulnerabilities_count }}
- **Critical Severity:** {{ critical_count }}
- **High Severity:** {{ high_count }}
- **Medium Severity:** {{ medium_count }}
- **Low Severity:** {{ low_count }}
- **Data Exfiltrated:** {{ files_dumped }} files ({{ total_size_mb }} MB)

---

## Attack Timeline

| Event | Timestamp |
|-------|-----------|
| Attack Started | {{ started_at }} |
| Attack Completed | {{ completed_at }} |
| Duration | {{ duration }} seconds |

---

## Vulnerabilities Discovered

{% for vuln in vulnerabilities %}
### {{ loop.index }}. {{ vuln.type }}

**Severity:** {{ vuln.severity | upper }}  
**Location:** {{ vuln.location }}  
**Parameter:** {{ vuln.parameter }}

**Description:**  
{{ vuln.description }}

**Proof of Concept:**
```
{{ vuln.payload }}
```

**Evidence:**
```
{{ vuln.evidence }}
```

**Recommendation:**  
{{ vuln.recommendation }}

---
{% endfor %}

## Agent Execution Summary

{% for agent in agents %}
### {{ agent.name }}

- **Status:** {{ agent.status }}
- **Duration:** {{ agent.duration }}s
- **Findings:** {{ agent.findings_count }}

**Output:**
```
{{ agent.output }}
```

---
{% endfor %}

## Data Exfiltration Summary

{% if files_dumped > 0 %}
### Files Extracted

| File Type | Count | Total Size |
|-----------|-------|------------|
{% for file_type, stats in files_by_type.items() %}
| {{ file_type }} | {{ stats.count }} | {{ stats.size_mb }} MB |
{% endfor %}

### Database Dumps

{% for db in databases %}
- **{{ db.type }}:** {{ db.name }} ({{ db.tables_count }} tables, {{ db.rows_count }} rows)
{% endfor %}

### Credentials Found

{% for cred in credentials %}
- **{{ cred.type }}:** {{ cred.username }} / {{ cred.password }}
{% endfor %}

{% else %}
No data was exfiltrated during this attack.
{% endif %}

---

## Technical Details

### Attack Configuration

```json
{{ config | tojson(indent=2) }}
```

### System Information

- **LLM Model:** {{ llm_model }}
- **Attack Agents Used:** {{ agents_count }}
- **Total Requests Made:** {{ total_requests }}
- **Success Rate:** {{ success_rate }}%

---

## Recommendations

Based on the findings, the following remediation steps are recommended:

{% for rec in recommendations %}
{{ loop.index }}. **{{ rec.title }}**
   - Priority: {{ rec.priority }}
   - {{ rec.description }}
{% endfor %}

---

## Conclusion

This penetration test identified **{{ vulnerabilities_count }}** vulnerabilities in the target system. Immediate action should be taken to address the critical and high-severity findings to prevent potential exploitation by malicious actors.

---

**Report Generated by:** dLNk dLNk Attack Platform v2.0  
**Timestamp:** {{ timestamp }}

---

## Disclaimer

This report contains sensitive security information and should be treated as confidential. The findings and recommendations are based on the assessment conducted at the time of testing and may not reflect the current security posture of the target system.

This penetration test was conducted in accordance with applicable laws and regulations, and with proper authorization from the system owner.
"""
        
        # Prepare data for template
        vulnerabilities = results.get("vulnerabilities", [])
        
        # Count by severity
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "low").lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
        
        # Calculate duration
        started = datetime.fromisoformat(attack_data.get("started_at", datetime.now().isoformat()))
        completed = datetime.fromisoformat(results.get("completed_at", datetime.now().isoformat()))
        duration = (completed - started).total_seconds()
        
        # Prepare template data
        template_data = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "attack_id": attack_data.get("attack_id"),
            "target_url": attack_data.get("target_url"),
            "attack_type": attack_data.get("attack_type"),
            "status": results.get("status", "unknown"),
            "started_at": started.strftime("%Y-%m-%d %H:%M:%S"),
            "completed_at": completed.strftime("%Y-%m-%d %H:%M:%S"),
            "duration": round(duration, 2),
            "vulnerabilities_count": len(vulnerabilities),
            "critical_count": severity_counts["critical"],
            "high_count": severity_counts["high"],
            "medium_count": severity_counts["medium"],
            "low_count": severity_counts["low"],
            "files_dumped": results.get("files_dumped", 0),
            "total_size_mb": round(results.get("total_size_bytes", 0) / (1024**2), 2),
            "vulnerabilities": vulnerabilities,
            "agents": results.get("agents", []),
            "files_by_type": results.get("files_by_type", {}),
            "databases": results.get("databases", []),
            "credentials": results.get("credentials", []),
            "config": attack_data.get("options", {}),
            "llm_model": attack_data.get("llm_model", "mixtral:latest"),
            "agents_count": len(results.get("agents", [])),
            "total_requests": results.get("total_requests", 0),
            "success_rate": round(results.get("success_rate", 0), 2),
            "recommendations": self._generate_recommendations(vulnerabilities)
        }
        
        # Render template
        t = Template(template)
        report = t.render(**template_data)
        
        # Save report
        filename = f"report_{attack_data.get('attack_id')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        filepath = os.path.join(self.reports_dir, filename)
        
        with open(filepath, 'w') as f:
            f.write(report)
        
        return filepath
    
    async def _generate_html_report(
        self, 
        attack_data: Dict[str, Any],
        results: Dict[str, Any]
    ) -> str:
        """สร้างรายงานแบบ HTML"""
        
        # Generate markdown first
        md_report = await self._generate_markdown_report(attack_data, results)
        
        # Read markdown
        with open(md_report, 'r') as f:
            md_content = f.read()
        
        # Convert to HTML
        html_content = markdown.markdown(md_content, extensions=['tables', 'fenced_code'])
        
        # Wrap in HTML template
        html_template = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penetration Testing Report - {{ attack_id }}</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 40px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
        }
        h3 {
            color: #7f8c8d;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        pre code {
            background-color: transparent;
            color: #ecf0f1;
        }
        .severity-critical {
            color: #e74c3c;
            font-weight: bold;
        }
        .severity-high {
            color: #e67e22;
            font-weight: bold;
        }
        .severity-medium {
            color: #f39c12;
            font-weight: bold;
        }
        .severity-low {
            color: #3498db;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
            color: #7f8c8d;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        {{ content }}
        <div class="footer">
            <p><strong>Report Generated by:</strong> dLNk dLNk Attack Platform v2.0</p>
            <p><strong>Timestamp:</strong> {{ timestamp }}</p>
        </div>
    </div>
</body>
</html>
"""
        
        t = Template(html_template)
        html_report = t.render(
            content=html_content,
            attack_id=attack_data.get('attack_id'),
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
        
        # Save HTML report
        filename = f"report_{attack_data.get('attack_id')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        filepath = os.path.join(self.reports_dir, filename)
        
        with open(filepath, 'w') as f:
            f.write(html_report)
        
        return filepath
    
    async def _generate_json_report(
        self, 
        attack_data: Dict[str, Any],
        results: Dict[str, Any]
    ) -> str:
        """สร้างรายงานแบบ JSON"""
        
        report_data = {
            "metadata": {
                "generated_at": datetime.now().isoformat(),
                "generator": "dLNk dLNk Attack Platform v2.0",
                "format_version": "1.0"
            },
            "attack": attack_data,
            "results": results
        }
        
        # Save JSON report
        filename = f"report_{attack_data.get('attack_id')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        filepath = os.path.join(self.reports_dir, filename)
        
        with open(filepath, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        return filepath
    
    def _generate_recommendations(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, str]]:
        """สร้างคำแนะนำจากช่องโหว่ที่พบ"""
        recommendations = []
        
        # Group by type
        vuln_types = {}
        for vuln in vulnerabilities:
            vtype = vuln.get("type", "Unknown")
            if vtype not in vuln_types:
                vuln_types[vtype] = []
            vuln_types[vtype].append(vuln)
        
        # Generate recommendations
        for vtype, vulns in vuln_types.items():
            if "SQL Injection" in vtype:
                recommendations.append({
                    "title": "Fix SQL Injection Vulnerabilities",
                    "priority": "CRITICAL",
                    "description": "Use parameterized queries or prepared statements. Implement input validation and sanitization. Use ORM frameworks where possible."
                })
            
            elif "XSS" in vtype:
                recommendations.append({
                    "title": "Implement XSS Protection",
                    "priority": "HIGH",
                    "description": "Encode all user input before displaying. Use Content Security Policy (CSP). Implement HTTPOnly and Secure flags on cookies."
                })
            
            elif "Authentication" in vtype:
                recommendations.append({
                    "title": "Strengthen Authentication Mechanisms",
                    "priority": "CRITICAL",
                    "description": "Implement strong password policies. Use multi-factor authentication. Avoid default credentials. Implement account lockout mechanisms."
                })
            
            elif "Command Injection" in vtype:
                recommendations.append({
                    "title": "Prevent Command Injection",
                    "priority": "CRITICAL",
                    "description": "Avoid executing system commands with user input. Use safe APIs instead of shell commands. Implement strict input validation and whitelisting."
                })
        
        # Add general recommendations
        recommendations.append({
            "title": "Regular Security Audits",
            "priority": "MEDIUM",
            "description": "Conduct regular penetration testing and security audits. Keep all software and dependencies up to date."
        })
        
        recommendations.append({
            "title": "Security Awareness Training",
            "priority": "MEDIUM",
            "description": "Provide security awareness training to developers and staff. Implement secure coding practices."
        })
        
        return recommendations

