"""
dLNk Attack Platform - Exploit Executor
Executes exploits based on attack plan
"""

import asyncio
from typing import Dict, Any, List
from loguru import logger
from datetime import datetime

from api.database.db_service import db
from agents.sqlmap_agent import SqlmapAgent
from advanced_agents.xss_hunter import XSSHunter
from agents.command_injection_exploiter import CommandInjectionExploiter
from agents.ssrf_agent_weaponized import SSRFAgent
from advanced_agents.auth_bypass import AuthenticationBypassAgent


class ExploitExecutor:
    """Executes exploits according to attack plan"""
    
    def __init__(self):
        self.agents = {
            "SQLMapAgent": SqlmapAgent(),
            "XSSAgent": XSSHunter("http://localhost", "/tmp"),
            "CommandInjectionAgent": CommandInjectionExploiter(),
            "SSRFAgent": SSRFAgent(),
            "AuthBypassAgent": AuthenticationBypassAgent("http://localhost", "/tmp"),
        }
    
    async def execute_plan(
        self,
        attack_id: str,
        attack_plan: Dict[str, Any],
        target_url: str,
        vulnerabilities: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Execute attack plan
        
        Args:
            attack_id: Attack session ID
            attack_plan: Attack plan from AI
            target_url: Target URL
            vulnerabilities: Discovered vulnerabilities
        
        Returns:
            Exploitation results
        """
        logger.info(f"ðŸ’¥ Executing attack plan...")
        logger.info(f"   Steps: {len(attack_plan.get('steps', []))}")
        
        results = {
            "exploits": [],
            "successful_exploits": [],
            "failed_exploits": [],
            "total_attempts": 0,
            "successful_attempts": 0
        }
        
        steps = attack_plan.get("steps", [])
        
        for step in steps:
            logger.info(f"   Step {step['step']}: {step['action']}")
            
            exploit_result = await self._execute_step(
                attack_id,
                step,
                target_url,
                vulnerabilities
            )
            
            results["exploits"].append(exploit_result)
            results["total_attempts"] += 1
            
            if exploit_result.get("success"):
                results["successful_exploits"].append(exploit_result)
                results["successful_attempts"] += 1
                logger.info(f"   âœ… Step {step['step']} succeeded")
            else:
                results["failed_exploits"].append(exploit_result)
                logger.info(f"   âŒ Step {step['step']} failed")
            
            # Save to database
            await db.create_exploit(
                attack_id=attack_id,
                vuln_type=step.get("action", "unknown"),
                agent_name=step.get("agent", "unknown"),
                target_url=target_url,
                payload=step.get("payload", ""),
                success=exploit_result.get("success", False),
                output=str(exploit_result.get("output", "")),
                error_message=exploit_result.get("error")
            )
        
        logger.info(f"âœ… Exploitation complete")
        logger.info(f"   Success: {results['successful_attempts']}/{results['total_attempts']}")
        
        return results
    
    async def _execute_step(
        self,
        attack_id: str,
        step: Dict[str, Any],
        target_url: str,
        vulnerabilities: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Execute single exploitation step"""
        
        agent_name = step.get("agent", "")
        agent = self.agents.get(agent_name)
        
        if not agent:
            return {
                "step": step["step"],
                "action": step["action"],
                "success": False,
                "error": f"Agent {agent_name} not found"
            }
        
        try:
            # Find matching vulnerability
            target = step.get("target", target_url)
            
            # Execute exploit based on agent type
            if agent_name == "SQLMapAgent":
                result = await self._exploit_sql_injection(agent, target, step)
            elif agent_name == "XSSAgent":
                result = await self._exploit_xss(agent, target, step)
            elif agent_name == "CommandInjectionAgent":
                result = await self._exploit_command_injection(agent, target, step)
            elif agent_name == "SSRFAgent":
                result = await self._exploit_ssrf(agent, target, step)
            elif agent_name == "AuthBypassAgent":
                result = await self._exploit_auth_bypass(agent, target, step)
            else:
                result = {"success": False, "error": "Unknown agent"}
            
            return {
                "step": step["step"],
                "action": step["action"],
                "agent": agent_name,
                "target": target,
                **result
            }
        
        except Exception as e:
            logger.error(f"Exploitation failed: {e}")
            return {
                "step": step["step"],
                "action": step["action"],
                "success": False,
                "error": str(e)
            }
    
    async def _exploit_sql_injection(
        self,
        agent: SqlmapAgent,
        target: str,
        step: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Exploit SQL injection"""
        try:
            result = await agent.exploit(target)
            
            return {
                "success": result.get("success", False),
                "output": result.get("data", ""),
                "database": result.get("database"),
                "tables": result.get("tables", []),
                "dumped_data": result.get("dumped_data", {})
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _exploit_xss(
        self,
        agent: XSSHunter,
        target: str,
        step: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Exploit XSS"""
        try:
            payload = step.get("payload", "<script>alert('XSS')</script>")
            result = await agent.exploit(target, payload)
            
            return {
                "success": result.get("success", False),
                "output": result.get("response", ""),
                "payload_executed": result.get("payload_executed", False)
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _exploit_command_injection(
        self,
        agent: CommandInjectionExploiter,
        target: str,
        step: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Exploit command injection"""
        try:
            result = await agent.exploit(target)
            
            return {
                "success": result.get("success", False),
                "output": result.get("output", ""),
                "shell_access": result.get("shell_access", False),
                "reverse_shell": result.get("reverse_shell")
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _exploit_ssrf(
        self,
        agent: SSRFAgent,
        target: str,
        step: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Exploit SSRF"""
        try:
            result = await agent.exploit(target)
            
            return {
                "success": result.get("success", False),
                "output": result.get("response", ""),
                "internal_access": result.get("internal_access", False)
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _exploit_auth_bypass(
        self,
        agent: AuthenticationBypassAgent,
        target: str,
        step: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Exploit authentication bypass"""
        try:
            result = await agent.exploit(target)
            
            return {
                "success": result.get("success", False),
                "output": result.get("response", ""),
                "bypassed": result.get("bypassed", False),
                "access_token": result.get("access_token"),
                "session": result.get("session")
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def post_exploitation(
        self,
        attack_id: str,
        successful_exploits: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Post-exploitation activities
        
        Args:
            attack_id: Attack session ID
            successful_exploits: List of successful exploits
        
        Returns:
            Post-exploitation results
        """
        logger.info(f"ðŸ”“ Running post-exploitation...")
        
        results = {
            "privilege_escalation": [],
            "lateral_movement": [],
            "persistence": [],
            "access_info": {}
        }
        
        # Privilege escalation
        for exploit in successful_exploits:
            if exploit.get("shell_access"):
                priv_esc = await self._attempt_privilege_escalation(exploit)
                results["privilege_escalation"].append(priv_esc)
            
            if exploit.get("database"):
                results["access_info"]["database"] = exploit["database"]
            
            if exploit.get("access_token"):
                results["access_info"]["token"] = exploit["access_token"]
            
            if exploit.get("session"):
                results["access_info"]["session"] = exploit["session"]
        
        logger.info(f"âœ… Post-exploitation complete")
        
        return results
    
    async def _attempt_privilege_escalation(
        self,
        exploit: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Attempt privilege escalation"""
        logger.info("   Attempting privilege escalation...")
        
        # This would contain actual privilege escalation logic
        # For now, return placeholder
        
        return {
            "attempted": True,
            "success": False,
            "method": "kernel_exploit",
            "details": "Privilege escalation attempted"
        }

