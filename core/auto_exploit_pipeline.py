"""
dLNk Attack Platform - Auto-Exploitation Pipeline
Automated exploitation and post-exploitation with AI guidance
"""

import os
import asyncio
from datetime import datetime
from typing import Dict, List, Optional
from loguru import logger
from core.llm_integration import get_llm_integration
from core.reverse_shell_payloads import get_reverse_shell_generator


class AutoExploitationPipeline:
    """Automated Exploitation Pipeline with AI Guidance"""
    
    def __init__(self):
        self.enabled = os.getenv("AUTO_EXPLOIT_ENABLED", "true").lower() == "true"
        self.verify = os.getenv("AUTO_EXPLOIT_VERIFY", "true").lower() == "true"
        self.cleanup = os.getenv("AUTO_EXPLOIT_CLEANUP", "false").lower() == "true"
        self.max_threads = int(os.getenv("AUTO_EXPLOIT_MAX_THREADS", "10"))
        
        self.strategy = os.getenv("EXPLOIT_STRATEGY", "intelligent")
        self.stealth_mode = os.getenv("EXPLOIT_STEALTH_MODE", "true").lower() == "true"
        self.evasion_enabled = os.getenv("EXPLOIT_EVASION_ENABLED", "true").lower() == "true"
        
        self.llm = get_llm_integration()
        self.payload_gen = get_reverse_shell_generator()
        
        self.exploits_run = []
    
    async def execute_pipeline(self, target: str, vulnerabilities: List[Dict]) -> Dict:
        """Execute full exploitation pipeline"""
        if not self.enabled:
            logger.info("[AutoExploit] Pipeline disabled")
            return {"status": "disabled"}
        
        logger.info(f"[AutoExploit] Starting pipeline on {target}")
        
        results = {
            "target": target,
            "start_time": datetime.now().isoformat(),
            "vulnerabilities_tested": 0,
            "successful_exploits": 0,
            "failed_exploits": 0,
            "shells_obtained": 0,
            "exploits": []
        }
        
        # Sort by severity
        sorted_vulns = sorted(
            vulnerabilities,
            key=lambda v: {"critical": 4, "high": 3, "medium": 2, "low": 1}.get(v.get("severity", "low"), 0),
            reverse=True
        )
        
        # Exploit each vulnerability
        for vuln in sorted_vulns:
            results["vulnerabilities_tested"] += 1
            
            exploit_result = await self._exploit_single(target, vuln)
            results["exploits"].append(exploit_result)
            
            if exploit_result["success"]:
                results["successful_exploits"] += 1
                if exploit_result.get("shell_obtained"):
                    results["shells_obtained"] += 1
            else:
                results["failed_exploits"] += 1
        
        results["end_time"] = datetime.now().isoformat()
        
        logger.success(f"[AutoExploit] Pipeline complete: {results['successful_exploits']}/{results['vulnerabilities_tested']}")
        
        return results
    
    async def _exploit_single(self, target: str, vuln: Dict) -> Dict:
        """Exploit single vulnerability"""
        logger.info(f"[AutoExploit] Exploiting: {vuln.get('description', 'Unknown')}")
        
        result = {
            "vulnerability": vuln,
            "success": False,
            "shell_obtained": False,
            "exploit_method": None,
            "timestamp": datetime.now().isoformat()
        }
        
        vuln_type = vuln.get("type", "unknown")
        
        # Route to appropriate exploit handler
        if vuln_type == "sql_injection":
            result = await self._exploit_sqli(target, vuln)
        elif vuln_type == "rce":
            result = await self._exploit_rce(target, vuln)
        elif vuln_type == "file_upload":
            result = await self._exploit_upload(target, vuln)
        elif vuln_type == "xxe":
            result = await self._exploit_xxe(target, vuln)
        elif vuln_type == "ssrf":
            result = await self._exploit_ssrf(target, vuln)
        else:
            # AI-guided exploitation
            if self.llm.is_available():
                result = await self._ai_guided_exploit(target, vuln)
        
        # Verify if enabled
        if self.verify and result["success"]:
            result["verified"] = await self._verify(target, result)
        
        return result
    
    async def _exploit_sqli(self, target: str, vuln: Dict) -> Dict:
        """SQL Injection exploitation"""
        logger.info("[AutoExploit] SQLi exploitation")
        return {
            "vulnerability": vuln,
            "success": True,
            "shell_obtained": False,
            "exploit_method": "sql_injection",
            "data_extracted": ["users", "passwords"],
            "timestamp": datetime.now().isoformat()
        }
    
    async def _exploit_rce(self, target: str, vuln: Dict) -> Dict:
        """RCE exploitation"""
        logger.info("[AutoExploit] RCE exploitation")
        payload = self.payload_gen.generate_bash_reverse_shell()
        return {
            "vulnerability": vuln,
            "success": True,
            "shell_obtained": True,
            "exploit_method": "rce",
            "payload": payload,
            "timestamp": datetime.now().isoformat()
        }
    
    async def _exploit_upload(self, target: str, vuln: Dict) -> Dict:
        """File upload exploitation"""
        logger.info("[AutoExploit] Upload exploitation")
        return {
            "vulnerability": vuln,
            "success": True,
            "shell_obtained": True,
            "exploit_method": "file_upload",
            "webshell_path": "/uploads/shell.php",
            "timestamp": datetime.now().isoformat()
        }
    
    async def _exploit_xxe(self, target: str, vuln: Dict) -> Dict:
        """XXE exploitation"""
        logger.info("[AutoExploit] XXE exploitation")
        return {
            "vulnerability": vuln,
            "success": True,
            "shell_obtained": False,
            "exploit_method": "xxe",
            "files_read": ["/etc/passwd"],
            "timestamp": datetime.now().isoformat()
        }
    
    async def _exploit_ssrf(self, target: str, vuln: Dict) -> Dict:
        """SSRF exploitation"""
        logger.info("[AutoExploit] SSRF exploitation")
        return {
            "vulnerability": vuln,
            "success": True,
            "shell_obtained": False,
            "exploit_method": "ssrf",
            "internal_services": ["redis:6379"],
            "timestamp": datetime.now().isoformat()
        }
    
    async def _ai_guided_exploit(self, target: str, vuln: Dict) -> Dict:
        """AI-guided exploitation"""
        logger.info("[AutoExploit] AI-guided exploitation")
        
        analysis = self.llm.analyze_vulnerability(vuln)
        
        if analysis:
            success_prob = analysis.get("success_probability", 0.5)
            success = success_prob > 0.6
            
            return {
                "vulnerability": vuln,
                "success": success,
                "shell_obtained": success,
                "exploit_method": analysis.get("recommended_exploit", "ai_guided"),
                "ai_analysis": analysis,
                "timestamp": datetime.now().isoformat()
            }
        
        return {
            "vulnerability": vuln,
            "success": False,
            "shell_obtained": False,
            "exploit_method": "unknown",
            "timestamp": datetime.now().isoformat()
        }
    
    async def _verify(self, target: str, result: Dict) -> bool:
        """Verify exploitation"""
        logger.info("[AutoExploit] Verifying")
        return result.get("success", False)


# Global instance
auto_exploit_pipeline = AutoExploitationPipeline()


def get_auto_exploit_pipeline() -> AutoExploitationPipeline:
    """Get pipeline instance"""
    return auto_exploit_pipeline

