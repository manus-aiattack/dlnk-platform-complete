"""
An agent that attempts to exploit a specific, known privilege escalation vector.
"""

import time
from core.logger import log
from core.data_models import Strategy, PrivilegeEscalationVector, PrivilegeEscalationExploiterReport, AttackPhase, ErrorType
from typing import Optional
from core.shell_manager import ShellManager

from core.base_agent import BaseAgent


class PrivilegeEscalationExploiter(BaseAgent):
    supported_phases = [AttackPhase.ESCALATION]
    required_tools = []

    def __init__(self, context_manager=None, orchestrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        self.shell_manager: Optional[ShellManager] = None
        self.report_class = PrivilegeEscalationExploiterReport

    async def setup(self):
        """Asynchronous setup method for PrivilegeEscalationExploiter."""
        self.shell_manager = await self.context_manager.get_context('shell_manager')

    async def run(self, strategy: Strategy, **kwargs) -> PrivilegeEscalationExploiterReport:
        start_time = time.time()
        shell_id = strategy.context.get("shell_id")
        vector = strategy.context.get("vector")

        if not all([shell_id, vector]):
            end_time = time.time()
            return PrivilegeEscalationExploiterReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                shell_id=shell_id,
                vector_type="",
                errors=["Shell ID or vector not provided."],
                error_type=ErrorType.CONFIGURATION,
                summary="Priv-esc exploit failed: Missing shell ID or vector."
            )

        # Pydantic models might be passed as dicts, so convert if necessary
        if isinstance(vector, dict):
            vector = PrivilegeEscalationVector(**vector)

        log.phase(
            f"PrivilegeEscalationExploiter: Attempting to exploit {vector.type} on shell {shell_id}")

        if vector.type == "SUDO_NOPASSWD":
            return await self._exploit_sudo_nopasswd(shell_id, vector, start_time)
        else:
            msg = f"Exploitation for vector type '{vector.type}' is not yet implemented."
            log.warning(msg)
            end_time = time.time()
            return PrivilegeEscalationExploiterReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                shell_id=shell_id,
                vector_type=vector.type,
                errors=[msg],
                error_type=ErrorType.NOT_IMPLEMENTED,
                summary=f"Priv-esc exploit for '{vector.type}' not implemented."
            )

    async def _exploit_sudo_nopasswd(self, shell_id: str, vector: PrivilegeEscalationVector, start_time: float) -> PrivilegeEscalationExploiterReport:
        command = vector.command
        log.info(f"Executing sudo command: {command}")
        try:
            # We send the command but don't wait for a full response, as it might open a new shell
            # A better implementation would handle the new root shell
            await self.shell_manager.send_command(shell_id, command, timeout=10)
            msg = f"Successfully executed sudo command. A root shell may now be available."
            log.success(msg)
            end_time = time.time()
            return PrivilegeEscalationExploiterReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                shell_id=shell_id,
                vector_type=vector.type,
                summary=msg
            )
        except Exception as e:
            end_time = time.time()
            # A timeout is not necessarily a failure here, but other exceptions are
            if "Timeout" in str(e):
                msg = f"Sudo command timed out, which may indicate success. A root shell may be available."
                log.success(msg)
                return PrivilegeEscalationExploiterReport(
                    agent_name=self.__class__.__name__,
                    start_time=start_time,
                    end_time=end_time,
                    shell_id=shell_id,
                    vector_type=vector.type,
                    summary=msg
                )
            error_msg = f"Failed to execute command: {e}"
            log.error(f"Failed to execute sudo command: {e}")
            return PrivilegeEscalationExploiterReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                shell_id=shell_id,
                vector_type=vector.type,
                errors=[error_msg],
                error_type=ErrorType.LOGIC,
                summary=f"Failed to execute sudo command for vector '{vector.type}'."
            )
