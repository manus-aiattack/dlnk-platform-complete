from config import settings

# Late import to avoid circular dependencies
log = None


def _get_logger():
    global log
    if log is None:
        from core.logger import log as logger_instance
        log = logger_instance
    return log


STRINGS = {
    'en': {
        'api_running': "dLNkdLNk API is running.",
        'mission_queued': "Mission queued successfully.",
        'mission_started': "Mission started.",
        'mission_status_error': "Mission not found",
        'redis_connection_error': "Could not connect to Redis: {e}",
        'worker_starting': "Starting dLNkdLNk Worker...",
        'redis_connection_success': "Successfully connected to Redis.",
        'redis_connection_critical_error': "Could not connect to Redis. Is it running on localhost:6379? Error: {e}",
        'waiting_for_mission': "Waiting for new mission on 'missions' queue...",
        'invalid_mission_data': "Invalid mission data received: {mission_json}",
        'mission_dequeued': "De-queued mission {mission_id}. Starting attack on {target_url}.",
        'orchestrator_failed': "Orchestrator failed during mission {mission_id}: {e}",
        'mission_completed': "Mission {mission_id} completed successfully.",
        'redis_connection_lost': "Lost connection to Redis. Retrying in 10 seconds... Error: {e}",
        'worker_loop_error': "An unexpected error occurred in the worker loop: {e}",
        'dashboard_starting': "Starting monitoring dashboard. Press Ctrl+C to exit.",
        'dashboard_stopped': "Monitoring dashboard stopped.",
        'dashboard_refreshing': "--- dLNkdLNk System Dashboard (refreshing every 5s) ---",
        'monitor_agent_starting': "Monitor Agent: Gathering system status...",
        'monitor_redis_error': "Cannot generate report: No connection to Redis.",
        'mission_status_title': "[bold green]Mission Status[/bold green]",
        'mission_id_header': "Mission ID",
        'target_header': "Target",
        'status_header': "Status",
        'active_shells_title': "[bold green]Active C2 Shells[/bold green]",
        'shell_id_header': "Shell ID",
        'remote_address_header': "Remote Address",
        'no_active_shells_text': "No active shells",
        'no_active_shells_color': "dim",
        'pre_flight_starting': "Running pre-flight syntax check on all Python files...",
        'pre_flight_errors': "Syntax errors found in the codebase. Please fix them before starting the application.",
        'pre_flight_abort': "Aborting startup.",
        'pre_flight_success': "Pre-flight syntax check passed successfully.",
        'system_initializing': "System Initializing...",
        'orchestrator_initializing': "Initializing Orchestrator...",
        'starting_attack_loop': "Starting main attack loop...",
        'orchestrator_fatal_error': "A fatal error occurred in the Orchestrator: {e}",
        'repair_agent_failed': "The RuntimeRepairAgent failed to run: {e}",
        'invalid_target_url': "Invalid TARGET_URL: {url}. Could not determine hostname.",
        'bore_setup_starting': "Running Bore setup to get Attacker IP and Port...",
        'bore_waiting': "Waiting for Bore to establish connection...",
        'bore_output': "[bore] {line}",
        'attacker_ip_found': "Real Attacker IP: {ip}, Port: {port}",
        'bore_failed': "Bore process exited unexpectedly. Output: {output}",
        'bore_not_found': "'bore' command not found. Please ensure it is installed and in your system's PATH.",
        'bore_setup_error': "An error occurred during Bore setup: {e}",
        'cycle_starting': "STARTING AUTONOMOUS ATTACK CYCLE {cycle_count}",
        'strategy_loop_starting': "Strategy & Execution Loop: Iteration {i}",
        'strategy_received': "Strategy received: Next agent is '{agent}'",
        'exploit_attempt_starting': "Attempting Exploit with WAF-Bypass Loop...",
        'waf_block_detected': "Initial exploit attempt appears to be blocked by a WAF.",
        'waf_bypass_attempt': "Retrying exploit with WAF bypass payloads...",
        'strategy_stop': "Strategy is to '{agent}'. Breaking strategy loop.",
        'reporting_starting': "Running Threat Assessor & Reporter...",
        'meta_cognition_starting': "Running Meta-Cognition Agent for self-optimization...",
        'cycle_ending': "END OF ATTACK CYCLE {cycle_count}",
        'cooldown_starting': "Cooldown for {seconds} seconds before next cycle...",
        'shutdown_starting': "Shutting down background services...",
        'data_received_from': "Received data from {agent}.",
        'repair_agent_starting': "Repair Agent: Starting syntax scan...",
        'repair_agent_no_files': "Warning: No Python files found to scan.",
        'repair_agent_scan_report_title': "Python Syntax Scan Report",
        'repair_agent_file_path_header': "File Path",
        'repair_agent_status_header': "Status",
        'repair_agent_details_header': "Details",
        'repair_agent_error_status': "[bold red]Error[/bold red]",
        'repair_agent_success_message': "✅ All {file_count} scanned Python files have valid syntax.",
        'repair_agent_error_summary': "Scan complete. Found syntax errors in {error_count} out of {total_files} files.",
        'repair_agent_standalone_start': "Running Repair Agent in standalone mode...",
        'repair_agent_standalone_complete': "Scan complete.",
        'runtime_repair_starting': "Runtime Repair Agent: A runtime error was detected. Analyzing...",
        'runtime_error_caught_title': "[bold yellow]Runtime Error Caught[/bold yellow]",
        'runtime_error_type': "[bold red]Error Type:[/] {error_type}",
        'runtime_error_message': "[bold red]Message:[/] {error_message}",
        'runtime_repair_calling_llm': "Runtime Repair Agent: Calling LLM for error analysis and fix suggestion...",
        'runtime_repair_success': "Runtime Repair Agent: Analysis complete.",
        'runtime_repair_suggestion_title': "[bold green]AI Analysis & Fix Suggestion[/bold green]",
        'runtime_repair_llm_failed': "Runtime Repair Agent: Failed to get analysis from LLM: {e}",
        'shell_agent_failed_context': "ShellAgent failed: 'shell_id' and 'command' must be in the strategy context.",
        'shell_agent_executing_command': "Shell Agent: Executing command '{command}' on shell '{shell_id}'...",
        'shell_agent_command_success': "Shell Agent: Command executed. Output received.",
        'shell_agent_requesting_shells': "Shell Agent: Requesting list of active shells...",
        'shell_agent_found_shells': "Found active shells: {shells}",
        'shell_agent_no_shells': "No active shells found.",
        'dumper_failed_context': "DataDumperAgent failed: 'shell_id' and 'dump_target' must be in the strategy context.",
        'dumper_attempting': "Data Dumper: Attempting to dump '{target}' from shell '{shell_id}'...",
        'dumper_success': "Successfully dumped data from {target}:",
        'dumper_failed': "Failed to dump data from {target}.",
        'persistence_failed_context': "PersistenceAgent failed: 'shell_id' must be in the strategy context.",
        'persistence_attempting': "Persistence Agent: Attempting to establish persistence on shell '{shell_id}'...",
        'persistence_generated_creds': "Generated credentials - User: {username}, Pass: {password}",
        'persistence_invalid_password': "LLM generated an invalid password.",
        'persistence_success': "Persistence established: User '{username}' created with sudo privileges.",
        'persistence_failed': "Failed to establish persistence.",
        'persistence_agent_error': "An error occurred in PersistenceAgent: {e}",
        'exploit_agent_directive': "Exploit Agent: Received directive to generate exploit.",
        'exploit_agent_directive_details': "Directive: {directive}",
        'exploit_agent_using_bypass': "Using {count} WAF bypass payloads provided by the orchestrator.",
        'exploit_agent_calling_llm': "Exploit Agent: Calling LLM to generate conceptual exploit code...",
        'exploit_agent_llm_failed': "LLM failed to generate exploit code.",
        'exploit_agent_success': "Exploit Agent: Successfully generated conceptual exploit code.",
        'exploit_agent_generated_code_title': "--- Generated Exploit Code ---",
        'exploit_agent_generated_code_end': "--- End of Generated Code ---",
        'exploit_agent_llm_error': "Exploit Agent: An error occurred during LLM call: {e}"
    },
    'th': {
        'api_running': "dLNkdLNk API กำลังทำงาน",
        'mission_queued': "จัดคิวภารกิจสำเร็จแล้ว",
        'mission_started': "เริ่มภารกิจแล้ว",
        'mission_status_error': "ไม่พบภารกิจ",
        'redis_connection_error': "ไม่สามารถเชื่อมต่อกับ Redis ได้: {e}",
        'worker_starting': "กำลังเริ่มต้น dLNkdLNk Worker...",
        'redis_connection_success': "เชื่อมต่อกับ Redis สำเร็จแล้ว",
        'redis_connection_critical_error': "ไม่สามารถเชื่อมต่อกับ Redis ได้ Redis กำลังทำงานบน localhost:6379 หรือไม่? ข้อผิดพลาด: {e}",
        'waiting_for_mission': "กำลังรอภารกิจใหม่ในคิว 'missions'...",
        'invalid_mission_data': "ได้รับข้อมูลภารกิจไม่ถูกต้อง: {mission_json}",
        'mission_dequeued': "นำภารกิจ {mission_id} ออกจากคิวแล้ว เริ่มการโจมตี {target_url}",
        'orchestrator_failed': "Orchestrator ล้มเหลวระหว่างภารกิจ {mission_id}: {e}",
        'mission_completed': "ภารกิจ {mission_id} เสร็จสมบูรณ์",
        'redis_connection_lost': "การเชื่อมต่อกับ Redis ขาดหาย กำลังลองใหม่ใน 10 วินาที... ข้อผิดพลาด: {e}",
        'worker_loop_error': "เกิดข้อผิดพลาดที่ไม่คาดคิดในลูปของ worker: {e}",
        'dashboard_starting': "กำลังเริ่มแดชบอร์ดติดตามสถานะ กด Ctrl+C เพื่อออก",
        'dashboard_stopped': "หยุดการทำงานแดชบอร์ดติดตามสถานะแล้ว",
        'dashboard_refreshing': "--- แดชบอร์ดระบบ dLNkdLNk (รีเฟรชทุก 5 วินาที) ---",
        'monitor_agent_starting': "Monitor Agent: กำลังรวบรวมสถานะของระบบ...",
        'monitor_redis_error': "ไม่สามารถสร้างรายงานได้: ไม่มีการเชื่อมต่อกับ Redis",
        'mission_status_title': "[bold green]สถานะภารกิจ[/bold green]",
        'mission_id_header': "ID ภารกิจ",
        'target_header': "เป้าหมาย",
        'status_header': "สถานะ",
        'active_shells_title': "[bold green]Shells ที่ใช้งานอยู่[/bold green]",
        'shell_id_header': "ID Shell",
        'remote_address_header': "ที่อยู่ระยะไกล",
        'no_active_shells_text': "ไม่มี Shell ที่ใช้งานอยู่",
        'no_active_shells_color': "dim",
        'pre_flight_starting': "กำลังตรวจสอบ Syntax ของไฟล์ Python ทั้งหมด...",
        'pre_flight_errors': "พบข้อผิดพลาดทาง Syntax ในโค้ดเบส กรุณาแก้ไขก่อนเริ่มโปรแกรม",
        'pre_flight_abort': "กำลังยกเลิกการเริ่มต้น...",
        'pre_flight_success': "การตรวจสอบ Syntax ผ่านเรียบร้อย",
        'system_initializing': "กำลังเริ่มต้นระบบ...",
        'orchestrator_initializing': "กำลังเริ่มต้น Orchestrator...",
        'starting_attack_loop': "กำลังเริ่มลูปการโจมตีหลัก...",
        'orchestrator_fatal_error': "เกิดข้อผิดพลาดร้ายแรงใน Orchestrator: {e}",
        'repair_agent_failed': "RuntimeRepairAgent ทำงานล้มเหลว: {e}",
        'invalid_target_url': "TARGET_URL ไม่ถูกต้อง: {url} ไม่สามารถหา hostname ได้",
        'bore_setup_starting': "กำลังตั้งค่า Bore เพื่อรับ IP และ Port ของผู้โจมตี...",
        'bore_waiting': "กำลังรอ Bore สร้างการเชื่อมต่อ...",
        'bore_output': "[bore] {line}",
        'attacker_ip_found': "IP จริงของผู้โจมตี: {ip}, Port: {port}",
        'bore_failed': "โปรเซส Bore ออกโดยไม่คาดคิด. Output: {output}",
        'bore_not_found': "ไม่พบคำสั่ง 'bore' กรุณาติดตั้งและตรวจสอบว่าอยู่ใน PATH ของระบบ",
        'bore_setup_error': "เกิดข้อผิดพลาดระหว่างการตั้งค่า Bore: {e}",
        'cycle_starting': "กำลังเริ่มรอบการโจมตีอัตโนมัติที่ {cycle_count}",
        'strategy_loop_starting': "ลูปวางแผนและปฏิบัติการ: รอบที่ {i}",
        'strategy_received': "ได้รับแผน: เอเจนต์ถัดไปคือ '{agent}'",
        'exploit_attempt_starting': "กำลังพยายามเจาะระบบด้วยลูปบายพาส WAF...",
        'waf_block_detected': "การพยายามเจาะระบบครั้งแรกดูเหมือนจะถูกบล็อกโดย WAF",
        'waf_bypass_attempt': "กำลังลองเจาะระบบอีกครั้งด้วยเพย์โหลดบายพาส WAF...",
        'strategy_stop': "แผนคือ '{agent}' กำลังออกจากลูปวางแผน",
        'reporting_starting': "กำลังเริ่ม Threat Assessor & Reporter...",
        'meta_cognition_starting': "กำลังเริ่ม Meta-Cognition Agent เพื่อปรับปรุงตัวเอง...",
        'cycle_ending': "สิ้นสุดรอบการโจมตีที่ {cycle_count}",
        'cooldown_starting': "กำลังพัก {seconds} วินาทีก่อนเริ่มรอบถัดไป...",
        'shutdown_starting': "กำลังปิดบริการพื้นหลัง...",
        'data_received_from': "ได้รับข้อมูลจาก {agent}",
        'repair_agent_starting': "Repair Agent: กำลังเริ่มสแกน Syntax...",
        'repair_agent_no_files': "คำเตือน: ไม่พบไฟล์ Python ที่จะสแกน",
        'repair_agent_scan_report_title': "รายงานการสแกน Syntax ของ Python",
        'repair_agent_file_path_header': "เส้นทางไฟล์",
        'repair_agent_status_header': "สถานะ",
        'repair_agent_details_header': "รายละเอียด",
        'repair_agent_error_status': "[bold red]ข้อผิดพลาด[/bold red]",
        'repair_agent_success_message': "✅ ไฟล์ Python ทั้งหมด {file_count} ไฟล์มี Syntax ที่ถูกต้อง",
        'repair_agent_error_summary': "สแกนเสร็จสิ้น พบข้อผิดพลาดทาง Syntax ใน {error_count} จาก {total_files} ไฟล์",
        'repair_agent_standalone_start': "กำลังรัน Repair Agent ในโหมดเดี่ยว...",
        'repair_agent_standalone_complete': "สแกนเสร็จสิ้น",
        'runtime_repair_starting': "Runtime Repair Agent: ตรวจพบข้อผิดพลาดขณะทำงาน กำลังวิเคราะห์...",
        'runtime_error_caught_title': "[bold yellow]ตรวจพบข้อผิดพลาดขณะทำงาน[/bold yellow]",
        'runtime_error_type': "[bold red]ประเภทข้อผิดพลาด:[/] {error_type}",
        'runtime_error_message': "[bold red]ข้อความ:[/] {error_message}",
        'runtime_repair_calling_llm': "Runtime Repair Agent: กำลังเรียก LLM เพื่อวิเคราะห์ข้อผิดพลาดและแนะนำการแก้ไข...",
        'runtime_repair_success': "Runtime Repair Agent: วิเคราะห์เสร็จสิ้น",
        'runtime_repair_suggestion_title': "[bold green]ผลการวิเคราะห์และคำแนะนำการแก้ไขจาก AI[/bold green]",
        'runtime_repair_llm_failed': "Runtime Repair Agent: ไม่สามารถรับผลการวิเคราะห์จาก LLM: {e}",
        'shell_agent_failed_context': "ShellAgent ล้มเหลว: ต้องมี 'shell_id' และ 'command' ใน context ของ strategy",
        'shell_agent_executing_command': "Shell Agent: กำลังรันคำสั่ง '{command}' บน shell '{shell_id}'...",
        'shell_agent_command_success': "Shell Agent: รันคำสั่งเสร็จสิ้น ได้รับผลลัพธ์",
        'shell_agent_requesting_shells': "Shell Agent: กำลังขอรายชื่อ shell ที่ใช้งานอยู่...",
        'shell_agent_found_shells': "พบ shell ที่ใช้งานอยู่: {shells}",
        'shell_agent_no_shells': "ไม่พบ shell ที่ใช้งานอยู่",
        'dumper_failed_context': "DataDumperAgent ล้มเหลว: ต้องมี 'shell_id' และ 'dump_target' ใน context ของ strategy",
        'dumper_attempting': "Data Dumper: กำลังพยายามดัมพ์ข้อมูล '{target}' จาก shell '{shell_id}'...",
        'dumper_success': "ดัมพ์ข้อมูลจาก {target} สำเร็จแล้ว:",
        'dumper_failed': "ไม่สามารถดัมพ์ข้อมูลจาก {target}",
        'persistence_failed_context': "PersistenceAgent ล้มเหลว: ต้องมี 'shell_id' ใน context ของ strategy",
        'persistence_attempting': "Persistence Agent: กำลังพยายามสร้าง Persistence บน shell '{shell_id}'...",
        'persistence_generated_creds': "สร้างข้อมูลประจำตัว - ผู้ใช้: {username}, รหัสผ่าน: {password}",
        'persistence_invalid_password': "LLM สร้างรหัสผ่านที่ไม่ถูกต้อง",
        'persistence_success': "สร้าง Persistence สำเร็จ: ผู้ใช้ '{username}' ถูกสร้างและมีสิทธิ์ sudo",
        'persistence_failed': "ไม่สามารถสร้าง Persistence",
        'persistence_agent_error': "เกิดข้อผิดพลาดใน PersistenceAgent: {e}",
        'exploit_agent_directive': "Exploit Agent: ได้รับคำสั่งให้สร้าง exploit",
        'exploit_agent_directive_details': "คำสั่ง: {directive}",
        'exploit_agent_using_bypass': "กำลังใช้เพย์โหลดบายพาส WAF {count} รายการจาก orchestrator",
        'exploit_agent_calling_llm': "Exploit Agent: กำลังเรียก LLM เพื่อสร้างโค้ด exploit แนวคิด...",
        'exploit_agent_llm_failed': "LLM ไม่สามารถสร้างโค้ด exploit ได้",
        'exploit_agent_success': "Exploit Agent: สร้างโค้ด exploit แนวคิดสำเร็จแล้ว",
        'exploit_agent_generated_code_title': "--- โค้ด Exploit ที่สร้างขึ้น ---",
        'exploit_agent_generated_code_end': "--- สิ้นสุดโค้d Exploit ---",
        'exploit_agent_llm_error': "Exploit Agent: เกิดข้อผิดพลาดระหว่างการเรียก LLM: {e}"
    }
}


def get_string(key: str, **kwargs) -> str:
    """
    Retrieves a string from the language dictionary based on the configured language.
    Formats the string with any provided keyword arguments.
    """
    lang = settings.LANGUAGE
    # Fallback to English if the key is not in the target language
    template = STRINGS.get(
        lang, STRINGS['en']).get(
        key, STRINGS['en'].get(
            key, f"<TRANSLATION_ERROR: {key}>"))

    try:
        return template.format(**kwargs)
    except KeyError as e:
        logger = _get_logger()
        logger.error(f"Missing formatting key {e} for string '{key}'")
        return f"<{key} - FORMATTING ERROR>"
