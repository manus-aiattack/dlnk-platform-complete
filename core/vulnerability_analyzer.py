import asyncio
import json
import re
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from core.logger import log
from core.exploit_generator import ExploitType, Vulnerability


class SeverityLevel(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class VulnerabilityPattern:
    name: str
    pattern: str
    exploit_type: ExploitType
    severity: SeverityLevel
    confidence: float
    description: str
    remediation: str


@dataclass
class VulnerabilityReport:
    target_url: str
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    vulnerabilities: List[Vulnerability]
    recommendations: List[str]
    risk_score: float


class VulnerabilityAnalyzer:
    def __init__(self, context_manager=None):
        self.context_manager = context_manager
        self.vulnerability_patterns = {}
        self.cve_database = {}
        self.owasp_top10 = {}

    async def initialize(self):
        """Initialize vulnerability analyzer"""
        await self._load_vulnerability_patterns()
        await self._load_cve_database()
        await self._load_owasp_top10()

    async def _load_vulnerability_patterns(self):
        """Load vulnerability detection patterns"""
        self.vulnerability_patterns = {
            "sql_injection": [
                VulnerabilityPattern(
                    name="MySQL Error",
                    pattern=r"mysql_fetch_array|mysql_num_rows|mysql_query",
                    exploit_type=ExploitType.SQL_INJECTION,
                    severity=SeverityLevel.HIGH,
                    confidence=0.9,
                    description="MySQL database error indicating potential SQL injection",
                    remediation="Use parameterized queries and input validation"
                ),
                VulnerabilityPattern(
                    name="Oracle Error",
                    pattern=r"ORA-01756|ORA-00933|ORA-01722",
                    exploit_type=ExploitType.SQL_INJECTION,
                    severity=SeverityLevel.HIGH,
                    confidence=0.9,
                    description="Oracle database error indicating potential SQL injection",
                    remediation="Use parameterized queries and input validation"
                ),
                VulnerabilityPattern(
                    name="PostgreSQL Error",
                    pattern=r"PostgreSQL query failed|PostgreSQL error",
                    exploit_type=ExploitType.SQL_INJECTION,
                    severity=SeverityLevel.HIGH,
                    confidence=0.9,
                    description="PostgreSQL database error indicating potential SQL injection",
                    remediation="Use parameterized queries and input validation"
                )
            ],
            "xss": [
                VulnerabilityPattern(
                    name="Reflected XSS",
                    pattern=r"<script[^>]*>.*?</script>",
                    exploit_type=ExploitType.XSS,
                    severity=SeverityLevel.MEDIUM,
                    confidence=0.8,
                    description="Reflected Cross-Site Scripting vulnerability",
                    remediation="Implement proper output encoding and input validation"
                ),
                VulnerabilityPattern(
                    name="DOM XSS",
                    pattern=r"javascript:|data:|vbscript:",
                    exploit_type=ExploitType.XSS,
                    severity=SeverityLevel.MEDIUM,
                    confidence=0.7,
                    description="DOM-based Cross-Site Scripting vulnerability",
                    remediation="Avoid using innerHTML and implement proper output encoding"
                )
            ],
            "command_injection": [
                VulnerabilityPattern(
                    name="Command Execution",
                    pattern=r"uid=\d+|gid=\d+|total \d+",
                    exploit_type=ExploitType.COMMAND_INJECTION,
                    severity=SeverityLevel.CRITICAL,
                    confidence=0.9,
                    description="Command injection vulnerability confirmed",
                    remediation="Avoid system() calls and use parameterized commands"
                ),
                VulnerabilityPattern(
                    name="Shell Access",
                    pattern=r"root:x:0:0:|bin/bash|bin/sh",
                    exploit_type=ExploitType.COMMAND_INJECTION,
                    severity=SeverityLevel.CRITICAL,
                    confidence=0.95,
                    description="Shell access achieved through command injection",
                    remediation="Implement strict input validation and avoid command execution"
                )
            ],
            "path_traversal": [
                VulnerabilityPattern(
                    name="File Access",
                    pattern=r"root:x:0:0:|\[boot loader\]|bin/bash",
                    exploit_type=ExploitType.PATH_TRAVERSAL,
                    severity=SeverityLevel.HIGH,
                    confidence=0.9,
                    description="Path traversal vulnerability allowing file access",
                    remediation="Implement proper path validation and use whitelist approach"
                )
            ],
            "deserialization": [
                VulnerabilityPattern(
                    name="Java Deserialization",
                    pattern=r"java\.io\.InvalidClassException|java\.io\.StreamCorruptedException",
                    exploit_type=ExploitType.DESERIALIZATION,
                    severity=SeverityLevel.CRITICAL,
                    confidence=0.8,
                    description="Java deserialization vulnerability",
                    remediation="Avoid deserializing untrusted data and use safe serialization"
                )
            ]
        }

    async def _load_cve_database(self):
        """Load CVE database for vulnerability mapping"""
        # This would load from a real CVE database
        # For now, use a simplified mapping
        self.cve_database = {
            "CVE-2021-44228": {
                "name": "Log4Shell",
                "severity": "CRITICAL",
                "description": "Apache Log4j2 remote code execution vulnerability",
                "cvss_score": 10.0
            },
            "CVE-2021-34527": {
                "name": "PrintNightmare",
                "severity": "CRITICAL",
                "description": "Windows Print Spooler remote code execution vulnerability",
                "cvss_score": 9.8
            }
        }

    async def _load_owasp_top10(self):
        """Load OWASP Top 10 vulnerability categories"""
        self.owasp_top10 = {
            "A01": "Broken Access Control",
            "A02": "Cryptographic Failures",
            "A03": "Injection",
            "A04": "Insecure Design",
            "A05": "Security Misconfiguration",
            "A06": "Vulnerable and Outdated Components",
            "A07": "Identification and Authentication Failures",
            "A08": "Software and Data Integrity Failures",
            "A09": "Security Logging and Monitoring Failures",
            "A10": "Server-Side Request Forgery (SSRF)"
        }

    async def analyze_response(self, response_text: str, url: str, parameters: Dict[str, str]) -> List[Vulnerability]:
        """Analyze HTTP response for vulnerabilities"""
        vulnerabilities = []

        try:
            # Check for each vulnerability type
            for vuln_type, patterns in self.vulnerability_patterns.items():
                for pattern in patterns:
                    if re.search(pattern.pattern, response_text, re.IGNORECASE | re.MULTILINE):
                        vulnerability = Vulnerability(
                            type=pattern.exploit_type,
                            location=url,
                            parameters=parameters,
                            severity=pattern.severity.value,
                            confidence=pattern.confidence,
                            description=pattern.description
                        )
                        vulnerabilities.append(vulnerability)

            # Remove duplicates
            unique_vulnerabilities = []
            seen = set()
            for vuln in vulnerabilities:
                key = (vuln.type, vuln.location, vuln.description)
                if key not in seen:
                    seen.add(key)
                    unique_vulnerabilities.append(vuln)

            return unique_vulnerabilities

        except Exception as e:
            log.error(f"Failed to analyze response: {e}")
            return []

    async def analyze_multiple_responses(self, responses: List[Dict[str, Any]]) -> VulnerabilityReport:
        """Analyze multiple HTTP responses and generate comprehensive report"""
        try:
            all_vulnerabilities = []
            target_url = ""

            for response_data in responses:
                response_text = response_data.get("response_text", "")
                url = response_data.get("url", "")
                parameters = response_data.get("parameters", {})

                if not target_url:
                    target_url = url

                vulnerabilities = await self.analyze_response(response_text, url, parameters)
                all_vulnerabilities.extend(vulnerabilities)

            # Generate report
            report = await self._generate_vulnerability_report(target_url, all_vulnerabilities)

            return report

        except Exception as e:
            log.error(f"Failed to analyze multiple responses: {e}")
            return VulnerabilityReport(
                target_url="",
                total_vulnerabilities=0,
                critical_count=0,
                high_count=0,
                medium_count=0,
                low_count=0,
                vulnerabilities=[],
                recommendations=[],
                risk_score=0.0
            )

    async def _generate_vulnerability_report(self, target_url: str, vulnerabilities: List[Vulnerability]) -> VulnerabilityReport:
        """Generate comprehensive vulnerability report"""
        try:
            # Count vulnerabilities by severity
            critical_count = sum(
                1 for v in vulnerabilities if v.severity == "critical")
            high_count = sum(
                1 for v in vulnerabilities if v.severity == "high")
            medium_count = sum(
                1 for v in vulnerabilities if v.severity == "medium")
            low_count = sum(1 for v in vulnerabilities if v.severity == "low")

            # Calculate risk score
            risk_score = await self._calculate_risk_score(vulnerabilities)

            # Generate recommendations
            recommendations = await self._generate_recommendations(vulnerabilities)

            return VulnerabilityReport(
                target_url=target_url,
                total_vulnerabilities=len(vulnerabilities),
                critical_count=critical_count,
                high_count=high_count,
                medium_count=medium_count,
                low_count=low_count,
                vulnerabilities=vulnerabilities,
                recommendations=recommendations,
                risk_score=risk_score
            )

        except Exception as e:
            log.error(f"Failed to generate vulnerability report: {e}")
            return VulnerabilityReport(
                target_url=target_url,
                total_vulnerabilities=0,
                critical_count=0,
                high_count=0,
                medium_count=0,
                low_count=0,
                vulnerabilities=[],
                recommendations=[],
                risk_score=0.0
            )

    async def _calculate_risk_score(self, vulnerabilities: List[Vulnerability]) -> float:
        """Calculate overall risk score"""
        try:
            if not vulnerabilities:
                return 0.0

            # Weighted risk calculation
            severity_weights = {
                "critical": 10.0,
                "high": 7.0,
                "medium": 4.0,
                "low": 1.0
            }

            total_weighted_score = 0.0
            total_weight = 0.0

            for vuln in vulnerabilities:
                weight = severity_weights.get(vuln.severity, 1.0)
                confidence_factor = vuln.confidence

                weighted_score = weight * confidence_factor
                total_weighted_score += weighted_score
                total_weight += weight

            if total_weight == 0:
                return 0.0

            # Normalize to 0-10 scale
            risk_score = (total_weighted_score / total_weight) * 10.0
            return min(risk_score, 10.0)

        except Exception as e:
            log.error(f"Failed to calculate risk score: {e}")
            return 0.0

    async def _generate_recommendations(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Generate security recommendations based on vulnerabilities"""
        try:
            recommendations = []
            vuln_types = set(vuln.type for vuln in vulnerabilities)

            # General recommendations
            if vulnerabilities:
                recommendations.append(
                    "Implement comprehensive input validation and output encoding")
                recommendations.append(
                    "Use parameterized queries for database operations")
                recommendations.append(
                    "Implement proper error handling without information disclosure")
                recommendations.append(
                    "Regular security testing and code reviews")

            # Specific recommendations based on vulnerability types
            if ExploitType.SQL_INJECTION in vuln_types:
                recommendations.append(
                    "Use prepared statements and parameterized queries")
                recommendations.append(
                    "Implement database access controls and least privilege")

            if ExploitType.XSS in vuln_types:
                recommendations.append(
                    "Implement Content Security Policy (CSP)")
                recommendations.append(
                    "Use proper output encoding (HTML, URL, JavaScript)")
                recommendations.append(
                    "Avoid innerHTML and use textContent where possible")

            if ExploitType.COMMAND_INJECTION in vuln_types:
                recommendations.append("Avoid system() and exec() functions")
                recommendations.append("Use parameterized command execution")
                recommendations.append(
                    "Implement strict input validation and whitelisting")

            if ExploitType.PATH_TRAVERSAL in vuln_types:
                recommendations.append("Implement proper path validation")
                recommendations.append(
                    "Use whitelist approach for file access")
                recommendations.append("Avoid user input in file paths")

            if ExploitType.DESERIALIZATION in vuln_types:
                recommendations.append("Avoid deserializing untrusted data")
                recommendations.append(
                    "Use safe serialization formats (JSON, XML)")
                recommendations.append(
                    "Implement integrity checks for serialized data")

            return list(set(recommendations))  # Remove duplicates

        except Exception as e:
            log.error(f"Failed to generate recommendations: {e}")
            return ["Implement comprehensive security measures"]

    async def map_to_owasp_top10(self, vulnerabilities: List[Vulnerability]) -> Dict[str, List[Vulnerability]]:
        """Map vulnerabilities to OWASP Top 10 categories"""
        try:
            owasp_mapping = {
                "A01": [],  # Broken Access Control
                "A02": [],  # Cryptographic Failures
                "A03": [],  # Injection
                "A04": [],  # Insecure Design
                "A05": [],  # Security Misconfiguration
                "A06": [],  # Vulnerable and Outdated Components
                "A07": [],  # Identification and Authentication Failures
                "A08": [],  # Software and Data Integrity Failures
                "A09": [],  # Security Logging and Monitoring Failures
                "A10": []   # Server-Side Request Forgery (SSRF)
            }

            for vuln in vulnerabilities:
                if vuln.type in [ExploitType.SQL_INJECTION, ExploitType.COMMAND_INJECTION]:
                    owasp_mapping["A03"].append(vuln)  # Injection
                elif vuln.type == ExploitType.XSS:
                    owasp_mapping["A03"].append(vuln)  # Injection
                elif vuln.type == ExploitType.PATH_TRAVERSAL:
                    owasp_mapping["A01"].append(vuln)  # Broken Access Control
                elif vuln.type == ExploitType.DESERIALIZATION:
                    # Software and Data Integrity Failures
                    owasp_mapping["A08"].append(vuln)
                else:
                    # Insecure Design (default)
                    owasp_mapping["A04"].append(vuln)

            return owasp_mapping

        except Exception as e:
            log.error(f"Failed to map to OWASP Top 10: {e}")
            return {}

    async def get_vulnerability_statistics(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Get vulnerability statistics and insights"""
        try:
            stats = {
                "total_vulnerabilities": len(vulnerabilities),
                "severity_distribution": {},
                "type_distribution": {},
                "confidence_distribution": {},
                "high_confidence_vulns": 0,
                "critical_vulns": 0,
                "unique_locations": 0
            }

            if not vulnerabilities:
                return stats

            # Severity distribution
            for vuln in vulnerabilities:
                severity = vuln.severity
                stats["severity_distribution"][severity] = stats["severity_distribution"].get(
                    severity, 0) + 1

                if severity == "critical":
                    stats["critical_vulns"] += 1

                if vuln.confidence > 0.8:
                    stats["high_confidence_vulns"] += 1

            # Type distribution
            for vuln in vulnerabilities:
                vuln_type = vuln.type.value
                stats["type_distribution"][vuln_type] = stats["type_distribution"].get(
                    vuln_type, 0) + 1

            # Confidence distribution
            confidence_ranges = {
                "high": 0,    # > 0.8
                "medium": 0,  # 0.5 - 0.8
                "low": 0      # < 0.5
            }

            for vuln in vulnerabilities:
                if vuln.confidence > 0.8:
                    confidence_ranges["high"] += 1
                elif vuln.confidence >= 0.5:
                    confidence_ranges["medium"] += 1
                else:
                    confidence_ranges["low"] += 1

            stats["confidence_distribution"] = confidence_ranges

            # Unique locations
            unique_locations = set(vuln.location for vuln in vulnerabilities)
            stats["unique_locations"] = len(unique_locations)

            return stats

        except Exception as e:
            log.error(f"Failed to get vulnerability statistics: {e}")
            return {}

    async def export_report(self, report: VulnerabilityReport, format: str = "json") -> str:
        """Export vulnerability report in specified format"""
        try:
            if format.lower() == "json":
                return json.dumps({
                    "target_url": report.target_url,
                    "total_vulnerabilities": report.total_vulnerabilities,
                    "critical_count": report.critical_count,
                    "high_count": report.high_count,
                    "medium_count": report.medium_count,
                    "low_count": report.low_count,
                    "risk_score": report.risk_score,
                    "vulnerabilities": [
                        {
                            "type": vuln.type.value,
                            "location": vuln.location,
                            "severity": vuln.severity,
                            "confidence": vuln.confidence,
                            "description": vuln.description
                        }
                        for vuln in report.vulnerabilities
                    ],
                    "recommendations": report.recommendations
                }, indent=2)

            elif format.lower() == "html":
                return await self._generate_html_report(report)

            else:
                return f"Unsupported format: {format}"

        except Exception as e:
            log.error(f"Failed to export report: {e}")
            return f"Error exporting report: {e}"

    async def _generate_html_report(self, report: VulnerabilityReport) -> str:
        """Generate HTML vulnerability report"""
        try:
            html = f"""
            <!DOCTYPE html>
            <html>
            <head>
                <title>Vulnerability Report - {report.target_url}</title>
                <style>
                    body {{ font-family: Arial, sans-serif; margin: 20px; }}
                    .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}
                    .summary {{ margin: 20px 0; }}
                    .vulnerability {{ margin: 10px 0; padding: 10px; border-left: 4px solid #ff0000; background-color: #f9f9f9; }}
                    .critical {{ border-left-color: #ff0000; }}
                    .high {{ border-left-color: #ff6600; }}
                    .medium {{ border-left-color: #ffcc00; }}
                    .low {{ border-left-color: #00cc00; }}
                    .recommendations {{ background-color: #e6f3ff; padding: 15px; border-radius: 5px; }}
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>Vulnerability Report</h1>
                    <p><strong>Target:</strong> {report.target_url}</p>
                    <p><strong>Total Vulnerabilities:</strong> {report.total_vulnerabilities}</p>
                    <p><strong>Risk Score:</strong> {report.risk_score:.2f}/10</p>
                </div>
                
                <div class="summary">
                    <h2>Summary</h2>
                    <ul>
                        <li>Critical: {report.critical_count}</li>
                        <li>High: {report.high_count}</li>
                        <li>Medium: {report.medium_count}</li>
                        <li>Low: {report.low_count}</li>
                    </ul>
                </div>
                
                <div class="vulnerabilities">
                    <h2>Vulnerabilities</h2>
            """

            for vuln in report.vulnerabilities:
                severity_class = vuln.severity.lower()
                html += f"""
                    <div class="vulnerability {severity_class}">
                        <h3>{vuln.type.value.upper()} - {vuln.severity.upper()}</h3>
                        <p><strong>Location:</strong> {vuln.location}</p>
                        <p><strong>Confidence:</strong> {vuln.confidence:.2f}</p>
                        <p><strong>Description:</strong> {vuln.description}</p>
                    </div>
                """

            html += """
                </div>
                
                <div class="recommendations">
                    <h2>Recommendations</h2>
                    <ul>
            """

            for rec in report.recommendations:
                html += f"<li>{rec}</li>"

            html += """
                    </ul>
                </div>
            </body>
            </html>
            """

            return html

        except Exception as e:
            log.error(f"Failed to generate HTML report: {e}")
            return f"Error generating HTML report: {e}"
