# คู่มือปฏิบัติการ dLNk dLNk Framework (ภาษาไทย)

**เวอร์ชั่น:** 3.0 (Final)
**วันที่:** 22 ตุลาคม 2568

**คำเตือน:** เอกสารฉบับนี้จัดทำขึ้นเพื่อการศึกษาและสำหรับผู้ที่ได้รับอนุญาตในการทดสอบระบบเท่านั้น การนำไปใช้ในทางที่ผิดกฎหมายถือเป็นความรับผิดชอบของผู้ใช้งานโดยตรง

## สารบัญ

1. [ภารกิจและปรัชญา](#ภารกิจและปรัชญา)
2. [สถาปัตยกรรมของระบบ](#สถาปัตยกรรมของระบบ)
3. [การติดตั้งและเตรียมพร้อมปฏิบัติการ](#การติดตั้งและเตรียมพร้อมปฏิบัติการ)
4. [คู่มือคำสั่งปฏิบัติการ (Attack Operations)](#คู่มือคำสั่งปฏิบัติการ-attack-operations)
5. [ภาพรวมคลังแสง Agent](#ภาพรวมคลังแสง-agent)
6. [รายละเอียด Weaponized Agents](#รายละเอียด-weaponized-agents)
7. [การสร้างแผนการโจมตี (Workflow)](#การสร้างแผนการโจมตี-workflow)

---

## 1. ภารกิจและปรัชญา

**dLNk dLNk Framework** ถูกพัฒนาขึ้นโดยมีเป้าหมายที่ชัดเจนในการเป็น **แพลตฟอร์มสำหรับปฏิบัติการโจมตีทางไซเบอร์เต็มรูปแบบ (Offensive Security Platform)** ไม่ใช่เป็นเพียงเครื่องมือทดสอบความปลอดภัยทั่วไป ปรัชญาหลักของเฟรมเวิร์กนี้คือ **"Attack, Exploit, Pwn"** ซึ่งหมายถึงการโจมตี, การใช้ประโยชน์จากช่องโหว่, และการเข้ายึดครองระบบเป้าหมายอย่างสมบูรณ์ ภารกิจสูงสุดของเราคือการสร้างระบบที่สามารถดำเนินทุกขั้นตอนของ Cyber Kill Chain ให้เป็นไปโดยอัตโนมัติมากที่สุดเท่าที่จะเป็นไปได้ เพื่อลดภาระงานของนักทดสอบเจาะระบบและเพิ่มประสิทธิภาพในการโจมตีให้ถึงขีดสุด

---

## 2. สถาปัตยกรรมของระบบ

สถาปัตยกรรมของ dLNk dLNk Framework ได้รับการออกแบบมาในลักษณะ Microservices-based เพื่อให้มีความยืดหยุ่นสูง สามารถขยายขีดความสามารถได้ง่าย และทนทานต่อความผิดพลาด (Fault-tolerant) ส่วนประกอบหลักของระบบได้ถูกสรุปไว้ในตารางด้านล่างนี้

| ส่วนประกอบ | หน้าที่ | โมดูลหลักที่เกี่ยวข้อง |
| :--- | :--- | :--- |
| **Orchestrator** | **ผู้บัญชาการกลาง (Central Commander)** ทำหน้าที่ควบคุมแผนการโจมตีทั้งหมด, จัดการลำดับการทำงานของ Agent, และรวบรวมผลลัพธ์ที่ได้จากแต่ละหน่วย | `core/orchestrator.py` |
| **Agents** | **หน่วยรบพิเศษ (Specialized Units)** เป็นโมดูลที่ปฏิบัติการโจมตีเฉพาะทางตามที่ได้รับมอบหมาย เช่น การสแกน, การเจาะระบบ, หรือการยกระดับสิทธิ์ | `agents/*` |
| **Context Manager** | **ศูนย์บัญชาการข้อมูล (Data Hub)** ใช้ Redis เป็นศูนย์กลางในการแชร์ข้อมูล, สถานะ, และผลลัพธ์ระหว่าง Agent เพื่อให้ทำงานร่วมกันได้อย่างราบรื่น | `core/context_manager.py` |
| **Workflows** | **แผนการรบ (Attack Plans)** เป็นไฟล์คอนฟิกในรูปแบบ YAML ที่กำหนดลำดับและเงื่อนไขในการเรียกใช้ Agent ต่างๆ เพื่อให้บรรลุเป้าหมายที่วางไว้ | `config/*.yaml` |
| **License Manager** | **ระบบรักษาความปลอดภัย (Access Control)** ควบคุมการเข้าถึงและการใช้งานเฟรมเวิร์ก เพื่อให้แน่ใจว่าผู้ใช้งานได้รับอนุญาตอย่างถูกต้อง | `core/license_manager.py` |
| **API & Dashboard** | **ส่วนประสานงาน (Interface)** มี RESTful API สำหรับการเชื่อมต่อกับระบบภายนอก และ Web Dashboard สำหรับการควบคุมและแสดงผลแบบ Real-time | `web/api.py`, `web/dashboard.html` |

---

## 3. การติดตั้งและเตรียมพร้อมปฏิบัติการ

เพื่อให้การใช้งานเป็นไปอย่างราบรื่นและมีประสิทธิภาพสูงสุด เราแนะนำให้ทำการติดตั้งผ่าน Docker ซึ่งเป็นวิธีที่ง่ายและรวดเร็วที่สุดในการเตรียมสภาพแวดล้อมสำหรับปฏิบัติการ

### วิธีที่ 1: การติดตั้งด้วย Docker (แนะนำ)

1.  **แตกไฟล์:** เริ่มต้นด้วยการแตกไฟล์ `dlnk_dlnk_framework_v3_final.zip` และเข้าไปยังไดเรกทอรีของโปรเจกต์
    ```bash
    unzip dlnk_dlnk_framework_v3_final.zip && cd dlnk_dlnk
    ```
2.  **เปิดใช้งาน License:** ใช้คำสั่งผ่าน CLI เพื่อเปิดใช้งาน License Key ที่คุณได้รับ
    ```bash
    dlnk-dlnk license activate <YOUR_LICENSE_KEY>
    ```
3.  **สร้างและรัน Container:** ใช้ Docker Compose ในการสร้าง Image และรัน Container ทั้งหมดที่จำเป็นสำหรับเฟรมเวิร์ก
    ```bash
    docker-compose up --build -d
    ```
4.  **ตรวจสอบสถานะ:** ตรวจสอบให้แน่ใจว่า Container ทั้งหมดทำงานอยู่ในสถานะ `Up`
    ```bash
    docker-compose ps
    ```
5.  **เข้าสู่ Dashboard:** เปิดเว็บเบราว์เซอร์และไปที่ `localhost:8000/dashboard` เพื่อเข้าสู่หน้าจอควบคุมหลัก

### วิธีที่ 2: การติดตั้งบนเครื่องโดยตรง (สำหรับนักพัฒนา)

สำหรับนักพัฒนาที่ต้องการแก้ไขหรือพัฒนา Agent เพิ่มเติม สามารถติดตั้งเฟรมเวิร์กบนเครื่องได้โดยตรงตามขั้นตอนต่อไปนี้

1.  **ติดตั้ง Dependencies:** ติดตั้ง Library ที่จำเป็นทั้งหมดผ่าน `pip`
    ```bash
    pip install -r requirements.txt && pip install -e .
    ```
2.  **รัน Redis Server:** ตรวจสอบให้แน่ใจว่า Redis server กำลังทำงานอยู่
    ```bash
    sudo service redis-server start
    ```
3.  **เปิดใช้งาน License และรันเซิร์ฟเวอร์:** เปิดใช้งาน License และเริ่มต้นเซิร์ฟเวอร์หลักของเฟรมเวิร์ก
    ```bash
    dlnk-dlnk license activate <YOUR_LICENSE_KEY>
    dlnk-dlnk server
    ```

---

## 4. คู่มือคำสั่งปฏิบัติการ (Attack Operations)

การสั่งการโจมตีผ่าน Command-Line Interface (CLI) ถูกออกแบบมาให้ง่ายและเป็นขั้นตอน โดยมีโครงสร้างคำสั่งหลักคือ `dlnk-dlnk attack <PHASE> [OPTIONS]`

- **Phase 1: SCAN (สแกนและลาดตระเวน)**
  - **คำสั่ง:** `dlnk-dlnk attack scan --target <URL/IP>`
  - **ปฏิบัติการ:** ในเฟสนี้, เฟรมเวิร์กจะทำการรวบรวมข้อมูลเบื้องต้น (Reconnaissance), สแกนพอร์ตที่เปิดอยู่, ตรวจจับเทคโนโลยีที่เป้าหมายใช้ (Technology Profiling), และสแกนหาช่องโหว่ที่รู้จักในเบื้องต้น ผลลัพธ์ทั้งหมดจะถูกบันทึกไว้ในไฟล์ `scan-<target>.json` เพื่อใช้เป็นข้อมูลสำหรับเฟสต่อไป

- **Phase 2: EXPLOIT (เข้าเจาะและยึดครอง)**
  - **คำสั่ง:** `dlnk-dlnk attack exploit --scan-file <path_to_scan.json>`
  - **ปฏิบัติการ:** Orchestrator จะนำข้อมูลจากเฟส SCAN มาวิเคราะห์และเลือกใช้ Agent ที่เหมาะสมที่สุดในการพยายามเจาะเข้าระบบ หากสำเร็จ, เฟรมเวิร์กจะพยายามสร้าง Reverse Shell กลับมายังเครื่องควบคุม

- **Phase 3: POST-EXPLOIT (ปฏิบัติการหลังยึดครอง)**
  - **คำสั่ง:** `dlnk-dlnk attack post-exploit --exploit-file <path_to_exploit.json>`
  - **ปฏิบัติการ:** หลังจากที่ได้ Shell แล้ว, เฟรมเวิร์กจะเริ่มปฏิบัติการขั้นต่อไปโดยอัตโนมัติ ซึ่งรวมถึงการยกระดับสิทธิ์ (Privilege Escalation), การฝังตัวเพื่อสร้างความคงทน (Persistence), การเคลื่อนที่ภายในเครือข่าย (Lateral Movement), และการขโมยข้อมูล (Data Exfiltration)

- **FULL AUTO ATTACK (ปฏิบัติการโจมตีอัตโนมัติเต็มรูปแบบ)**
  - **คำสั่ง:** `dlnk-dlnk attack full-auto --target <URL/IP>`
  - **ปฏิบัติการ:** นี่คือโหมดการทำงานที่มีประสิทธิภาพสูงสุด โดยจะรัน Workflow `attack_full_auto_workflow.yaml` ซึ่งจะดำเนินทุกเฟสตั้งแต่ต้นจนจบโดยอัตโนมัติ เหมาะสำหรับสถานการณ์ที่ต้องการผลลัพธ์ที่รวดเร็ว

---

## 5. ภาพรวมคลังแสง Agent

คลังแสงของ dLNk dLNk ประกอบด้วย Agent ที่ถูก "Weaponized" หรือติดอาวุธพร้อมใช้งานจริงจำนวน 12 หน่วย แต่ละหน่วยมีความเชี่ยวชาญเฉพาะทางและทำงานร่วมกันภายใต้การควบคุมของ Orchestrator เพื่อให้บรรลุภารกิจการเจาะระบบ

| Agent | ภารกิจหลัก | ประเภทการโจมตี |
| :--- | :--- | :--- |
| **SQLMap Agent** | เจาะช่องโหว่ SQL Injection และดึงข้อมูล | Web Application |
| **XSS Agent** | ค้นหาและสาธิตผลกระทบจาก XSS | Web Application |
| **Cmd Injection Exploiter** | เจาะช่องโหว่ Command Injection เพื่อให้ได้ RCE | Web/System |
| **Deserialization Exploiter**| โจมตี Insecure Deserialization บน Java | Application |
| **Privilege Escalation** | ยกระดับสิทธิ์บนเครื่องเป้าหมาย | Post-Exploitation |
| **Shell Upgrader** | อัปเกรด Shell พื้นฐานให้ใช้งานได้เต็มรูปแบบ | Post-Exploitation |
| **IDOR/BOLA Agent** | ตรวจจับช่องโหว่การเข้าถึงข้อมูลโดยตรงใน API | API Security |
| **SSRF Agent** | ใช้ประโยชน์จากช่องโหว่ SSRF เพื่อโจมตีระบบภายใน | Web Application |
| **Rate Limit Agent** | หลบเลี่ยงการจำกัดจำนวน Request | Web Application |
| **0-day Hunter System** | ค้นหาช่องโหว่ที่ไม่เคยถูกค้นพบมาก่อน (0-day) | Fuzzing/Static Analysis |
| **Exploit Database Agent** | ค้นหาและใช้งาน Exploit ที่มีอยู่แล้ว | Vulnerability Research |
| **WAF Bypass Expert** | ตรวจจับและหลบเลี่ยง Web Application Firewall | Evasion |

---

## 6. รายละเอียด Weaponized Agents

### **SQLMap Agent**
Agent นี้ทำหน้าที่เป็นหน่วยรบแนวหน้าในการโจมตีเว็บแอปพลิเคชัน โดยมีความเชี่ยวชาญในการค้นหาและใช้ประโยชน์จากช่องโหว่ SQL Injection โดยทำงานร่วมกับเครื่องมือ `sqlmap` ที่เป็นมาตรฐานอุตสาหกรรม มันสามารถตรวจจับช่องโหว่ได้ทุกประเภท ตั้งแต่ Error-based ไปจนถึง Blind SQL Injection และเมื่อพบช่องโหว่แล้ว มันจะทำการดึงข้อมูลสำคัญ เช่น ชื่อฐานข้อมูล, ตาราง, และข้อมูลผู้ใช้ ออกมาโดยอัตโนมัติ

### **XSS Agent**
หน่วยรบนี้มีคลังแสง Payload สำหรับ Cross-Site Scripting (XSS) มากกว่า 500 รูปแบบ ทำให้สามารถทดสอบช่องโหว่ได้ทั้งแบบ Reflected, Stored, และ DOM-based ความสามารถที่โดดเด่นคือการทำงานร่วมกับ **WAF Bypass Expert** เพื่อเข้ารหัสและปรับเปลี่ยน Payload ให้สามารถหลบเลี่ยงการตรวจจับของ Firewall ได้อย่างมีประสิทธิภาพ และยังสามารถสร้าง Proof-of-Concept เพื่อยืนยันผลกระทบของช่องโหว่ได้อีกด้วย

### **Command Injection Exploiter**
เมื่อมีโอกาส Agent นี้จะพยายามแทรกแซงคำสั่งของระบบปฏิบัติการเข้าไปยังส่วนต่างๆ ของแอปพลิเคชันเป้าหมายเพื่อเข้าควบคุมเซิร์ฟเวอร์ (Remote Code Execution) ด้วยคลัง Payload กว่า 200 รูปแบบที่ครอบคลุมทั้งระบบปฏิบัติการ Linux และ Windows มันสามารถสร้างและส่ง Reverse Shell กลับมายังเครื่องของ Operator ได้โดยอัตโนมัติ ทำให้สามารถเข้าควบคุมเครื่องเป้าหมายได้ในทันที

### **0-day Hunter System**
นี่คือหน่วยรบพิเศษที่ใช้เทคนิคขั้นสูงในการค้นหาช่องโหว่ที่ไม่เคยถูกค้นพบมาก่อน (0-day) ประกอบด้วย 3 ส่วนหลักคือ: **Fuzzing** โดยใช้ `AFL++` เพื่อหาจุดบกพร่องที่ทำให้โปรแกรมหยุดทำงาน, **Static Analysis** โดยใช้ `Semgrep` เพื่อสแกน Source Code และหาโค้ดที่ไม่ปลอดภัย, และ **Crash Triage & Exploit Generation** ซึ่งจะวิเคราะห์สาเหตุของ Crash และพยายามสร้าง Exploit ต้นแบบขึ้นมาโดยอัตโนมัติด้วย `angr`

---

## 7. การสร้างแผนการโจมตี (Workflow)

(ส่วนนี้จะถูกเพิ่มเติมในภายหลัง พร้อมตัวอย่าง `workflow.yaml` แบบละเอียด)

